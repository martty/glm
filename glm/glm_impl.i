#line 1 ".\\glm_impl.cpp"


#line 1 "C:\\Projects\\glm\\glm\\detail/setup.hpp"
#pragma once


#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\cassert"






#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals.h"





#pragma once


#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals_core.h"





#pragma once








#line 16 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals_core.h"

#line 18 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals_core.h"
#line 19 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals_core.h"










































































































































































































































#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\vcruntime.h"







#pragma once






















#line 32 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\vcruntime.h"

#line 34 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\vcruntime.h"
#line 35 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\vcruntime.h"


    
#line 39 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\vcruntime.h"






    
    

#line 49 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\vcruntime.h"
        


            
        #line 54 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\vcruntime.h"
    #line 55 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\vcruntime.h"
#line 56 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\vcruntime.h"

#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\sal.h"













#pragma once







































































































































#line 151 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\sal.h"



#line 155 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\sal.h"





























#line 185 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\sal.h"


#line 188 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\sal.h"

#line 190 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\sal.h"





#line 196 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\sal.h"



#line 200 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\sal.h"






#line 207 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\sal.h"











#line 219 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\sal.h"








#line 228 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\sal.h"
#line 229 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\sal.h"































































































































































































































































































































































































































































































#pragma region Input Buffer SAL 1 compatibility macros



























































































































































































































































































































































































































































































































































































































































































































































































#pragma endregion Input Buffer SAL 1 compatibility macros

















































































#line 1555 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\sal.h"






























#line 1586 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\sal.h"
























#line 1611 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\sal.h"












#line 1624 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\sal.h"






































#line 1663 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\sal.h"















































































































#line 1775 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\sal.h"






































































































#line 1878 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\sal.h"








































































































































































#line 2047 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\sal.h"





































































































#line 2149 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\sal.h"



















































































































































































































#line 2361 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\sal.h"
extern "C" {




#line 2367 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\sal.h"



































































































































































































































#line 2595 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\sal.h"
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

    
    
    
    

    
    

#line 2634 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\sal.h"









































































































































































































































#line 2868 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\sal.h"









#line 2878 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\sal.h"


    
    
#line 2883 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\sal.h"






#line 2890 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\sal.h"
#line 2891 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\sal.h"






#line 2898 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\sal.h"
#line 2899 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\sal.h"











#line 2911 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\sal.h"

































#line 2945 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\sal.h"






















}
#line 2969 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\sal.h"

#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\concurrencysal.h"


















#pragma once


extern "C" {
#line 24 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\concurrencysal.h"











































































































































































































































































#line 292 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\concurrencysal.h"



#line 296 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\concurrencysal.h"
















































#line 345 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\concurrencysal.h"











































#line 389 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\concurrencysal.h"


}
#line 393 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\concurrencysal.h"

#line 395 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\concurrencysal.h"
#line 2971 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\sal.h"

#line 58 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\vcruntime.h"
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\vadefs.h"










#pragma once



#pragma pack(push, 8)


extern "C" {
#line 20 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\vadefs.h"



#line 24 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\vadefs.h"


    
    
        typedef unsigned __int64  uintptr_t;
    

#line 32 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\vadefs.h"
#line 33 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\vadefs.h"


    
    


        typedef char* va_list;
    #line 41 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\vadefs.h"
#line 42 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\vadefs.h"


    


#line 48 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\vadefs.h"





#line 54 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\vadefs.h"



#line 58 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\vadefs.h"
    
    
#line 61 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\vadefs.h"











#line 73 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\vadefs.h"







#line 81 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\vadefs.h"











#line 93 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\vadefs.h"





#line 99 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\vadefs.h"











#line 111 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\vadefs.h"

    void __cdecl __va_start(va_list* , ...);

    
    



    

#line 122 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\vadefs.h"


} 
#line 126 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\vadefs.h"


    extern "C++"
    {
        template <typename _Ty>
        struct __vcrt_va_list_is_reference
        {
            enum : bool { __the_value = false };
        };

        template <typename _Ty>
        struct __vcrt_va_list_is_reference<_Ty&>
        {
            enum : bool { __the_value = true };
        };

        template <typename _Ty>
        struct __vcrt_va_list_is_reference<_Ty&&>
        {
            enum : bool { __the_value = true };
        };

        template <typename _Ty>
        struct __vcrt_assert_va_start_is_not_reference
        {
            static_assert(!__vcrt_va_list_is_reference<_Ty>::__the_value,
                "va_start argument must not have reference type and must not be parenthesized");
        };
    } 

    





#line 163 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\vadefs.h"

#pragma pack(pop)
#line 59 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\vcruntime.h"






    



    





















#line 92 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\vcruntime.h"

__pragma(pack(push, 8)) extern "C" {




    


        
    #line 103 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\vcruntime.h"
#line 104 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\vcruntime.h"
















    

#line 123 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\vcruntime.h"

#line 125 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\vcruntime.h"
        
    #line 127 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\vcruntime.h"
#line 128 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\vcruntime.h"


    

#line 133 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\vcruntime.h"
        
    #line 135 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\vcruntime.h"
#line 136 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\vcruntime.h"





#line 142 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\vcruntime.h"
    
    
#line 145 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\vcruntime.h"




    
#line 151 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\vcruntime.h"








    


#line 163 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\vcruntime.h"



#line 167 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\vcruntime.h"
    
#line 169 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\vcruntime.h"




    
#line 175 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\vcruntime.h"


    
        
        
    

#line 183 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\vcruntime.h"
#line 184 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\vcruntime.h"






    typedef unsigned __int64 size_t;
    typedef __int64          ptrdiff_t;
    typedef __int64          intptr_t;




#line 198 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\vcruntime.h"


    typedef bool  __vcrt_bool;






#line 208 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\vcruntime.h"



    
#line 213 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\vcruntime.h"


    
#line 217 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\vcruntime.h"


    
#line 221 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\vcruntime.h"








    
        
    

#line 234 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\vcruntime.h"
#line 235 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\vcruntime.h"


    


#line 241 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\vcruntime.h"


    extern "C++"
    {
        template <typename _CountofType, size_t _SizeOfArray>
        char (*__countof_helper(__unaligned _CountofType (&_Array)[_SizeOfArray]))[_SizeOfArray];

        
    }


#line 253 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\vcruntime.h"



#line 257 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\vcruntime.h"


    
        
    

#line 264 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\vcruntime.h"

    


#line 269 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\vcruntime.h"


#line 272 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\vcruntime.h"
        
        
    #line 275 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\vcruntime.h"

    
#line 278 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\vcruntime.h"



#line 282 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\vcruntime.h"



    


        
    

#line 292 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\vcruntime.h"
#line 293 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\vcruntime.h"


    


#line 299 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\vcruntime.h"






#line 306 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\vcruntime.h"


    


        




    #line 317 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\vcruntime.h"
#line 318 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\vcruntime.h"



#line 322 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\vcruntime.h"


    
        
    


#line 330 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\vcruntime.h"
#line 331 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\vcruntime.h"


    void __cdecl __security_init_cookie(void);

    



        void __cdecl __security_check_cookie(  uintptr_t _StackCookie);
        __declspec(noreturn) void __cdecl __report_gsfailure(  uintptr_t _StackCookie);
    #line 342 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\vcruntime.h"
#line 343 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\vcruntime.h"

extern uintptr_t __security_cookie;


    
    
    
#line 351 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\vcruntime.h"

} __pragma(pack(pop))

#line 355 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\vcruntime.h"
#line 254 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals_core.h"
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\xkeycheck.h"





#pragma once






















#line 30 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\xkeycheck.h"





#line 36 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\xkeycheck.h"





#line 42 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\xkeycheck.h"





#line 48 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\xkeycheck.h"





#line 54 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\xkeycheck.h"





#line 60 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\xkeycheck.h"





#line 66 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\xkeycheck.h"





#line 72 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\xkeycheck.h"





#line 78 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\xkeycheck.h"





#line 84 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\xkeycheck.h"





#line 90 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\xkeycheck.h"





#line 96 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\xkeycheck.h"





#line 102 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\xkeycheck.h"





#line 108 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\xkeycheck.h"





#line 114 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\xkeycheck.h"





#line 120 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\xkeycheck.h"





#line 126 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\xkeycheck.h"





#line 132 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\xkeycheck.h"





#line 138 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\xkeycheck.h"





#line 144 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\xkeycheck.h"





#line 150 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\xkeycheck.h"





#line 156 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\xkeycheck.h"





#line 162 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\xkeycheck.h"





#line 168 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\xkeycheck.h"





#line 174 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\xkeycheck.h"





#line 180 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\xkeycheck.h"





#line 186 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\xkeycheck.h"





#line 192 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\xkeycheck.h"





#line 198 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\xkeycheck.h"





#line 204 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\xkeycheck.h"





#line 210 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\xkeycheck.h"





#line 216 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\xkeycheck.h"





#line 222 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\xkeycheck.h"





#line 228 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\xkeycheck.h"





#line 234 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\xkeycheck.h"





#line 240 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\xkeycheck.h"





#line 246 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\xkeycheck.h"





#line 252 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\xkeycheck.h"





#line 258 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\xkeycheck.h"





#line 264 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\xkeycheck.h"





#line 270 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\xkeycheck.h"





#line 276 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\xkeycheck.h"





#line 282 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\xkeycheck.h"





#line 288 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\xkeycheck.h"





#line 294 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\xkeycheck.h"






#line 301 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\xkeycheck.h"





#line 307 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\xkeycheck.h"





#line 313 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\xkeycheck.h"





#line 319 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\xkeycheck.h"





#line 325 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\xkeycheck.h"





#line 331 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\xkeycheck.h"





#line 337 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\xkeycheck.h"





#line 343 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\xkeycheck.h"





#line 349 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\xkeycheck.h"





#line 355 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\xkeycheck.h"





#line 361 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\xkeycheck.h"





#line 367 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\xkeycheck.h"





#line 373 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\xkeycheck.h"





#line 379 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\xkeycheck.h"





#line 385 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\xkeycheck.h"





#line 391 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\xkeycheck.h"





#line 397 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\xkeycheck.h"





#line 403 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\xkeycheck.h"





#line 409 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\xkeycheck.h"





#line 415 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\xkeycheck.h"





#line 421 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\xkeycheck.h"





#line 427 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\xkeycheck.h"





#line 433 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\xkeycheck.h"





#line 439 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\xkeycheck.h"





#line 445 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\xkeycheck.h"





#line 451 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\xkeycheck.h"





#line 457 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\xkeycheck.h"





#line 463 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\xkeycheck.h"





#line 469 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\xkeycheck.h"





#line 475 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\xkeycheck.h"





#line 481 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\xkeycheck.h"





#line 487 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\xkeycheck.h"





#line 493 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\xkeycheck.h"





#line 499 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\xkeycheck.h"





#line 505 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\xkeycheck.h"





#line 511 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\xkeycheck.h"






#line 518 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\xkeycheck.h"





#line 524 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\xkeycheck.h"





#line 530 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\xkeycheck.h"





#line 536 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\xkeycheck.h"






#line 543 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\xkeycheck.h"





#line 549 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\xkeycheck.h"





#line 555 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\xkeycheck.h"







#line 563 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\xkeycheck.h"





#line 569 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\xkeycheck.h"





#line 575 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\xkeycheck.h"





#line 581 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\xkeycheck.h"



#line 585 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\xkeycheck.h"

#line 587 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\xkeycheck.h"
#line 588 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\xkeycheck.h"
#line 255 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals_core.h"




#line 260 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals_core.h"

#line 262 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals_core.h"
#line 263 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals_core.h"



#line 267 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals_core.h"



#line 271 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals_core.h"







#line 279 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals_core.h"
#line 280 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals_core.h"





#line 286 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals_core.h"

#line 288 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals_core.h"

#line 290 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals_core.h"

#line 292 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals_core.h"
#line 293 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals_core.h"







#line 301 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals_core.h"






#line 308 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals_core.h"






#line 315 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals_core.h"



#line 319 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals_core.h"








































#line 360 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals_core.h"















#line 376 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals_core.h"
#line 377 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals_core.h"






#line 384 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals_core.h"
#line 385 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals_core.h"











#line 397 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals_core.h"
#line 398 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals_core.h"







#line 406 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals_core.h"
#line 407 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals_core.h"












#line 420 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals_core.h"


#line 423 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals_core.h"


#line 426 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals_core.h"
#line 427 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals_core.h"



#line 431 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals_core.h"



#line 435 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals_core.h"




#line 440 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals_core.h"

#line 442 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals_core.h"




#line 447 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals_core.h"

#line 449 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals_core.h"




#line 454 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals_core.h"




#line 459 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals_core.h"




#line 464 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals_core.h"




#line 469 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals_core.h"







#line 477 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals_core.h"




#line 482 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals_core.h"













#line 496 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals_core.h"
#line 497 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals_core.h"






#line 504 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals_core.h"










#line 515 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals_core.h"










#line 526 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals_core.h"





#line 532 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals_core.h"










#line 543 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals_core.h"
#line 544 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals_core.h"












#line 558 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals_core.h"

#line 560 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals_core.h"







#line 569 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals_core.h"

#line 571 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals_core.h"









#line 582 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals_core.h"

#line 584 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals_core.h"










#line 596 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals_core.h"

#line 598 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals_core.h"









#line 609 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals_core.h"

#line 611 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals_core.h"











#line 624 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals_core.h"

#line 626 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals_core.h"









#line 637 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals_core.h"

#line 639 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals_core.h"








#line 649 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals_core.h"

#line 651 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals_core.h"








#line 661 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals_core.h"

#line 663 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals_core.h"









#line 674 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals_core.h"

#line 676 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals_core.h"













#line 691 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals_core.h"

#line 693 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals_core.h"








#line 703 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals_core.h"

#line 705 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals_core.h"














#line 721 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals_core.h"

#line 723 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals_core.h"
















#line 740 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals_core.h"













#line 755 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals_core.h"

#line 757 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals_core.h"










#line 769 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals_core.h"

#line 771 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals_core.h"











#line 783 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals_core.h"












#line 796 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals_core.h"























#line 820 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals_core.h"


















#line 839 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals_core.h"














































#line 886 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals_core.h"

#line 888 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals_core.h"



























#line 916 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals_core.h"


















#line 935 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals_core.h"
#line 936 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals_core.h"

























#line 962 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals_core.h"









#line 972 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals_core.h"



#line 976 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals_core.h"



#line 980 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals_core.h"

#line 982 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals_core.h"
#line 983 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals_core.h"
#line 10 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals.h"


#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\crtdbg.h"







#pragma once



#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt.h"







#pragma once



__pragma(pack(push, 8)) extern "C" {









    

#line 25 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt.h"

#line 27 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt.h"
        
    #line 29 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt.h"
#line 30 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt.h"




    
#line 36 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt.h"


    

#line 41 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt.h"

#line 43 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt.h"
        
    #line 45 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt.h"
#line 46 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt.h"



#line 50 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt.h"
    
#line 52 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt.h"


    


#line 58 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt.h"





#line 64 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt.h"
    
#line 66 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt.h"





    
#line 73 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt.h"



#line 77 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt.h"
    
#line 79 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt.h"









    
#line 90 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt.h"













    


        
    #line 108 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt.h"
#line 109 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt.h"



#line 113 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt.h"
    
#line 115 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt.h"



#line 119 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt.h"
    
#line 121 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt.h"



#line 125 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt.h"
    
#line 127 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt.h"









extern "C++"
{
    template<bool _Enable, typename _Ty>
    struct _CrtEnableIf;

    template<typename _Ty>
    struct _CrtEnableIf<true, _Ty>
    {
        typedef _Ty _Type;
    };
}
#line 148 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt.h"


    typedef bool  __crt_bool;






#line 158 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt.h"










    
#line 170 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt.h"



















    

#line 192 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt.h"
        
    #line 194 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt.h"
#line 195 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt.h"



#line 199 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt.h"


    
#line 203 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt.h"


 
  

#line 209 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt.h"
   
  #line 211 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt.h"
 





#line 218 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt.h"
#line 219 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt.h"







    











        
    #line 240 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt.h"
#line 241 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt.h"


    
#line 245 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt.h"


    
        
    

#line 252 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt.h"
#line 253 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt.h"

























 void __cdecl _invalid_parameter_noinfo(void);
 __declspec(noreturn) void __cdecl _invalid_parameter_noinfo_noreturn(void);

__declspec(noreturn)
 void __cdecl _invoke_watson(
      wchar_t const* _Expression,
      wchar_t const* _FunctionName,
      wchar_t const* _FileName,
            unsigned int _LineNo,
            uintptr_t _Reserved);


    



        
        
        
        
        
        
        
        
        
        
        
        

    #line 308 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt.h"
#line 309 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt.h"












    


#line 326 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt.h"



#line 330 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt.h"


    


        


    #line 339 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt.h"
#line 340 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt.h"









    






        
    #line 358 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt.h"
#line 359 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt.h"


    


        
    #line 366 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt.h"
#line 367 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt.h"



#line 371 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt.h"













#line 385 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt.h"















#line 401 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt.h"





    
#line 408 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt.h"



#line 412 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt.h"


    

#line 417 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt.h"
#line 418 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt.h"


    


        


            
        #line 428 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt.h"
    #line 429 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt.h"
#line 430 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt.h"



#line 434 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt.h"





#line 440 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt.h"


    


        



    #line 450 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt.h"
#line 451 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt.h"


    
        
    



#line 460 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt.h"

    
        
        
        
    



#line 470 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt.h"

    
        
              
        

#line 477 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt.h"
    



#line 482 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt.h"

    
        
    



#line 490 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt.h"

    
        
    



#line 498 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt.h"
#line 499 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt.h"


    
#line 503 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt.h"








typedef int                           errno_t;
typedef unsigned short                wint_t;
typedef unsigned short                wctype_t;
typedef long                          __time32_t;
typedef __int64                       __time64_t;

typedef struct __crt_locale_data_public
{
      unsigned short const* _locale_pctype;
      int _locale_mb_cur_max;
               unsigned int _locale_lc_codepage;
} __crt_locale_data_public;

typedef struct __crt_locale_pointers
{
    struct __crt_locale_data*    locinfo;
    struct __crt_multibyte_data* mbcinfo;
} __crt_locale_pointers;

typedef __crt_locale_pointers* _locale_t;

typedef struct _Mbstatet
{ 
    unsigned long _Wchar;
    unsigned short _Byte, _State;
} _Mbstatet;

typedef _Mbstatet mbstate_t;



#line 543 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt.h"



#line 547 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt.h"


    


        typedef __time64_t time_t;
    #line 554 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt.h"
#line 555 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt.h"



    
#line 560 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt.h"


    typedef size_t rsize_t;
#line 564 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt.h"










    

        










        










        










        










        










        










        










        










        










        















        















        
















    














#line 740 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt.h"
#line 741 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt.h"












































































    





































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 1816 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt.h"

        
        
        
        

        

            


            


            


            


            


            


            


            


            



            



            


            


            


            


            


            


            


            


            


            


            



            



            



            


            



            




            

            




            

            




            

            




            

            




            

            




            

            




            

            




            

        











































#line 2006 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt.h"
    #line 2007 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt.h"
#line 2008 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt.h"



} __pragma(pack(pop))
#line 13 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\crtdbg.h"
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\vcruntime_new_debug.h"







#pragma once

#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\vcruntime_new.h"







#pragma once




extern "C++" {

#pragma pack(push, 8)

#pragma warning(push)
#pragma warning(disable: 4985) 













    namespace std
    {
        struct nothrow_t {

            explicit nothrow_t() = default;
#line 38 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\vcruntime_new.h"
        };

        


            extern nothrow_t const nothrow;
        #line 45 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\vcruntime_new.h"
    }
#line 47 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\vcruntime_new.h"

[[nodiscard]]     __declspec(allocator)
void* __cdecl operator new(
    size_t _Size
    );

[[nodiscard]]       __declspec(allocator)
void* __cdecl operator new(
    size_t _Size,
    std::nothrow_t const&
    ) noexcept;

[[nodiscard]]     __declspec(allocator)
void* __cdecl operator new[](
    size_t _Size
    );

[[nodiscard]]       __declspec(allocator)
void* __cdecl operator new[](
    size_t _Size,
    std::nothrow_t const&
    ) noexcept;

void __cdecl operator delete(
    void* _Block
    ) noexcept;

void __cdecl operator delete(
    void* _Block,
    std::nothrow_t const&
    ) noexcept;

void __cdecl operator delete[](
    void* _Block
    ) noexcept;

void __cdecl operator delete[](
    void* _Block,
    std::nothrow_t const&
    ) noexcept;

void __cdecl operator delete(
    void*  _Block,
    size_t _Size
    ) noexcept;

void __cdecl operator delete[](
    void* _Block,
    size_t _Size
    ) noexcept;
































































#pragma warning(push)
#pragma warning(disable: 4577) 
#pragma warning(disable: 4514) 

    
    [[nodiscard]]      
    inline void* __cdecl operator new(size_t _Size,   void* _Where) noexcept
    {
        (void)_Size;
        return _Where;
    }

    inline void __cdecl operator delete(void*, void*) noexcept
    {
        return;
    }
#line 178 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\vcruntime_new.h"


    
    [[nodiscard]]      
    inline void* __cdecl operator new[](size_t _Size,
          void* _Where) noexcept
    {
        (void)_Size;
        return _Where;
    }

    inline void __cdecl operator delete[](void*, void*) noexcept
    {
    }
#line 193 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\vcruntime_new.h"
#pragma warning(pop)



#pragma warning(pop)
#pragma pack(pop)

} 
#line 202 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\vcruntime_new.h"
#line 11 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\vcruntime_new_debug.h"


extern "C++" {

#pragma pack(push, 8)






    [[nodiscard]]      
    __declspec(allocator) void* __cdecl operator new(
            size_t      _Size,
            int         _BlockUse,
          char const* _FileName,
            int         _LineNumber
        );

    [[nodiscard]]      
    __declspec(allocator) void* __cdecl operator new[](
            size_t      _Size,
            int         _BlockUse,
          char const* _FileName,
            int         _LineNumber
        );

    void __cdecl operator delete(
        void*       _Block,
        int         _BlockUse,
        char const* _FileName,
        int         _LineNumber
        ) noexcept;

    void __cdecl operator delete[](
        void*       _Block,
        int         _BlockUse,
        char const* _FileName,
        int         _LineNumber
        ) noexcept;

#line 53 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\vcruntime_new_debug.h"



#pragma pack(pop)

} 
#line 60 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\vcruntime_new_debug.h"
#line 14 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\crtdbg.h"

__pragma(pack(push, 8)) extern "C" {



typedef void* _HFILE; 

























typedef int (__cdecl* _CRT_REPORT_HOOK )(int, char*,    int*);
typedef int (__cdecl* _CRT_REPORT_HOOKW)(int, wchar_t*, int*);





typedef int (__cdecl* _CRT_ALLOC_HOOK)(int, void*, size_t, int, long, unsigned char const*, int);























































typedef void (__cdecl* _CRT_DUMP_CLIENT)(void*, size_t);





struct _CrtMemBlockHeader;

typedef struct _CrtMemState
{
    struct _CrtMemBlockHeader* pBlockHeader;
    size_t lCounts[5];
    size_t lSizes[5];
    size_t lHighWaterCount;
    size_t lTotalCount;
} _CrtMemState;



    
    

    
    

    
    
    
    
    
    
    
    
    
    
    
    
    
























































































#line 235 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\crtdbg.h"










    
    
    
    
    
    
    

    
    
    
    
    
    
    
    

    
    

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

















































































































































































































































































































#line 586 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\crtdbg.h"











    
    
    
    
    
    
    

















































































#line 686 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\crtdbg.h"











    

    
        
    #line 702 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\crtdbg.h"

    
        
    #line 706 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\crtdbg.h"

    
        
    #line 710 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\crtdbg.h"

    
    

    
    

    
    

    
    












































#line 767 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\crtdbg.h"













    
#line 782 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\crtdbg.h"



























} __pragma(pack(pop))
#line 811 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\crtdbg.h"
#line 13 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals.h"
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\crtdefs.h"




















    

#line 24 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\crtdefs.h"
        
    #line 26 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\crtdefs.h"
#line 27 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\crtdefs.h"



    

#line 33 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\crtdefs.h"
        
    #line 35 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\crtdefs.h"
#line 36 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\crtdefs.h"



    

#line 42 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\crtdefs.h"
        
    #line 44 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\crtdefs.h"
#line 45 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\crtdefs.h"





    


#line 54 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\crtdefs.h"


#line 57 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\crtdefs.h"
        
        
    #line 60 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\crtdefs.h"
#line 61 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\crtdefs.h"


    

#line 66 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\crtdefs.h"
        

#line 69 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\crtdefs.h"
            
        #line 71 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\crtdefs.h"
    #line 72 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\crtdefs.h"
#line 73 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\crtdefs.h"


    

#line 78 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\crtdefs.h"

#line 80 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\crtdefs.h"
        
    #line 82 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\crtdefs.h"
#line 83 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\crtdefs.h"
#line 14 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals.h"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4472 4494 4514 4571 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4702 4793 4820 4988 5026 5027 5045  4984 5053 )












#line 31 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals.h"

#line 33 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals.h"
















#line 50 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals.h"
#line 51 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals.h"
#line 52 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals.h"






















































#line 107 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals.h"
#line 108 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals.h"









#line 118 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals.h"

#line 120 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals.h"
#line 121 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals.h"




#line 126 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals.h"

#line 128 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals.h"

#line 130 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals.h"

#line 132 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals.h"



#pragma detect_mismatch("_MSC_VER", "1900")
#line 137 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals.h"


#pragma detect_mismatch("_ITERATOR_DEBUG_LEVEL", "0")
#line 141 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals.h"



#pragma detect_mismatch("RuntimeLibrary", "MT_StaticRelease")






#line 152 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals.h"
#line 153 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals.h"
#line 154 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals.h"












#line 167 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals.h"
#line 168 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals.h"






#line 175 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals.h"
#line 176 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals.h"



#line 180 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals.h"





















#line 202 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals.h"





#line 208 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals.h"

#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\use_ansi.h"





#pragma once








#line 16 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\use_ansi.h"
















#line 33 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\use_ansi.h"



#line 37 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\use_ansi.h"




#line 42 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\use_ansi.h"
#line 43 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\use_ansi.h"




#line 48 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\use_ansi.h"

#pragma comment(lib, "libcpmt" "" "")






#line 57 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\use_ansi.h"

#line 59 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\use_ansi.h"

#line 61 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\use_ansi.h"
#line 210 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals.h"



















#line 230 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals.h"






#line 237 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals.h"
#line 238 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals.h"



#line 242 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals.h"






#line 249 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals.h"
#line 250 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals.h"












#line 263 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals.h"

#line 265 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals.h"

#line 267 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals.h"
#line 268 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals.h"






#line 275 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals.h"
#line 276 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals.h"






#line 283 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals.h"
#line 284 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals.h"




#line 289 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals.h"

#line 291 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals.h"
#line 292 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals.h"
















namespace std {
enum _Uninitialized { 
    _Noinit
};


class  _Lockit { 
public:














    __thiscall _Lockit() noexcept;
    explicit __thiscall _Lockit(int) noexcept; 
    __thiscall ~_Lockit() noexcept; 
#line 334 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals.h"

    static void __cdecl _Lockit_ctor(int) noexcept;
    static void __cdecl _Lockit_dtor(int) noexcept;

private:
    static void __cdecl _Lockit_ctor(_Lockit*) noexcept;
    static void __cdecl _Lockit_ctor(_Lockit*, int) noexcept;
    static void __cdecl _Lockit_dtor(_Lockit*) noexcept;

public:
     _Lockit(const _Lockit&) = delete;
    _Lockit&  operator=(const _Lockit&) = delete;

private:
    int _Locktype;
};








































































#line 423 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals.h"

class  _Init_locks { 
public:










    __thiscall _Init_locks() noexcept;
    __thiscall ~_Init_locks() noexcept;
#line 439 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals.h"

private:
    static void __cdecl _Init_locks_ctor(_Init_locks*) noexcept;
    static void __cdecl _Init_locks_dtor(_Init_locks*) noexcept;
};






































#line 483 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals.h"
}
#line 485 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals.h"







#pragma warning(pop)
#pragma pack(pop)
#line 495 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals.h"
#line 496 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\yvals.h"
#line 8 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\cassert"

#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\assert.h"









#line 11 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\assert.h"



__pragma(pack(push, 8)) extern "C" {











     void __cdecl _wassert(
          wchar_t const* _Message,
          wchar_t const* _File,
            unsigned       _Line
        );

    




#line 38 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\assert.h"



} __pragma(pack(pop))
#line 10 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\cassert"
#line 5 "C:\\Projects\\glm\\glm\\detail/setup.hpp"
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\cstddef"





#pragma once





#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stddef.h"







#pragma once





__pragma(pack(push, 8)) extern "C" {




    namespace std
    {
        typedef decltype(__nullptr) nullptr_t;
    }

    using ::std::nullptr_t;
#line 26 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stddef.h"





     int* __cdecl _errno(void);
    

     errno_t __cdecl _set_errno(  int _Value);
     errno_t __cdecl _get_errno(  int* _Value);

#line 38 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stddef.h"









#line 48 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stddef.h"
    
#line 50 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stddef.h"

 extern unsigned long  __cdecl __threadid(void);

 extern uintptr_t __cdecl __threadhandle(void);



} __pragma(pack(pop))
#line 59 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stddef.h"
#line 13 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\cstddef"
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\xtr1common"





#pragma once





#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4472 4494 4514 4571 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4702 4793 4820 4988 5026 5027 5045  4984 5053 )




namespace std {

template <class _Ty, _Ty _Val>
struct integral_constant {
    static constexpr _Ty value = _Val;

    using value_type = _Ty;
    using type       = integral_constant;

    constexpr operator value_type() const noexcept {
        return value;
    }

    [[nodiscard]] constexpr value_type operator()() const noexcept {
        return value;
    }
};


template <bool _Val>
using bool_constant = integral_constant<bool, _Val>;

using true_type  = bool_constant<true>;
using false_type = bool_constant<false>;


template <bool _Test, class _Ty = void>
struct enable_if {}; 

template <class _Ty>
struct enable_if<true, _Ty> { 
    using type = _Ty;
};

template <bool _Test, class _Ty = void>
using enable_if_t = typename enable_if<_Test, _Ty>::type;


template <bool _Test, class _Ty1, class _Ty2>
struct conditional { 
    using type = _Ty1;
};

template <class _Ty1, class _Ty2>
struct conditional<false, _Ty1, _Ty2> {
    using type = _Ty2;
};

template <bool _Test, class _Ty1, class _Ty2>
using conditional_t = typename conditional<_Test, _Ty1, _Ty2>::type;









template <class, class>
 constexpr bool is_same_v = false; 
template <class _Ty>
 constexpr bool is_same_v<_Ty, _Ty> = true;

template <class _Ty1, class _Ty2>
struct is_same : bool_constant<is_same_v<_Ty1, _Ty2>> {};
#line 86 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\xtr1common"


template <class _Ty>
struct remove_const { 
    using type = _Ty;
};

template <class _Ty>
struct remove_const<const _Ty> {
    using type = _Ty;
};

template <class _Ty>
using remove_const_t = typename remove_const<_Ty>::type;


template <class _Ty>
struct remove_volatile { 
    using type = _Ty;
};

template <class _Ty>
struct remove_volatile<volatile _Ty> {
    using type = _Ty;
};

template <class _Ty>
using remove_volatile_t = typename remove_volatile<_Ty>::type;


template <class _Ty>
struct remove_cv { 
    using type = _Ty;

    template <template <class> class _Fn>
    using _Apply = _Fn<_Ty>; 
};

template <class _Ty>
struct remove_cv<const _Ty> {
    using type = _Ty;

    template <template <class> class _Fn>
    using _Apply = const _Fn<_Ty>;
};

template <class _Ty>
struct remove_cv<volatile _Ty> {
    using type = _Ty;

    template <template <class> class _Fn>
    using _Apply = volatile _Fn<_Ty>;
};

template <class _Ty>
struct remove_cv<const volatile _Ty> {
    using type = _Ty;

    template <template <class> class _Fn>
    using _Apply = const volatile _Fn<_Ty>;
};

template <class _Ty>
using remove_cv_t = typename remove_cv<_Ty>::type;


template <bool _First_value, class _First, class... _Rest>
struct _Disjunction { 
    using type = _First;
};

template <class _False, class _Next, class... _Rest>
struct _Disjunction<false, _False, _Next, _Rest...> { 
    using type = typename _Disjunction<_Next::value, _Next, _Rest...>::type;
};

template <class... _Traits>
struct disjunction : false_type {}; 

template <class _First, class... _Rest>
struct disjunction<_First, _Rest...> : _Disjunction<_First::value, _First, _Rest...>::type {
    
};

template <class... _Traits>
 constexpr bool disjunction_v = disjunction<_Traits...>::value;


template <class _Ty, class... _Types>
 constexpr bool _Is_any_of_v = 
    disjunction_v<is_same<_Ty, _Types>...>;


template <class _Ty>
 constexpr bool is_integral_v = _Is_any_of_v<remove_cv_t<_Ty>, bool, char, signed char, unsigned char,
    wchar_t,



    char16_t, char32_t, short, unsigned short, int, unsigned int, long, unsigned long, long long, unsigned long long>;

template <class _Ty>
struct is_integral : bool_constant<is_integral_v<_Ty>> {};


template <class _Ty>
 constexpr bool is_floating_point_v = _Is_any_of_v<remove_cv_t<_Ty>, float, double, long double>;

template <class _Ty>
struct is_floating_point : bool_constant<is_floating_point_v<_Ty>> {};


template <class _Ty>
 constexpr bool is_arithmetic_v = 
    is_integral_v<_Ty> || is_floating_point_v<_Ty>;

template <class _Ty>
struct is_arithmetic : bool_constant<is_arithmetic_v<_Ty>> {};


template <class _Ty>
struct remove_reference {
    using type                 = _Ty;
    using _Const_thru_ref_type = const _Ty;
};

template <class _Ty>
struct remove_reference<_Ty&> {
    using type                 = _Ty;
    using _Const_thru_ref_type = const _Ty&;
};

template <class _Ty>
struct remove_reference<_Ty&&> {
    using type                 = _Ty;
    using _Const_thru_ref_type = const _Ty&&;
};

template <class _Ty>
using remove_reference_t = typename remove_reference<_Ty>::type;


template <class _Ty>
using _Const_thru_ref = typename remove_reference<_Ty>::_Const_thru_ref_type;

template <class _Ty>
using _Remove_cvref_t = remove_cv_t<remove_reference_t<_Ty>>;









#line 243 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\xtr1common"

}


#pragma warning(pop)
#pragma pack(pop)
#line 250 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\xtr1common"
#line 251 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\xtr1common"
#line 14 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\cstddef"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4472 4494 4514 4571 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4702 4793 4820 4988 5026 5027 5045  4984 5053 )




namespace std {
using :: ptrdiff_t;
using :: size_t;
using max_align_t = double; 

































































#line 92 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\cstddef"

}

using ::std:: max_align_t; 



#pragma warning(pop)
#pragma pack(pop)

#line 103 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\cstddef"
#line 104 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\cstddef"
#line 6 "C:\\Projects\\glm\\glm\\detail/setup.hpp"





















#line 28 "C:\\Projects\\glm\\glm\\detail/setup.hpp"

#line 30 "C:\\Projects\\glm\\glm\\detail/setup.hpp"




#line 1 "C:\\Projects\\glm\\glm\\detail\\../simd/platform.h"
#pragma once




















#line 23 "C:\\Projects\\glm\\glm\\detail\\../simd/platform.h"

#line 25 "C:\\Projects\\glm\\glm\\detail\\../simd/platform.h"

#line 27 "C:\\Projects\\glm\\glm\\detail\\../simd/platform.h"

#line 29 "C:\\Projects\\glm\\glm\\detail\\../simd/platform.h"











#line 41 "C:\\Projects\\glm\\glm\\detail\\../simd/platform.h"
















































































#line 122 "C:\\Projects\\glm\\glm\\detail\\../simd/platform.h"














#line 137 "C:\\Projects\\glm\\glm\\detail\\../simd/platform.h"



#line 141 "C:\\Projects\\glm\\glm\\detail\\../simd/platform.h"





































#line 179 "C:\\Projects\\glm\\glm\\detail\\../simd/platform.h"






















#line 202 "C:\\Projects\\glm\\glm\\detail\\../simd/platform.h"

























#line 228 "C:\\Projects\\glm\\glm\\detail\\../simd/platform.h"














































#line 275 "C:\\Projects\\glm\\glm\\detail\\../simd/platform.h"






#line 282 "C:\\Projects\\glm\\glm\\detail\\../simd/platform.h"


#line 285 "C:\\Projects\\glm\\glm\\detail\\../simd/platform.h"


#line 288 "C:\\Projects\\glm\\glm\\detail\\../simd/platform.h"


#line 291 "C:\\Projects\\glm\\glm\\detail\\../simd/platform.h"


#line 294 "C:\\Projects\\glm\\glm\\detail\\../simd/platform.h"


#line 297 "C:\\Projects\\glm\\glm\\detail\\../simd/platform.h"


#line 300 "C:\\Projects\\glm\\glm\\detail\\../simd/platform.h"


#line 303 "C:\\Projects\\glm\\glm\\detail\\../simd/platform.h"


#line 306 "C:\\Projects\\glm\\glm\\detail\\../simd/platform.h"





























#line 336 "C:\\Projects\\glm\\glm\\detail\\../simd/platform.h"










#line 347 "C:\\Projects\\glm\\glm\\detail\\../simd/platform.h"
#line 348 "C:\\Projects\\glm\\glm\\detail\\../simd/platform.h"



#line 352 "C:\\Projects\\glm\\glm\\detail\\../simd/platform.h"

#line 354 "C:\\Projects\\glm\\glm\\detail\\../simd/platform.h"




#line 359 "C:\\Projects\\glm\\glm\\detail\\../simd/platform.h"

#line 361 "C:\\Projects\\glm\\glm\\detail\\../simd/platform.h"

#line 363 "C:\\Projects\\glm\\glm\\detail\\../simd/platform.h"

#line 365 "C:\\Projects\\glm\\glm\\detail\\../simd/platform.h"

#line 367 "C:\\Projects\\glm\\glm\\detail\\../simd/platform.h"

#line 369 "C:\\Projects\\glm\\glm\\detail\\../simd/platform.h"













#line 383 "C:\\Projects\\glm\\glm\\detail\\../simd/platform.h"




#line 388 "C:\\Projects\\glm\\glm\\detail\\../simd/platform.h"




#line 393 "C:\\Projects\\glm\\glm\\detail\\../simd/platform.h"





#line 399 "C:\\Projects\\glm\\glm\\detail\\../simd/platform.h"
#line 35 "C:\\Projects\\glm\\glm\\detail/setup.hpp"










#line 46 "C:\\Projects\\glm\\glm\\detail/setup.hpp"



#line 50 "C:\\Projects\\glm\\glm\\detail/setup.hpp"
































#line 83 "C:\\Projects\\glm\\glm\\detail/setup.hpp"



#line 87 "C:\\Projects\\glm\\glm\\detail/setup.hpp"


#line 90 "C:\\Projects\\glm\\glm\\detail/setup.hpp"


#line 93 "C:\\Projects\\glm\\glm\\detail/setup.hpp"


#line 96 "C:\\Projects\\glm\\glm\\detail/setup.hpp"


#line 99 "C:\\Projects\\glm\\glm\\detail/setup.hpp"

#line 101 "C:\\Projects\\glm\\glm\\detail/setup.hpp"

#line 103 "C:\\Projects\\glm\\glm\\detail/setup.hpp"











#line 115 "C:\\Projects\\glm\\glm\\detail/setup.hpp"


#line 118 "C:\\Projects\\glm\\glm\\detail/setup.hpp"



#line 122 "C:\\Projects\\glm\\glm\\detail/setup.hpp"

#line 124 "C:\\Projects\\glm\\glm\\detail/setup.hpp"









#line 134 "C:\\Projects\\glm\\glm\\detail/setup.hpp"
#line 135 "C:\\Projects\\glm\\glm\\detail/setup.hpp"











#line 147 "C:\\Projects\\glm\\glm\\detail/setup.hpp"





#line 153 "C:\\Projects\\glm\\glm\\detail/setup.hpp"






#line 160 "C:\\Projects\\glm\\glm\\detail/setup.hpp"




#line 165 "C:\\Projects\\glm\\glm\\detail/setup.hpp"





#line 171 "C:\\Projects\\glm\\glm\\detail/setup.hpp"









#line 181 "C:\\Projects\\glm\\glm\\detail/setup.hpp"




#line 186 "C:\\Projects\\glm\\glm\\detail/setup.hpp"






#line 193 "C:\\Projects\\glm\\glm\\detail/setup.hpp"




#line 198 "C:\\Projects\\glm\\glm\\detail/setup.hpp"





#line 204 "C:\\Projects\\glm\\glm\\detail/setup.hpp"




#line 209 "C:\\Projects\\glm\\glm\\detail/setup.hpp"






#line 216 "C:\\Projects\\glm\\glm\\detail/setup.hpp"




#line 221 "C:\\Projects\\glm\\glm\\detail/setup.hpp"





#line 227 "C:\\Projects\\glm\\glm\\detail/setup.hpp"




#line 232 "C:\\Projects\\glm\\glm\\detail/setup.hpp"






#line 239 "C:\\Projects\\glm\\glm\\detail/setup.hpp"




#line 244 "C:\\Projects\\glm\\glm\\detail/setup.hpp"






#line 251 "C:\\Projects\\glm\\glm\\detail/setup.hpp"




#line 256 "C:\\Projects\\glm\\glm\\detail/setup.hpp"






#line 263 "C:\\Projects\\glm\\glm\\detail/setup.hpp"




#line 268 "C:\\Projects\\glm\\glm\\detail/setup.hpp"






#line 275 "C:\\Projects\\glm\\glm\\detail/setup.hpp"





#line 281 "C:\\Projects\\glm\\glm\\detail/setup.hpp"

#line 283 "C:\\Projects\\glm\\glm\\detail/setup.hpp"





#line 289 "C:\\Projects\\glm\\glm\\detail/setup.hpp"





#line 295 "C:\\Projects\\glm\\glm\\detail/setup.hpp"









#line 305 "C:\\Projects\\glm\\glm\\detail/setup.hpp"

#line 307 "C:\\Projects\\glm\\glm\\detail/setup.hpp"

#line 309 "C:\\Projects\\glm\\glm\\detail/setup.hpp"


#line 312 "C:\\Projects\\glm\\glm\\detail/setup.hpp"



#line 316 "C:\\Projects\\glm\\glm\\detail/setup.hpp"

#line 318 "C:\\Projects\\glm\\glm\\detail/setup.hpp"








#line 327 "C:\\Projects\\glm\\glm\\detail/setup.hpp"











#line 339 "C:\\Projects\\glm\\glm\\detail/setup.hpp"






#line 346 "C:\\Projects\\glm\\glm\\detail/setup.hpp"

#line 348 "C:\\Projects\\glm\\glm\\detail/setup.hpp"

































#line 382 "C:\\Projects\\glm\\glm\\detail/setup.hpp"








#line 391 "C:\\Projects\\glm\\glm\\detail/setup.hpp"





#line 397 "C:\\Projects\\glm\\glm\\detail/setup.hpp"










#line 408 "C:\\Projects\\glm\\glm\\detail/setup.hpp"







#line 416 "C:\\Projects\\glm\\glm\\detail/setup.hpp"


#line 419 "C:\\Projects\\glm\\glm\\detail/setup.hpp"















#line 435 "C:\\Projects\\glm\\glm\\detail/setup.hpp"


#line 438 "C:\\Projects\\glm\\glm\\detail/setup.hpp"















#line 454 "C:\\Projects\\glm\\glm\\detail/setup.hpp"




#line 459 "C:\\Projects\\glm\\glm\\detail/setup.hpp"



#line 463 "C:\\Projects\\glm\\glm\\detail/setup.hpp"

#line 465 "C:\\Projects\\glm\\glm\\detail/setup.hpp"

#line 467 "C:\\Projects\\glm\\glm\\detail/setup.hpp"










#line 478 "C:\\Projects\\glm\\glm\\detail/setup.hpp"




























#line 507 "C:\\Projects\\glm\\glm\\detail/setup.hpp"
#line 508 "C:\\Projects\\glm\\glm\\detail/setup.hpp"
















#line 525 "C:\\Projects\\glm\\glm\\detail/setup.hpp"







#line 533 "C:\\Projects\\glm\\glm\\detail/setup.hpp"







































#line 573 "C:\\Projects\\glm\\glm\\detail/setup.hpp"















#line 589 "C:\\Projects\\glm\\glm\\detail/setup.hpp"

namespace glm
{
	using std::size_t;


#line 596 "C:\\Projects\\glm\\glm\\detail/setup.hpp"
		typedef int length_t;
#line 598 "C:\\Projects\\glm\\glm\\detail/setup.hpp"
}







	namespace glm
	{
		template<typename T, std::size_t N>
		constexpr std::size_t countof(T const (&)[N])
		{
			return N;
		}
	}









#line 624 "C:\\Projects\\glm\\glm\\detail/setup.hpp"




namespace glm{
namespace detail
{
	template<typename T>
	struct is_int
	{
		enum test {value = 0};
	};

	template<>
	struct is_int<unsigned int>
	{
		enum test {value = ~0};
	};

	template<>
	struct is_int<signed int>
	{
		enum test {value = ~0};
	};
}

	typedef unsigned int	uint;
}





#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\cstdint"





#pragma once





#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\stdint.h"







#pragma once





typedef signed char        int8_t;
typedef short              int16_t;
typedef int                int32_t;
typedef long long          int64_t;
typedef unsigned char      uint8_t;
typedef unsigned short     uint16_t;
typedef unsigned int       uint32_t;
typedef unsigned long long uint64_t;

typedef signed char        int_least8_t;
typedef short              int_least16_t;
typedef int                int_least32_t;
typedef long long          int_least64_t;
typedef unsigned char      uint_least8_t;
typedef unsigned short     uint_least16_t;
typedef unsigned int       uint_least32_t;
typedef unsigned long long uint_least64_t;

typedef signed char        int_fast8_t;
typedef int                int_fast16_t;
typedef int                int_fast32_t;
typedef long long          int_fast64_t;
typedef unsigned char      uint_fast8_t;
typedef unsigned int       uint_fast16_t;
typedef unsigned int       uint_fast32_t;
typedef unsigned long long uint_fast64_t;

typedef long long          intmax_t;
typedef unsigned long long uintmax_t;










































    
    
    




#line 93 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\stdint.h"









    
#line 104 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\stdint.h"























#line 128 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\stdint.h"
#line 13 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\cstdint"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4472 4494 4514 4571 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4702 4793 4820 4988 5026 5027 5045  4984 5053 )




namespace std {
using :: int8_t;
using :: int16_t;
using :: int32_t;
using :: int64_t;
using :: uint8_t;
using :: uint16_t;
using :: uint32_t;
using :: uint64_t;

using :: int_least8_t;
using :: int_least16_t;
using :: int_least32_t;
using :: int_least64_t;
using :: uint_least8_t;
using :: uint_least16_t;
using :: uint_least32_t;
using :: uint_least64_t;

using :: int_fast8_t;
using :: int_fast16_t;
using :: int_fast32_t;
using :: int_fast64_t;
using :: uint_fast8_t;
using :: uint_fast16_t;
using :: uint_fast32_t;
using :: uint_fast64_t;

using :: intmax_t;
using :: intptr_t;
using :: uintmax_t;
using :: uintptr_t;


namespace [[deprecated( "warning STL4002: " "The non-Standard std::tr1 namespace and TR1-only machinery are deprecated and will be REMOVED. You can " "define _SILENCE_TR1_NAMESPACE_DEPRECATION_WARNING to acknowledge that you have received this warning.")]] tr1 {
    using :: int8_t;
    using :: int16_t;
    using :: int32_t;
    using :: int64_t;
    using :: uint8_t;
    using :: uint16_t;
    using :: uint32_t;
    using :: uint64_t;

    using :: int_least8_t;
    using :: int_least16_t;
    using :: int_least32_t;
    using :: int_least64_t;
    using :: uint_least8_t;
    using :: uint_least16_t;
    using :: uint_least32_t;
    using :: uint_least64_t;

    using :: int_fast8_t;
    using :: int_fast16_t;
    using :: int_fast32_t;
    using :: int_fast64_t;
    using :: uint_fast8_t;
    using :: uint_fast16_t;
    using :: uint_fast32_t;
    using :: uint_fast64_t;

    using :: intmax_t;
    using :: intptr_t;
    using :: uintmax_t;
    using :: uintptr_t;
} 
#line 89 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\cstdint"
}



#pragma warning(pop)
#pragma pack(pop)

#line 97 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\cstdint"
#line 98 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\cstdint"
#line 658 "C:\\Projects\\glm\\glm\\detail/setup.hpp"
#line 659 "C:\\Projects\\glm\\glm\\detail/setup.hpp"

namespace glm{
namespace detail
{

		typedef std::uint64_t						uint64;
		typedef std::int64_t						int64;

















#line 684 "C:\\Projects\\glm\\glm\\detail/setup.hpp"
}
}





#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\type_traits"





#pragma once




#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\xstddef"





#pragma once





#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\cstdlib"





#pragma once





#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\math.h"










#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_math.h"







#pragma once





__pragma(pack(push, 8)) extern "C" {

#pragma warning(push)
#pragma warning(disable:4738) 
#pragma warning(disable:4820) 




    
    
    struct _exception
    {
        int    type;   
        char*  name;   
        double arg1;   
        double arg2;   
        double retval; 
    };

    
    
    
        

        struct _complex
        {
            double x, y; 
        };

        


#line 48 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_math.h"
    #line 49 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_math.h"
#line 50 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_math.h"










#line 61 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_math.h"
    typedef float  float_t;
    typedef double double_t;
#line 64 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_math.h"















    
        extern double const _HUGE;
    

#line 84 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_math.h"
#line 85 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_math.h"


    
#line 89 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_math.h"


















































































void __cdecl _fperrraise(  int _Except);

   short __cdecl _dclass(  double _X);
   short __cdecl _ldclass(  long double _X);
   short __cdecl _fdclass(  float _X);

   int __cdecl _dsign(  double _X);
   int __cdecl _ldsign(  long double _X);
   int __cdecl _fdsign(  float _X);

   int __cdecl _dpcomp(  double _X,   double _Y);
   int __cdecl _ldpcomp(  long double _X,   long double _Y);
   int __cdecl _fdpcomp(  float _X,   float _Y);

   short __cdecl _dtest(  double* _Px);
   short __cdecl _ldtest(  long double* _Px);
   short __cdecl _fdtest(  float* _Px);

 short __cdecl _d_int(  double* _Px,   short _Xexp);
 short __cdecl _ld_int(  long double* _Px,   short _Xexp);
 short __cdecl _fd_int(  float* _Px,   short _Xexp);

 short __cdecl _dscale(  double* _Px,   long _Lexp);
 short __cdecl _ldscale(  long double* _Px,   long _Lexp);
 short __cdecl _fdscale(  float* _Px,   long _Lexp);

 short __cdecl _dunscale(  short* _Pex,   double* _Px);
 short __cdecl _ldunscale(  short* _Pex,   long double* _Px);
 short __cdecl _fdunscale(  short* _Pex,   float* _Px);

   short __cdecl _dexp(  double* _Px,   double _Y,   long _Eoff);
   short __cdecl _ldexp(  long double* _Px,   long double _Y,   long _Eoff);
   short __cdecl _fdexp(  float* _Px,   float _Y,   long _Eoff);

   short __cdecl _dnorm(  unsigned short* _Ps);
   short __cdecl _fdnorm(  unsigned short* _Ps);

   double __cdecl _dpoly(  double _X,   double const* _Tab,   int _N);
   long double __cdecl _ldpoly(  long double _X,   long double const* _Tab,   int _N);
   float __cdecl _fdpoly(  float _X,   float const* _Tab,   int _N);

   double __cdecl _dlog(  double _X,   int _Baseflag);
   long double __cdecl _ldlog(  long double _X,   int _Baseflag);
   float __cdecl _fdlog(  float _X,   int _Baseflag);

   double __cdecl _dsin(  double _X,   unsigned int _Qoff);
   long double __cdecl _ldsin(  long double _X,   unsigned int _Qoff);
   float __cdecl _fdsin(  float _X,   unsigned int _Qoff);


typedef union
{   
    unsigned short _Sh[4];
    double _Val;
} _double_val;


typedef union
{   
    unsigned short _Sh[2];
    float _Val;
} _float_val;


typedef union
{   
    unsigned short _Sh[4];
    long double _Val;
} _ldouble_val;

typedef union
{   
    unsigned short _Word[4];
    float _Float;
    double _Double;
    long double _Long_double;
} _float_const;

extern const _float_const _Denorm_C,  _Inf_C,  _Nan_C,  _Snan_C, _Hugeval_C;
extern const _float_const _FDenorm_C, _FInf_C, _FNan_C, _FSnan_C;
extern const _float_const _LDenorm_C, _LInf_C, _LNan_C, _LSnan_C;

extern const _float_const _Eps_C,  _Rteps_C;
extern const _float_const _FEps_C, _FRteps_C;
extern const _float_const _LEps_C, _LRteps_C;

extern const double      _Zero_C,  _Xbig_C;
extern const float       _FZero_C, _FXbig_C;
extern const long double _LZero_C, _LXbig_C;




























extern "C++"
{
      inline int fpclassify(  float _X) throw()
    {
        return _fdtest(&_X);
    }

      inline int fpclassify(  double _X) throw()
    {
        return _dtest(&_X);
    }

      inline int fpclassify(  long double _X) throw()
    {
        return _ldtest(&_X);
    }

      inline bool signbit(  float _X) throw()
    {
        return _fdsign(_X) != 0;
    }

      inline bool signbit(  double _X) throw()
    {
        return _dsign(_X) != 0;
    }

      inline bool signbit(  long double _X) throw()
    {
        return _ldsign(_X) != 0;
    }

      inline int _fpcomp(  float _X,   float _Y) throw()
    {
        return _fdpcomp(_X, _Y);
    }

      inline int _fpcomp(  double _X,   double _Y) throw()
    {
        return _dpcomp(_X, _Y);
    }

      inline int _fpcomp(  long double _X,   long double _Y) throw()
    {
        return _ldpcomp(_X, _Y);
    }

    template <class _Trc, class _Tre> struct _Combined_type
    {   
        typedef float _Type;
    };

    template <> struct _Combined_type<float, double>
    {   
        typedef double _Type;
    };

    template <> struct _Combined_type<float, long double>
    {   
        typedef long double _Type;
    };

    template <class _Ty, class _T2> struct _Real_widened
    {   
        typedef long double _Type;
    };

    template <> struct _Real_widened<float, float>
    {   
        typedef float _Type;
    };

    template <> struct _Real_widened<float, double>
    {   
        typedef double _Type;
    };

    template <> struct _Real_widened<double, float>
    {   
        typedef double _Type;
    };

    template <> struct _Real_widened<double, double>
    {   
        typedef double _Type;
    };

    template <class _Ty> struct _Real_type
    {   
        typedef double _Type;   
    };

    template <> struct _Real_type<float>
    {   
        typedef float _Type;
    };

    template <> struct _Real_type<long double>
    {   
        typedef long double _Type;
    };

    template <class _T1, class _T2>
      inline int _fpcomp(  _T1 _X,   _T2 _Y) throw()
    {   
        typedef typename _Combined_type<float,
            typename _Real_widened<
            typename _Real_type<_T1>::_Type,
            typename _Real_type<_T2>::_Type>::_Type>::_Type _Tw;
        return _fpcomp((_Tw)_X, (_Tw)_Y);
    }

    template <class _Ty>
      inline bool isfinite(  _Ty _X) throw()
    {
        return fpclassify(_X) <= 0;
    }

    template <class _Ty>
      inline bool isinf(  _Ty _X) throw()
    {
        return fpclassify(_X) == 1;
    }

    template <class _Ty>
      inline bool isnan(  _Ty _X) throw()
    {
        return fpclassify(_X) == 2;
    }

    template <class _Ty>
      inline bool isnormal(  _Ty _X) throw()
    {
        return fpclassify(_X) == (-1);
    }

    template <class _Ty1, class _Ty2>
      inline bool isgreater(  _Ty1 _X,   _Ty2 _Y) throw()
    {
        return (_fpcomp(_X, _Y) & 4) != 0;
    }

    template <class _Ty1, class _Ty2>
      inline bool isgreaterequal(  _Ty1 _X,   _Ty2 _Y) throw()
    {
        return (_fpcomp(_X, _Y) & (2 | 4)) != 0;
    }

    template <class _Ty1, class _Ty2>
      inline bool isless(  _Ty1 _X,   _Ty2 _Y) throw()
    {
        return (_fpcomp(_X, _Y) & 1) != 0;
    }

    template <class _Ty1, class _Ty2>
      inline bool islessequal(  _Ty1 _X,   _Ty2 _Y) throw()
    {
        return (_fpcomp(_X, _Y) & (1 | 2)) != 0;
    }

    template <class _Ty1, class _Ty2>
      inline bool islessgreater(  _Ty1 _X,   _Ty2 _Y) throw()
    {
        return (_fpcomp(_X, _Y) & (1 | 4)) != 0;
    }

    template <class _Ty1, class _Ty2>
      inline bool isunordered(  _Ty1 _X,   _Ty2 _Y) throw()
    {
        return _fpcomp(_X, _Y) == 0;
    }
}  
#line 461 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_math.h"





      int       __cdecl abs(  int _X);
      long      __cdecl labs(  long _X);
      long long __cdecl llabs(  long long _X);

      double __cdecl acos(  double _X);
      double __cdecl asin(  double _X);
      double __cdecl atan(  double _X);
      double __cdecl atan2(  double _Y,   double _X);

      double __cdecl cos(  double _X);
      double __cdecl cosh(  double _X);
      double __cdecl exp(  double _X);
       double __cdecl fabs(  double _X);
      double __cdecl fmod(  double _X,   double _Y);
      double __cdecl log(  double _X);
      double __cdecl log10(  double _X);
      double __cdecl pow(  double _X,   double _Y);
      double __cdecl sin(  double _X);
      double __cdecl sinh(  double _X);
       double __cdecl sqrt(  double _X);
      double __cdecl tan(  double _X);
      double __cdecl tanh(  double _X);

       double    __cdecl acosh(  double _X);
       double    __cdecl asinh(  double _X);
       double    __cdecl atanh(  double _X);
        double    __cdecl atof(  char const* _String);
        double    __cdecl _atof_l(  char const* _String,   _locale_t _Locale);
       double    __cdecl _cabs(  struct _complex _Complex_value);
       double    __cdecl cbrt(  double _X);
       double    __cdecl ceil(  double _X);
       double    __cdecl _chgsign(  double _X);
       double    __cdecl copysign(  double _Number,   double _Sign);
       double    __cdecl _copysign(  double _Number,   double _Sign);
       double    __cdecl erf(  double _X);
       double    __cdecl erfc(  double _X);
       double    __cdecl exp2(  double _X);
       double    __cdecl expm1(  double _X);
       double    __cdecl fdim(  double _X,   double _Y);
       double    __cdecl floor(  double _X);
       double    __cdecl fma(  double _X,   double _Y,   double _Z);
       double    __cdecl fmax(  double _X,   double _Y);
       double    __cdecl fmin(  double _X,   double _Y);
       double    __cdecl frexp(  double _X,   int* _Y);
       double    __cdecl hypot(  double _X,   double _Y);
       double    __cdecl _hypot(  double _X,   double _Y);
       int       __cdecl ilogb(  double _X);
       double    __cdecl ldexp(  double _X,   int _Y);
       double    __cdecl lgamma(  double _X);
       long long __cdecl llrint(  double _X);
       long long __cdecl llround(  double _X);
       double    __cdecl log1p(  double _X);
       double    __cdecl log2(  double _X);
       double    __cdecl logb(  double _X);
       long      __cdecl lrint(  double _X);
       long      __cdecl lround(  double _X);

    int __cdecl _matherr(  struct _exception* _Except);

       double __cdecl modf(  double _X,   double* _Y);
       double __cdecl nan(  char const* _X);
       double __cdecl nearbyint(  double _X);
       double __cdecl nextafter(  double _X,   double _Y);
       double __cdecl nexttoward(  double _X,   long double _Y);
       double __cdecl remainder(  double _X,   double _Y);
       double __cdecl remquo(  double _X,   double _Y,   int* _Z);
       double __cdecl rint(  double _X);
       double __cdecl round(  double _X);
       double __cdecl scalbln(  double _X,   long _Y);
       double __cdecl scalbn(  double _X,   int _Y);
       double __cdecl tgamma(  double _X);
       double __cdecl trunc(  double _X);
       double __cdecl _j0(  double _X );
       double __cdecl _j1(  double _X );
       double __cdecl _jn(int _X,   double _Y);
       double __cdecl _y0(  double _X);
       double __cdecl _y1(  double _X);
       double __cdecl _yn(  int _X,   double _Y);

       float     __cdecl acoshf(  float _X);
       float     __cdecl asinhf(  float _X);
       float     __cdecl atanhf(  float _X);
       float     __cdecl cbrtf(  float _X);
       float     __cdecl _chgsignf(  float _X);
       float     __cdecl copysignf(  float _Number,   float _Sign);
       float     __cdecl _copysignf(  float _Number,   float _Sign);
       float     __cdecl erff(  float _X);
       float     __cdecl erfcf(  float _X);
       float     __cdecl expm1f(  float _X);
       float     __cdecl exp2f(  float _X);
       float     __cdecl fdimf(  float _X,   float _Y);
       float     __cdecl fmaf(  float _X,   float _Y,   float _Z);
       float     __cdecl fmaxf(  float _X,   float _Y);
       float     __cdecl fminf(  float _X,   float _Y);
       float     __cdecl _hypotf(  float _X,   float _Y);
       int       __cdecl ilogbf(  float _X);
       float     __cdecl lgammaf(  float _X);
       long long __cdecl llrintf(  float _X);
       long long __cdecl llroundf(  float _X);
       float     __cdecl log1pf(  float _X);
       float     __cdecl log2f(  float _X);
       float     __cdecl logbf(  float _X);
       long      __cdecl lrintf(  float _X);
       long      __cdecl lroundf(  float _X);
       float     __cdecl nanf(  char const* _X);
       float     __cdecl nearbyintf(  float _X);
       float     __cdecl nextafterf(  float _X,   float _Y);
       float     __cdecl nexttowardf(  float _X,   long double _Y);
       float     __cdecl remainderf(  float _X,   float _Y);
       float     __cdecl remquof(  float _X,   float _Y,   int* _Z);
       float     __cdecl rintf(  float _X);
       float     __cdecl roundf(  float _X);
       float     __cdecl scalblnf(  float _X,   long _Y);
       float     __cdecl scalbnf(  float _X,   int _Y);
       float     __cdecl tgammaf(  float _X);
       float     __cdecl truncf(  float _X);

    



#line 588 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_math.h"

    

           float __cdecl _logbf(  float _X);
           float __cdecl _nextafterf(  float _X,   float _Y);
           int   __cdecl _finitef(  float _X);
           int   __cdecl _isnanf(  float _X);
           int   __cdecl _fpclassf(  float _X);

           int   __cdecl _set_FMA3_enable(  int _Flag);
           int   __cdecl _get_FMA3_enable(void);

    




#line 606 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_math.h"



    

           float __cdecl acosf(  float _X);
           float __cdecl asinf(  float _X);
           float __cdecl atan2f(  float _Y,   float _X);
           float __cdecl atanf(  float _X);
           float __cdecl ceilf(  float _X);
           float __cdecl cosf(  float _X);
           float __cdecl coshf(  float _X);
           float __cdecl expf(  float _X);

    









































#line 663 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_math.h"

    



#line 669 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_math.h"

          __inline float __cdecl fabsf(  float _X)
        {
            return (float)fabs(_X);
        }

    #line 676 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_math.h"

    

           float __cdecl floorf(  float _X);
           float __cdecl fmodf(  float _X,   float _Y);

    











#line 695 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_math.h"

      __inline float __cdecl frexpf(  float _X,   int *_Y)
    {
        return (float)frexp(_X, _Y);
    }

      __inline float __cdecl hypotf(  float _X,   float _Y)
    {
        return _hypotf(_X, _Y);
    }

      __inline float __cdecl ldexpf(  float _X,   int _Y)
    {
        return (float)ldexp(_X, _Y);
    }

    

           float  __cdecl log10f(  float _X);
           float  __cdecl logf(  float _X);
           float  __cdecl modff(  float _X,   float *_Y);
           float  __cdecl powf(  float _X,   float _Y);
           float  __cdecl sinf(  float _X);
           float  __cdecl sinhf(  float _X);
           float  __cdecl sqrtf(  float _X);
           float  __cdecl tanf(  float _X);
           float  __cdecl tanhf(  float _X);

    

















































#line 774 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_math.h"

       long double __cdecl acoshl(  long double _X);

      __inline long double __cdecl acosl(  long double _X)
    {
        return acos((double)_X);
    }

       long double __cdecl asinhl(  long double _X);

      __inline long double __cdecl asinl(  long double _X)
    {
        return asin((double)_X);
    }

      __inline long double __cdecl atan2l(  long double _Y,   long double _X)
    {
        return atan2((double)_Y, (double)_X);
    }

       long double __cdecl atanhl(  long double _X);

      __inline long double __cdecl atanl(  long double _X)
    {
        return atan((double)_X);
    }

       long double __cdecl cbrtl(  long double _X);

      __inline long double __cdecl ceill(  long double _X)
    {
        return ceil((double)_X);
    }

      __inline long double __cdecl _chgsignl(  long double _X)
    {
        return _chgsign((double)_X);
    }

       long double __cdecl copysignl(  long double _Number,   long double _Sign);

      __inline long double __cdecl _copysignl(  long double _Number,   long double _Sign)
    {
        return _copysign((double)_Number, (double)_Sign);
    }

      __inline long double __cdecl coshl(  long double _X)
    {
        return cosh((double)_X);
    }

      __inline long double __cdecl cosl(  long double _X)
    {
        return cos((double)_X);
    }

       long double __cdecl erfl(  long double _X);
       long double __cdecl erfcl(  long double _X);

      __inline long double __cdecl expl(  long double _X)
    {
        return exp((double)_X);
    }

       long double __cdecl exp2l(  long double _X);
       long double __cdecl expm1l(  long double _X);

      __inline long double __cdecl fabsl(  long double _X)
    {
        return fabs((double)_X);
    }

       long double __cdecl fdiml(  long double _X,   long double _Y);

      __inline long double __cdecl floorl(  long double _X)
    {
        return floor((double)_X);
    }

       long double __cdecl fmal(  long double _X,   long double _Y,   long double _Z);
       long double __cdecl fmaxl(  long double _X,   long double _Y);
       long double __cdecl fminl(  long double _X,   long double _Y);

      __inline long double __cdecl fmodl(  long double _X,   long double _Y)
    {
        return fmod((double)_X, (double)_Y);
    }

      __inline long double __cdecl frexpl(  long double _X,   int *_Y)
    {
        return frexp((double)_X, _Y);
    }

       int __cdecl ilogbl(  long double _X);

      __inline long double __cdecl _hypotl(  long double _X,   long double _Y)
    {
        return _hypot((double)_X, (double)_Y);
    }

      __inline long double __cdecl hypotl(  long double _X,   long double _Y)
    {
        return _hypot((double)_X, (double)_Y);
    }

      __inline long double __cdecl ldexpl(  long double _X,   int _Y)
    {
        return ldexp((double)_X, _Y);
    }

       long double __cdecl lgammal(  long double _X);
       long long __cdecl llrintl(  long double _X);
       long long __cdecl llroundl(  long double _X);

      __inline long double __cdecl logl(  long double _X)
    {
        return log((double)_X);
    }

      __inline long double __cdecl log10l(  long double _X)
    {
        return log10((double)_X);
    }

       long double __cdecl log1pl(  long double _X);
       long double __cdecl log2l(  long double _X);
       long double __cdecl logbl(  long double _X);
       long __cdecl lrintl(  long double _X);
       long __cdecl lroundl(  long double _X);

      __inline long double __cdecl modfl(  long double _X,   long double* _Y)
    {
        double _F, _I;
        _F = modf((double)_X, &_I);
        *_Y = _I;
        return _F;
    }

       long double __cdecl nanl(  char const* _X);
       long double __cdecl nearbyintl(  long double _X);
       long double __cdecl nextafterl(  long double _X,   long double _Y);
       long double __cdecl nexttowardl(  long double _X,   long double _Y);

      __inline long double __cdecl powl(  long double _X,   long double _Y)
    {
        return pow((double)_X, (double)_Y);
    }

       long double __cdecl remainderl(  long double _X,   long double _Y);
       long double __cdecl remquol(  long double _X,   long double _Y,   int* _Z);
       long double __cdecl rintl(  long double _X);
       long double __cdecl roundl(  long double _X);
       long double __cdecl scalblnl(  long double _X,   long _Y);
       long double __cdecl scalbnl(  long double _X,   int _Y);

      __inline long double __cdecl sinhl(  long double _X)
    {
        return sinh((double)_X);
    }

      __inline long double __cdecl sinl(  long double _X)
    {
        return sin((double)_X);
    }

      __inline long double __cdecl sqrtl(  long double _X)
    {
        return sqrt((double)_X);
    }

      __inline long double __cdecl tanhl(  long double _X)
    {
        return tanh((double)_X);
    }

      __inline long double __cdecl tanl(  long double _X)
    {
        return tan((double)_X);
    }

       long double __cdecl tgammal(  long double _X);
       long double __cdecl truncl(  long double _X);

    



#line 962 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_math.h"



    
    
    
    
    
    

    

    
        
            extern double HUGE;
        

#line 980 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_math.h"

        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_j0" ". See online help for details."))    double __cdecl j0(  double _X);
        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_j1" ". See online help for details."))    double __cdecl j1(  double _X);
        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_jn" ". See online help for details."))    double __cdecl jn(  int _X,   double _Y);
        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_y0" ". See online help for details."))    double __cdecl y0(  double _X);
        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_y1" ". See online help for details."))    double __cdecl y1(  double _X);
        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_yn" ". See online help for details."))    double __cdecl yn(  int _X,   double _Y);
    #line 988 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_math.h"

#line 990 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_math.h"


#pragma warning(pop)

} __pragma(pack(pop))
#line 996 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_math.h"
#line 12 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\math.h"




#line 13 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\cstdlib"
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdlib.h"







#pragma once




#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_malloc.h"








#pragma once



__pragma(pack(push, 8)) extern "C" {





































#line 52 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_malloc.h"

     
 __declspec(allocator) __declspec(restrict)
void* __cdecl _calloc_base(
      size_t _Count,
      size_t _Size
    );

     
  __declspec(allocator) __declspec(restrict) 
void* __cdecl calloc(
       size_t _Count,
       size_t _Size
    );

 
 int __cdecl _callnewh(
      size_t _Size
    );

     
 __declspec(allocator) 
void* __cdecl _expand(
                void*  _Block,
       size_t _Size
    );


void __cdecl _free_base(
        void* _Block
    );

 
void __cdecl free(
        void* _Block
    );

     
 __declspec(allocator) __declspec(restrict)
void* __cdecl _malloc_base(
      size_t _Size
    );

     
 __declspec(allocator)  __declspec(restrict) 
void* __cdecl malloc(
       size_t _Size
    );

 

size_t __cdecl _msize_base(
      void* _Block
    );

 
 
size_t __cdecl _msize(
      void* _Block
    );

       
 __declspec(allocator) __declspec(restrict)
void* __cdecl _realloc_base(
         void*  _Block,
                                 size_t _Size
    );

       
 __declspec(allocator) __declspec(restrict) 
void* __cdecl realloc(
        void*  _Block,
              size_t _Size
    );

       
 __declspec(allocator) __declspec(restrict)
void* __cdecl _recalloc_base(
        void*  _Block,
                                size_t _Count,
                                size_t _Size
    );

       
 __declspec(allocator) __declspec(restrict)
void* __cdecl _recalloc(
        void*  _Block,
              size_t _Count,
              size_t _Size
    );


void __cdecl _aligned_free(
        void* _Block
    );

     
 __declspec(allocator) __declspec(restrict)
void* __cdecl _aligned_malloc(
       size_t _Size,
                         size_t _Alignment
    );

     
 __declspec(allocator) __declspec(restrict)
void* __cdecl _aligned_offset_malloc(
       size_t _Size,
                         size_t _Alignment,
                         size_t _Offset
    );

 

size_t __cdecl _aligned_msize(
      void*  _Block,
               size_t _Alignment,
               size_t _Offset
    );

       
 __declspec(allocator) __declspec(restrict)
void* __cdecl _aligned_offset_realloc(
        void*  _Block,
              size_t _Size,
                                size_t _Alignment,
                                size_t _Offset
    );

       
 __declspec(allocator) __declspec(restrict)
void* __cdecl _aligned_offset_recalloc(
        void*  _Block,
              size_t _Count,
              size_t _Size,
                                size_t _Alignment,
                                size_t _Offset
    );

       
 __declspec(allocator) __declspec(restrict)
void* __cdecl _aligned_realloc(
        void*  _Block,
              size_t _Size,
                                size_t _Alignment
    );

       
 __declspec(allocator) __declspec(restrict)
void* __cdecl _aligned_recalloc(
        void*  _Block,
              size_t _Count,
              size_t _Size,
                                size_t _Alignment
    );


















#line 225 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_malloc.h"



} __pragma(pack(pop))
#line 14 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdlib.h"
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_search.h"










#pragma once




__pragma(pack(push, 8)) extern "C" {


    typedef int (__cdecl* _CoreCrtSecureSearchSortCompareFunction)(void*, void const*, void const*);
    typedef int (__cdecl* _CoreCrtNonSecureSearchSortCompareFunction)(void const*, void const*);




     
     void* __cdecl bsearch_s(
                                                        void const* _Key,
          void const* _Base,
                                                        rsize_t     _NumOfElements,
                                                        rsize_t     _SizeOfElements,
                            _CoreCrtSecureSearchSortCompareFunction _CompareFunction,
                                                    void*       _Context
        );

     void __cdecl qsort_s(
          void*   _Base,
                                                             rsize_t _NumOfElements,
                                                             rsize_t _SizeOfElements,
                             _CoreCrtSecureSearchSortCompareFunction _CompareFunction,
                                                         void*   _Context
        );

#line 44 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_search.h"



 
 void* __cdecl bsearch(
                                                    void const* _Key,
      void const* _Base,
                                                    size_t      _NumOfElements,
                                                    size_t      _SizeOfElements,
                     _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction
    );

 void __cdecl qsort(
      void*  _Base,
                                                         size_t _NumOfElements,
                                                         size_t _SizeOfElements,
                     _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction
    );

 
 void* __cdecl _lfind_s(
                                                       void const*   _Key,
      void const*   _Base,
                                                    unsigned int* _NumOfElements,
                                                       size_t        _SizeOfElements,
                             _CoreCrtSecureSearchSortCompareFunction _CompareFunction,
                                                       void*         _Context
    );

 
 void* __cdecl _lfind(
                                                       void const*   _Key,
      void const*   _Base,
                                                    unsigned int* _NumOfElements,
                                                       unsigned int  _SizeOfElements,
                          _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction
    );

 
 void* __cdecl _lsearch_s(
                                                             void const*   _Key,
      void*         _Base,
                                                          unsigned int* _NumOfElements,
                                                             size_t        _SizeOfElements,
                                   _CoreCrtSecureSearchSortCompareFunction _CompareFunction,
                                                             void*         _Context
    );

 
 void* __cdecl _lsearch(
                                                             void const*   _Key,
      void*         _Base,
                                                          unsigned int* _NumOfElements,
                                                             unsigned int  _SizeOfElements,
                                _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction
    );




















































































#line 185 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_search.h"





      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_lfind" ". See online help for details."))
     void* __cdecl lfind(
                                                           void const*   _Key,
          void const*   _Base,
                                                        unsigned int* _NumOfElements,
                                                           unsigned int  _SizeOfElements,
                              _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction
        );

      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_lsearch" ". See online help for details."))
     void* __cdecl lsearch(
                                                                void const*   _Key,
          void*         _Base,
                                                             unsigned int* _NumOfElements,
                                                                unsigned int  _SizeOfElements,
                                   _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction
        );

#line 209 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_search.h"



} __pragma(pack(pop))
#line 15 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdlib.h"
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdlib.h"








#pragma once



__pragma(pack(push, 8)) extern "C" {


































     
    
     errno_t __cdecl _itow_s(
                                  int      _Value,
          wchar_t* _Buffer,
                                  size_t   _BufferCount,
                                  int      _Radix
        );

    extern "C++" { template <size_t _Size> inline errno_t __cdecl _itow_s(  int _Value, wchar_t (&_Buffer)[_Size],   int _Radix) throw() { return _itow_s(_Value, _Buffer, _Size, _Radix); } }
#line 64 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdlib.h"

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_itow_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  wchar_t* __cdecl _itow( int _Value,   wchar_t *_Buffer,  int _Radix);
#line 71 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdlib.h"

     
    
     errno_t __cdecl _ltow_s(
                                  long     _Value,
          wchar_t* _Buffer,
                                  size_t   _BufferCount,
                                  int      _Radix
        );

    extern "C++" { template <size_t _Size> inline errno_t __cdecl _ltow_s(  long _Value, wchar_t (&_Buffer)[_Size],   int _Radix) throw() { return _ltow_s(_Value, _Buffer, _Size, _Radix); } }
#line 87 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdlib.h"

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ltow_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  wchar_t* __cdecl _ltow( long _Value,   wchar_t *_Buffer,  int _Radix);
#line 94 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdlib.h"

    
     errno_t __cdecl _ultow_s(
                                  unsigned long _Value,
          wchar_t*      _Buffer,
                                  size_t        _BufferCount,
                                  int           _Radix
        );

    extern "C++" { template <size_t _Size> inline errno_t __cdecl _ultow_s(  unsigned long _Value, wchar_t (&_Buffer)[_Size],   int _Radix) throw() { return _ultow_s(_Value, _Buffer, _Size, _Radix); } }
#line 109 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdlib.h"

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ultow_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  wchar_t* __cdecl _ultow( unsigned long _Value,   wchar_t *_Buffer,  int _Radix);
#line 116 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdlib.h"

     
     double __cdecl wcstod(
                            wchar_t const* _String,
            wchar_t**      _EndPtr
        );

     
     double __cdecl _wcstod_l(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                          _locale_t      _Locale
        );

     
     long __cdecl wcstol(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix
        );

     
     long __cdecl _wcstol_l(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix,
                          _locale_t      _Locale
        );

     
     long long __cdecl wcstoll(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix
        );

     
     long long __cdecl _wcstoll_l(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix,
                          _locale_t      _Locale
        );

     
     unsigned long __cdecl wcstoul(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix
        );

     
     unsigned long __cdecl _wcstoul_l(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix,
                          _locale_t      _Locale
        );

     
     unsigned long long __cdecl wcstoull(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix
        );

     
     unsigned long long __cdecl _wcstoull_l(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix,
                          _locale_t      _Locale
        );

     
     long double __cdecl wcstold(
                            wchar_t const* _String,
            wchar_t**      _EndPtr
        );

     
     long double __cdecl _wcstold_l(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                          _locale_t      _Locale
        );

     
     float __cdecl wcstof(
                            wchar_t const* _String,
            wchar_t**      _EndPtr
        );

     
     float __cdecl _wcstof_l(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                          _locale_t      _Locale
        );

     
     double __cdecl _wtof(
          wchar_t const* _String
        );

     
     double __cdecl _wtof_l(
            wchar_t const* _String,
          _locale_t      _Locale
        );

     
     int __cdecl _wtoi(
          wchar_t const* _String
        );

     
     int __cdecl _wtoi_l(
            wchar_t const* _String,
          _locale_t      _Locale
        );

     
     long __cdecl _wtol(
          wchar_t const* _String
        );

     
     long __cdecl _wtol_l(
            wchar_t const* _String,
          _locale_t      _Locale
        );

     
     long long __cdecl _wtoll(
          wchar_t const* _String
        );

     
     long long __cdecl _wtoll_l(
            wchar_t const* _String,
          _locale_t      _Locale
        );

    
     errno_t __cdecl _i64tow_s(
                                  __int64  _Value,
          wchar_t* _Buffer,
                                  size_t   _BufferCount,
                                  int      _Radix
        );

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_i64tow_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
     wchar_t* __cdecl _i64tow(
                            __int64  _Value,
            wchar_t* _Buffer,
                            int      _Radix
        );

    
     errno_t __cdecl _ui64tow_s(
                                  unsigned __int64 _Value,
          wchar_t*         _Buffer,
                                  size_t           _BufferCount,
                                  int              _Radix
        );

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ui64tow_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
     wchar_t* __cdecl _ui64tow(
                            unsigned __int64 _Value,
            wchar_t*         _Buffer,
                            int              _Radix
        );

     
     __int64 __cdecl _wtoi64(
          wchar_t const* _String
        );

     
     __int64 __cdecl _wtoi64_l(
            wchar_t const* _String,
          _locale_t      _Locale
        );

     
     __int64 __cdecl _wcstoi64(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix
        );

     
     __int64 __cdecl _wcstoi64_l(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix,
                          _locale_t      _Locale
        );

     
     unsigned __int64 __cdecl _wcstoui64(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix
        );

     
     unsigned __int64 __cdecl _wcstoui64_l(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix,
                          _locale_t      _Locale
        );

    
    

     
     
     __declspec(allocator) wchar_t* __cdecl _wfullpath(
          wchar_t*       _Buffer,
                                    wchar_t const* _Path,
                                      size_t         _BufferCount
        );

    

    
     errno_t __cdecl _wmakepath_s(
          wchar_t*       _Buffer,
                                  size_t         _BufferCount,
                            wchar_t const* _Drive,
                            wchar_t const* _Dir,
                            wchar_t const* _Filename,
                            wchar_t const* _Ext
        );

    extern "C++" { template <size_t _Size> inline errno_t __cdecl _wmakepath_s(wchar_t (&_Buffer)[_Size],   wchar_t const* _Drive,   wchar_t const* _Dir,   wchar_t const* _Filename,   wchar_t const* _Ext) throw() { return _wmakepath_s(_Buffer, _Size, _Drive, _Dir, _Filename, _Ext); } }
#line 362 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdlib.h"

#pragma warning(push)
#pragma warning(disable: 28719) 
#pragma warning(disable: 28726) 
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wmakepath_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  void __cdecl _wmakepath(  wchar_t *_Buffer,  wchar_t const* _Drive,  wchar_t const* _Dir,  wchar_t const* _Filename,  wchar_t const* _Ext);
#line 374 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdlib.h"
#pragma warning(pop)

     void __cdecl _wperror(
          wchar_t const* _ErrorMessage
        );

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wsplitpath_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
     void __cdecl _wsplitpath(
                            wchar_t const* _FullPath,
            wchar_t*       _Drive,
            wchar_t*       _Dir,
            wchar_t*       _Filename,
            wchar_t*       _Ext
        );

     errno_t __cdecl _wsplitpath_s(
                                      wchar_t const* _FullPath,
             wchar_t*       _Drive,
                                        size_t         _DriveCount,
               wchar_t*       _Dir,
                                        size_t         _DirCount,
          wchar_t*       _Filename,
                                        size_t         _FilenameCount,
               wchar_t*       _Ext,
                                        size_t         _ExtCount
        );

    extern "C++" { template <size_t _DriveSize, size_t _DirSize, size_t _NameSize, size_t _ExtSize> inline errno_t __cdecl _wsplitpath_s(   wchar_t const* _Path,   wchar_t (&_Drive)[_DriveSize],   wchar_t (&_Dir)[_DirSize],   wchar_t (&_Name)[_NameSize],   wchar_t (&_Ext)[_ExtSize] ) throw() { return _wsplitpath_s(_Path, _Drive, _DriveSize, _Dir, _DirSize, _Name, _NameSize, _Ext, _ExtSize); } }
#line 405 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdlib.h"

        
        

        
         errno_t __cdecl _wdupenv_s(
                wchar_t**      _Buffer,
                                                                                size_t*        _BufferCount,
                                                                                   wchar_t const* _VarName
            );

        

          __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wdupenv_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
         wchar_t* __cdecl _wgetenv(
              wchar_t const* _VarName
            );

         
        
         errno_t __cdecl _wgetenv_s(
                                         size_t*        _RequiredCount,
              wchar_t*       _Buffer,
                                          size_t         _BufferCount,
                                        wchar_t const* _VarName
            );

        extern "C++" { template <size_t _Size> inline   errno_t __cdecl _wgetenv_s(  size_t* _RequiredCount, wchar_t (&_Buffer)[_Size],   wchar_t const* _VarName) throw() { return _wgetenv_s(_RequiredCount, _Buffer, _Size, _VarName); } }
#line 439 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdlib.h"

         
         int __cdecl _wputenv(
              wchar_t const* _EnvString
            );

        
         errno_t __cdecl _wputenv_s(
              wchar_t const* _Name,
              wchar_t const* _Value
            );

         errno_t __cdecl _wsearchenv_s(
                                    wchar_t const* _Filename,
                                    wchar_t const* _VarName,
              wchar_t*       _Buffer,
                                      size_t         _BufferCount
            );

        extern "C++" { template <size_t _Size> inline errno_t __cdecl _wsearchenv_s(  wchar_t const* _Filename,   wchar_t const* _VarName, wchar_t (&_ResultPath)[_Size]) throw() { return _wsearchenv_s(_Filename, _VarName, _ResultPath, _Size); } }
#line 464 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdlib.h"

        __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wsearchenv_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  void __cdecl _wsearchenv( wchar_t const* _Filename,  wchar_t const* _VarName,   wchar_t *_ResultPath);
#line 471 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdlib.h"

         int __cdecl _wsystem(
              wchar_t const* _Command
            );

#line 476 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdlib.h"



} __pragma(pack(pop))
#line 16 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdlib.h"
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\limits.h"







#pragma once




__pragma(pack(push, 8)) extern "C" {







    
    



#line 27 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\limits.h"








































    
        
    #line 70 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\limits.h"
#line 71 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\limits.h"

} __pragma(pack(pop))
#line 17 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdlib.h"

__pragma(pack(push, 8)) extern "C" {




    
#line 25 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdlib.h"









 void __cdecl _swab(
        char* _Buf1,
        char* _Buf2,
                                                                  int   _SizeInBytes
    );













     __declspec(noreturn) void __cdecl exit(  int _Code);
     __declspec(noreturn) void __cdecl _exit(  int _Code);
     __declspec(noreturn) void __cdecl _Exit(  int _Code);
     __declspec(noreturn) void __cdecl quick_exit(  int _Code);
     __declspec(noreturn) void __cdecl abort(void);
#line 58 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdlib.h"





 unsigned int __cdecl _set_abort_behavior(
      unsigned int _Flags,
      unsigned int _Mask
    );




    

    typedef int (__cdecl* _onexit_t)(void);
    


#line 78 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdlib.h"


    
    
#line 83 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdlib.h"

























































    int       __cdecl atexit(void (__cdecl*)(void));
    _onexit_t __cdecl _onexit(  _onexit_t _Func);
#line 143 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdlib.h"

int __cdecl at_quick_exit(void (__cdecl*)(void));









    
    typedef void (__cdecl* _purecall_handler)(void);

    
    typedef void (__cdecl* _invalid_parameter_handler)(
        wchar_t const*,
        wchar_t const*,
        wchar_t const*,
        unsigned int,
        uintptr_t
        );

    
     _purecall_handler __cdecl _set_purecall_handler(
          _purecall_handler _Handler
        );

     _purecall_handler __cdecl _get_purecall_handler(void);

    
     _invalid_parameter_handler __cdecl _set_invalid_parameter_handler(
          _invalid_parameter_handler _Handler
        );

     _invalid_parameter_handler __cdecl _get_invalid_parameter_handler(void);

     _invalid_parameter_handler __cdecl _set_thread_local_invalid_parameter_handler(
          _invalid_parameter_handler _Handler
        );

     _invalid_parameter_handler __cdecl _get_thread_local_invalid_parameter_handler(void);
#line 186 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdlib.h"












#line 199 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdlib.h"









  int __cdecl _set_error_mode(  int _Mode);




     int* __cdecl _errno(void);
    

     errno_t __cdecl _set_errno(  int _Value);
     errno_t __cdecl _get_errno(  int* _Value);

     unsigned long* __cdecl __doserrno(void);
    

     errno_t __cdecl _set_doserrno(  unsigned long _Value);
     errno_t __cdecl _get_doserrno(  unsigned long * _Value);

    
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "strerror" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) char** __cdecl __sys_errlist(void);
    

     __declspec(deprecated("This function or variable may be unsafe. Consider using " "strerror" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) int * __cdecl __sys_nerr(void);
    

     void __cdecl perror(  char const* _ErrMsg);
#line 234 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdlib.h"




__declspec(deprecated("This function or variable may be unsafe. Consider using " "_get_pgmptr" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  char**    __cdecl __p__pgmptr (void);
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_get_wpgmptr" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  wchar_t** __cdecl __p__wpgmptr(void);
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_get_fmode" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  int*      __cdecl __p__fmode  (void);








    
    
    
#line 253 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdlib.h"

 
 errno_t __cdecl _get_pgmptr (  char**    _Value);

 
 errno_t __cdecl _get_wpgmptr(  wchar_t** _Value);

 errno_t __cdecl _set_fmode  (               int       _Mode );

 errno_t __cdecl _get_fmode  (              int*      _PMode);








typedef struct _div_t
{
    int quot;
    int rem;
} div_t;

typedef struct _ldiv_t
{
    long quot;
    long rem;
} ldiv_t;

typedef struct _lldiv_t
{
    long long quot;
    long long rem;
} lldiv_t;

  int       __cdecl abs   (  int       _Number);
  long      __cdecl labs  (  long      _Number);
  long long __cdecl llabs (  long long _Number);
  __int64   __cdecl _abs64(  __int64   _Number);

  unsigned short   __cdecl _byteswap_ushort(  unsigned short   _Number);
  unsigned long    __cdecl _byteswap_ulong (  unsigned long    _Number);
  unsigned __int64 __cdecl _byteswap_uint64(  unsigned __int64 _Number);

   div_t   __cdecl div  (  int       _Numerator,   int       _Denominator);
   ldiv_t  __cdecl ldiv (  long      _Numerator,   long      _Denominator);
   lldiv_t __cdecl lldiv(  long long _Numerator,   long long _Denominator);



#pragma warning (push)
#pragma warning (disable:6540)

unsigned int __cdecl _rotl(
      unsigned int _Value,
      int          _Shift
    );

 
unsigned long __cdecl _lrotl(
      unsigned long _Value,
      int           _Shift
    );

unsigned __int64 __cdecl _rotl64(
      unsigned __int64 _Value,
      int              _Shift
    );

unsigned int __cdecl _rotr(
      unsigned int _Value,
      int          _Shift
    );

 
unsigned long __cdecl _lrotr(
      unsigned long _Value,
      int           _Shift
    );

unsigned __int64 __cdecl _rotr64(
      unsigned __int64 _Value,
      int              _Shift
    );

#pragma warning (pop)






 void __cdecl srand(  unsigned int _Seed);

   int __cdecl rand(void);



#line 353 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdlib.h"




extern "C++"
{
    inline long abs(long const _X) throw()
    {
        return labs(_X);
    }

    inline long long abs(long long const _X) throw()
    {
        return llabs(_X);
    }

    inline ldiv_t div(long const _A1, long const _A2) throw()
    {
        return ldiv(_A1, _A2);
    }

    inline lldiv_t div(long long const _A1, long long const _A2) throw()
    {
        return lldiv(_A1, _A2);
    }
}
#line 380 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdlib.h"










    #pragma pack(push, 4)
    typedef struct
    {
        unsigned char ld[10];
    } _LDOUBLE;
    #pragma pack(pop)

    











#line 410 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdlib.h"

typedef struct
{
    double x;
} _CRT_DOUBLE;

typedef struct
{
    float f;
} _CRT_FLOAT;





typedef struct
{
    long double x;
} _LONGDOUBLE;



#pragma pack(push, 4)
typedef struct
{
    unsigned char ld12[12];
} _LDBL12;
#pragma pack(pop)








                      double    __cdecl atof   (  char const* _String);
    int       __cdecl atoi   (  char const* _String);
                      long      __cdecl atol   (  char const* _String);
                      long long __cdecl atoll  (  char const* _String);
                      __int64   __cdecl _atoi64(  char const* _String);

   double    __cdecl _atof_l  (  char const* _String,   _locale_t _Locale);
   int       __cdecl _atoi_l  (  char const* _String,   _locale_t _Locale);
   long      __cdecl _atol_l  (  char const* _String,   _locale_t _Locale);
   long long __cdecl _atoll_l (  char const* _String,   _locale_t _Locale);
   __int64   __cdecl _atoi64_l(  char const* _String,   _locale_t _Locale);

   int __cdecl _atoflt (  _CRT_FLOAT*  _Result,   char const* _String);
   int __cdecl _atodbl (  _CRT_DOUBLE* _Result,   char*       _String);
   int __cdecl _atoldbl(  _LDOUBLE*    _Result,   char*       _String);

 
 int __cdecl _atoflt_l(
         _CRT_FLOAT* _Result,
        char const* _String,
      _locale_t   _Locale
    );

 
 int __cdecl _atodbl_l(
         _CRT_DOUBLE* _Result,
        char*        _String,
      _locale_t    _Locale
    );


 
 int __cdecl _atoldbl_l(
         _LDOUBLE* _Result,
        char*     _String,
      _locale_t _Locale
    );

 
 float __cdecl strtof(
                        char const* _String,
        char**      _EndPtr
    );

 
 float __cdecl _strtof_l(
                        char const* _String,
        char**      _EndPtr,
                      _locale_t   _Locale
    );

 
 double __cdecl strtod(
                        char const* _String,
        char**      _EndPtr
    );

 
 double __cdecl _strtod_l(
                        char const* _String,
        char**      _EndPtr,
                      _locale_t   _Locale
    );

 
 long double __cdecl strtold(
                        char const* _String,
        char**      _EndPtr
    );

 
 long double __cdecl _strtold_l(
                        char const* _String,
        char**      _EndPtr,
                      _locale_t   _Locale
    );

 
 long __cdecl strtol(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix
    );

 
 long __cdecl _strtol_l(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix,
                      _locale_t   _Locale
    );

 
 long long __cdecl strtoll(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix
    );

 
 long long __cdecl _strtoll_l(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix,
                      _locale_t   _Locale
    );

 
 unsigned long __cdecl strtoul(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix
    );

 
 unsigned long __cdecl _strtoul_l(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix,
                      _locale_t   _Locale
    );

 
 unsigned long long __cdecl strtoull(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix
    );

 
 unsigned long long __cdecl _strtoull_l(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix,
                      _locale_t   _Locale
    );

 
 __int64 __cdecl _strtoi64(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix
    );

 
 __int64 __cdecl _strtoi64_l(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix,
                      _locale_t   _Locale
    );

 
 unsigned __int64 __cdecl _strtoui64(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix
    );

 
 unsigned __int64 __cdecl _strtoui64_l(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix,
                      _locale_t   _Locale
    );








 

 errno_t __cdecl _itoa_s(
                              int    _Value,
      char*  _Buffer,
                              size_t _BufferCount,
                              int    _Radix
    );

extern "C++" { template <size_t _Size> inline   errno_t __cdecl _itoa_s(  int _Value, char (&_Buffer)[_Size],   int _Radix) throw() { return _itoa_s(_Value, _Buffer, _Size, _Radix); } }
#line 637 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdlib.h"

#pragma warning(push)
#pragma warning(disable: 28719) 
#pragma warning(disable: 28726) 
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_itoa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  char* __cdecl _itoa( int _Value,   char *_Buffer,  int _Radix);
#line 647 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdlib.h"
#pragma warning(pop)

 

 errno_t __cdecl _ltoa_s(
                              long   _Value,
      char*  _Buffer,
                              size_t _BufferCount,
                              int    _Radix
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _ltoa_s(  long _Value, char (&_Buffer)[_Size],   int _Radix) throw() { return _ltoa_s(_Value, _Buffer, _Size, _Radix); } }
#line 664 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdlib.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_ltoa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  char* __cdecl _ltoa( long _Value,   char *_Buffer,  int _Radix);
#line 671 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdlib.h"

 

 errno_t __cdecl _ultoa_s(
                              unsigned long _Value,
      char*         _Buffer,
                              size_t        _BufferCount,
                              int           _Radix
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _ultoa_s(  unsigned long _Value, char (&_Buffer)[_Size],   int _Radix) throw() { return _ultoa_s(_Value, _Buffer, _Size, _Radix); } }
#line 687 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdlib.h"

#pragma warning(push)
#pragma warning(disable: 28726) 
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_ultoa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  char* __cdecl _ultoa( unsigned long _Value,   char *_Buffer,  int _Radix);
#line 696 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdlib.h"
#pragma warning(pop)

 

 errno_t __cdecl _i64toa_s(
                              __int64 _Value,
      char*   _Buffer,
                              size_t  _BufferCount,
                              int     _Radix
    );

 
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_i64toa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
 char* __cdecl _i64toa(
                        __int64 _Value,
        char*   _Buffer,
                        int     _Radix
    );

 

 errno_t __cdecl _ui64toa_s(
                              unsigned __int64 _Value,
      char*            _Buffer,
                              size_t           _BufferCount,
                              int              _Radix
    );

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_ui64toa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
 char* __cdecl _ui64toa(
                        unsigned __int64 _Value,
        char*            _Buffer,
                        int              _Radix
    );













 

 errno_t __cdecl _ecvt_s(
      char* _Buffer,
       size_t                       _BufferCount,
       double                       _Value,
       int                          _DigitCount,
      int*                         _PtDec,
      int*                         _PtSign
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _ecvt_s(char (&_Buffer)[_Size],   double _Value,   int _DigitCount,   int* _PtDec,   int* _PtSign) throw() { return _ecvt_s(_Buffer, _Size, _Value, _DigitCount, _PtDec, _PtSign); } }
#line 762 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdlib.h"

  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ecvt_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
 char* __cdecl _ecvt(
       double _Value,
       int    _DigitCount,
      int*   _PtDec,
      int*   _PtSign
    );

 

 errno_t __cdecl _fcvt_s(
      char*  _Buffer,
                              size_t _BufferCount,
                              double _Value,
                              int    _FractionalDigitCount,
                             int*   _PtDec,
                             int*   _PtSign
    );

extern "C++" { template <size_t _Size> inline   errno_t __cdecl _fcvt_s(char (&_Buffer)[_Size],   double _Value,   int _FractionalDigitCount,   int* _PtDec,   int* _PtSign) throw() { return _fcvt_s(_Buffer, _Size, _Value, _FractionalDigitCount, _PtDec, _PtSign); } }
#line 791 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdlib.h"

 
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_fcvt_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
 char* __cdecl _fcvt(
       double _Value,
       int    _FractionalDigitCount,
      int*   _PtDec,
      int*   _PtSign
    );

 
 errno_t __cdecl _gcvt_s(
      char*  _Buffer,
                              size_t _BufferCount,
                              double _Value,
                              int    _DigitCount
    );

extern "C++" { template <size_t _Size> inline   errno_t __cdecl _gcvt_s(char (&_Buffer)[_Size],   double _Value,   int _DigitCount) throw() { return _gcvt_s(_Buffer, _Size, _Value, _DigitCount); } }
#line 816 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdlib.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_gcvt_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
 char* __cdecl _gcvt(
                        double _Value,
                        int    _DigitCount,
        char*  _Buffer
    );











    

#line 836 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdlib.h"
        
    #line 838 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdlib.h"

    


        
    #line 844 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdlib.h"

     
     int __cdecl ___mb_cur_max_func(void);

     
     int __cdecl ___mb_cur_max_l_func(_locale_t _Locale);
#line 851 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdlib.h"



 
 int __cdecl mblen(
        char const* _Ch,
                                             size_t      _MaxCount
    );

 
 int __cdecl _mblen_l(
        char const* _Ch,
                                             size_t      _MaxCount,
                                         _locale_t   _Locale
    );

 
 
 size_t __cdecl _mbstrlen(
      char const* _String
    );

 
 
 size_t __cdecl _mbstrlen_l(
        char const* _String,
      _locale_t   _Locale
    );

 
 
 size_t __cdecl _mbstrnlen(
      char const* _String,
        size_t      _MaxCount
    );

 
 
 size_t __cdecl _mbstrnlen_l(
        char const* _String,
          size_t      _MaxCount,
      _locale_t   _Locale
    );

 
 int __cdecl mbtowc(
                      wchar_t*    _DstCh,
      char const* _SrcCh,
                                      size_t      _SrcSizeInBytes
    );

 
 int __cdecl _mbtowc_l(
                      wchar_t*    _DstCh,
      char const* _SrcCh,
                                      size_t      _SrcSizeInBytes,
                                  _locale_t   _Locale
    );


 errno_t __cdecl mbstowcs_s(
                                                      size_t*     _PtNumOfCharConverted,
      wchar_t*    _DstBuf,
                                                           size_t      _SizeInWords,
                                     char const* _SrcBuf,
                                                           size_t      _MaxCount
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl mbstowcs_s(  size_t* _PtNumOfCharConverted,   wchar_t (&_Dest)[_Size],   char const* _Source,   size_t _MaxCount) throw() { return mbstowcs_s(_PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount); } }
#line 927 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdlib.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "mbstowcs_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  size_t __cdecl mbstowcs( wchar_t *_Dest,  char const* _Source,  size_t _MaxCount);
#line 934 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdlib.h"


 errno_t __cdecl _mbstowcs_s_l(
                                                      size_t*     _PtNumOfCharConverted,
      wchar_t*    _DstBuf,
                                                           size_t      _SizeInWords,
                                     char const* _SrcBuf,
                                                           size_t      _MaxCount,
                                                       _locale_t   _Locale
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _mbstowcs_s_l(  size_t* _PtNumOfCharConverted,   wchar_t (&_Dest)[_Size],   char const* _Source,   size_t _MaxCount,   _locale_t _Locale) throw() { return _mbstowcs_s_l(_PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount, _Locale); } }
#line 953 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdlib.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_mbstowcs_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  size_t __cdecl _mbstowcs_l(  wchar_t *_Dest,   char const* _Source,   size_t _MaxCount,   _locale_t _Locale);
#line 962 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdlib.h"




__declspec(deprecated("This function or variable may be unsafe. Consider using " "wctomb_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
 int __cdecl wctomb(
      char*   _MbCh,
                                wchar_t _WCh
    );

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wctomb_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
 int __cdecl _wctomb_l(
        char*     _MbCh,
                          wchar_t   _WCh,
                      _locale_t _Locale
    );



    
     errno_t __cdecl wctomb_s(
                                                         int*    _SizeConverted,
          char*   _MbCh,
                                                              rsize_t _SizeInBytes,
                                                              wchar_t _WCh
        );

#line 989 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdlib.h"


 errno_t __cdecl _wctomb_s_l(
                             int*     _SizeConverted,
      char*     _MbCh,
                                  size_t    _SizeInBytes,
                                  wchar_t   _WCh,
                              _locale_t _Locale);


 errno_t __cdecl wcstombs_s(
                                                               size_t*        _PtNumOfCharConverted,
      char*          _Dst,
                                                                    size_t         _DstSizeInBytes,
                                                                  wchar_t const* _Src,
                                                                    size_t         _MaxCountInBytes
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl wcstombs_s(  size_t* _PtNumOfCharConverted,   char (&_Dest)[_Size],   wchar_t const* _Source,   size_t _MaxCount) throw() { return wcstombs_s(_PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount); } }
#line 1015 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdlib.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "wcstombs_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  size_t __cdecl wcstombs( char *_Dest,  wchar_t const* _Source,  size_t _MaxCount);
#line 1022 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdlib.h"


 errno_t __cdecl _wcstombs_s_l(
                                                               size_t*        _PtNumOfCharConverted,
      char*          _Dst,
                                                                    size_t         _DstSizeInBytes,
                                                                  wchar_t const* _Src,
                                                                    size_t         _MaxCountInBytes,
                                                                _locale_t      _Locale
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcstombs_s_l(  size_t* _PtNumOfCharConverted,   char (&_Dest)[_Size],   wchar_t const* _Source,   size_t _MaxCount,   _locale_t _Locale) throw() { return _wcstombs_s_l(_PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount, _Locale); } }
#line 1041 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdlib.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcstombs_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  size_t __cdecl _wcstombs_l(  char *_Dest,   wchar_t const* _Source,   size_t _MaxCount,   _locale_t _Locale);
#line 1050 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdlib.h"




















 
 
 __declspec(allocator) char* __cdecl _fullpath(
      char*       _Buffer,
                                char const* _Path,
                                  size_t      _BufferCount
    );




 errno_t __cdecl _makepath_s(
      char*       _Buffer,
                              size_t      _BufferCount,
                        char const* _Drive,
                        char const* _Dir,
                        char const* _Filename,
                        char const* _Ext
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _makepath_s(char (&_Buffer)[_Size],   char const* _Drive,   char const* _Dir,   char const* _Filename,   char const* _Ext) throw() { return _makepath_s(_Buffer, _Size, _Drive, _Dir, _Filename, _Ext); } }
#line 1098 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdlib.h"

#pragma warning(push)
#pragma warning(disable: 28719) 
#pragma warning(disable: 28726) 
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_makepath_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  void __cdecl _makepath(  char *_Buffer,  char const* _Drive,  char const* _Dir,  char const* _Filename,  char const* _Ext);
#line 1110 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdlib.h"
#pragma warning(pop)

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_splitpath_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
 void __cdecl _splitpath(
                        char const* _FullPath,
        char*       _Drive,
        char*       _Dir,
        char*       _Filename,
        char*       _Ext
    );


 errno_t __cdecl _splitpath_s(
                                  char const* _FullPath,
         char*       _Drive,
                                    size_t      _DriveCount,
           char*       _Dir,
                                    size_t      _DirCount,
      char*       _Filename,
                                    size_t      _FilenameCount,
           char*       _Ext,
                                    size_t      _ExtCount
    );

extern "C++" { template <size_t _DriveSize, size_t _DirSize, size_t _NameSize, size_t _ExtSize> inline errno_t __cdecl _splitpath_s(   char const* _Dest,   char (&_Drive)[_DriveSize],   char (&_Dir)[_DirSize],   char (&_Name)[_NameSize],   char (&_Ext)[_ExtSize] ) throw() { return _splitpath_s(_Dest, _Drive, _DriveSize, _Dir, _DirSize, _Name, _NameSize, _Ext, _ExtSize); } }




 
 errno_t __cdecl getenv_s(
                                 size_t*     _RequiredCount,
      char*       _Buffer,
                                  rsize_t     _BufferCount,
                                char const* _VarName
    );

#line 1147 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdlib.h"




 int*       __cdecl __p___argc (void);
 char***    __cdecl __p___argv (void);
 wchar_t*** __cdecl __p___wargv(void);






    
    
    
#line 1164 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdlib.h"

 char***    __cdecl __p__environ (void);
 wchar_t*** __cdecl __p__wenviron(void);


    
#line 1171 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdlib.h"







    
    
#line 1181 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdlib.h"









      __declspec(deprecated("This function or variable may be unsafe. Consider using " "_dupenv_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
     char* __cdecl getenv(
          char const* _VarName
        );

    extern "C++" { template <size_t _Size> inline errno_t __cdecl getenv_s(  size_t* _RequiredCount, char (&_Buffer)[_Size],   char const* _VarName) throw() { return getenv_s(_RequiredCount, _Buffer, _Size, _VarName); } }
#line 1202 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdlib.h"

    


#line 1206 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdlib.h"

    
     errno_t __cdecl _dupenv_s(
            char**      _Buffer,
                                                                            size_t*     _BufferCount,
                                                                               char const* _VarName
        );

    

#line 1217 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdlib.h"

     int __cdecl system(
          char const* _Command
        );

    
    
    #pragma warning (push)
    #pragma warning (disable:6540)

     
     int __cdecl _putenv(
          char const* _EnvString
        );

    
     errno_t __cdecl _putenv_s(
          char const* _Name,
          char const* _Value
        );

    #pragma warning (pop)

     errno_t __cdecl _searchenv_s(
                                char const* _Filename,
                                char const* _VarName,
          char*       _Buffer,
                                  size_t      _BufferCount
        );

    extern "C++" { template <size_t _Size> inline errno_t __cdecl _searchenv_s(  char const* _Filename,   char const* _VarName, char (&_Buffer)[_Size]) throw() { return _searchenv_s(_Filename, _VarName, _Buffer, _Size); } }
#line 1254 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdlib.h"

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_searchenv_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  void __cdecl _searchenv( char const* _Filename,  char const* _VarName,   char *_Buffer);
#line 1261 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdlib.h"

    
    __declspec(deprecated("This function or variable has been superceded by newer library " "or operating system functionality. Consider using " "SetErrorMode" " " "instead. See online help for details."))
     void __cdecl _seterrormode(
          int _Mode
        );

    __declspec(deprecated("This function or variable has been superceded by newer library " "or operating system functionality. Consider using " "Beep" " " "instead. See online help for details."))
     void __cdecl _beep(
          unsigned _Frequency,
          unsigned _Duration
        );

    __declspec(deprecated("This function or variable has been superceded by newer library " "or operating system functionality. Consider using " "Sleep" " " "instead. See online help for details."))
     void __cdecl _sleep(
          unsigned long _Duration
        );

#line 1279 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdlib.h"









    




    
    

    #pragma warning(push)
    #pragma warning(disable: 4141) 

      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_ecvt" ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ecvt_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
     char* __cdecl ecvt(
           double _Value,
           int    _DigitCount,
          int*   _PtDec,
          int*   _PtSign
        );

      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_fcvt" ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_fcvt_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
     char* __cdecl fcvt(
           double _Value,
           int    _FractionalDigitCount,
          int*   _PtDec,
          int*   _PtSign
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_gcvt" ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_fcvt_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
     char* __cdecl gcvt(
                            double _Value,
                            int    _DigitCount,
            char*  _DstBuf
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_itoa" ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_itoa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
     char* __cdecl itoa(
                            int   _Value,
            char* _Buffer,
                            int   _Radix
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_ltoa" ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ltoa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
     char* __cdecl ltoa(
                            long  _Value,
            char* _Buffer,
                            int   _Radix
        );


    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_swab" ". See online help for details."))
     void __cdecl swab(
          char* _Buf1,
          char* _Buf2,
                                     int   _SizeInBytes
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_ultoa" ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ultoa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
     char* __cdecl ultoa(
                            unsigned long _Value,
            char*         _Buffer,
                            int           _Radix
        );

    

      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_putenv" ". See online help for details."))
     int __cdecl putenv(
          char const* _EnvString
        );

    #pragma warning(pop)

    _onexit_t __cdecl onexit(  _onexit_t _Func);

#line 1363 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdlib.h"



} __pragma(pack(pop))
#line 1368 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdlib.h"
#line 14 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\cstdlib"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4472 4494 4514 4571 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4702 4793 4820 4988 5026 5027 5045  4984 5053 )





[[nodiscard]]   inline double abs(  double _Xx) noexcept  {
    return :: fabs(_Xx);
}

[[nodiscard]]   inline float abs(  float _Xx) noexcept  {
    return :: fabsf(_Xx);
}

[[nodiscard]]   inline long double abs(  long double _Xx) noexcept  {
    return :: fabsl(_Xx);
}

namespace std {
using :: size_t;
using :: div_t;
using :: ldiv_t;
using :: abort;
using :: abs;
using :: atexit;
using :: atof;
using :: atoi;
using :: atol;
using :: bsearch;
using :: calloc;
using :: div;
using :: exit;
using :: free;
using :: labs;
using :: ldiv;
using :: malloc;
using :: mblen;
using :: mbstowcs;
using :: mbtowc;
using :: qsort;
using :: rand;
using :: realloc;
using :: srand;
using :: strtod;
using :: strtol;
using :: strtoul;
using :: wcstombs;
using :: wctomb;

using :: lldiv_t;


using :: getenv;
using :: system;
#line 72 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\cstdlib"

using :: atoll;
using :: llabs;
using :: lldiv;
using :: strtof;
using :: strtold;
using :: strtoll;
using :: strtoull;

using :: _Exit;
using :: at_quick_exit;
using :: quick_exit;
}



#pragma warning(pop)
#pragma pack(pop)

#line 92 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\cstdlib"
#line 93 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\cstdlib"
#line 13 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\xstddef"
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\initializer_list"





#pragma once






#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4472 4494 4514 4571 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4702 4793 4820 4988 5026 5027 5045  4984 5053 )




namespace std {

template <class _Elem>
class initializer_list {
public:
    using value_type      = _Elem;
    using reference       = const _Elem&;
    using const_reference = const _Elem&;
    using size_type       = size_t;

    using iterator       = const _Elem*;
    using const_iterator = const _Elem*;

    constexpr initializer_list() noexcept : _First(nullptr), _Last(nullptr) {}

    constexpr initializer_list(const _Elem* _First_arg, const _Elem* _Last_arg) noexcept
        : _First(_First_arg), _Last(_Last_arg) {}

    [[nodiscard]] constexpr const _Elem* begin() const noexcept {
        return _First;
    }

    [[nodiscard]] constexpr const _Elem* end() const noexcept {
        return _Last;
    }

    [[nodiscard]] constexpr size_t size() const noexcept {
        return static_cast<size_t>(_Last - _First);
    }

private:
    const _Elem* _First;
    const _Elem* _Last;
};


template <class _Elem>
[[nodiscard]] constexpr const _Elem* begin(initializer_list<_Elem> _Ilist) noexcept {
    return _Ilist.begin();
}


template <class _Elem>
[[nodiscard]] constexpr const _Elem* end(initializer_list<_Elem> _Ilist) noexcept {
    return _Ilist.end();
}
}


#pragma warning(pop)
#pragma pack(pop)
#line 72 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\initializer_list"
#line 73 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\initializer_list"
#line 14 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\xstddef"


#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4472 4494 4514 4571 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4702 4793 4820 4988 5026 5027 5045  4984 5053 )




namespace std {

template <class>

 constexpr bool _Always_false = false;




template <class _Arg, class _Result>
struct unary_function { 
    using argument_type = _Arg;
    using result_type   = _Result;
};


template <class _Arg1, class _Arg2, class _Result>
struct binary_function { 
    using first_argument_type  = _Arg1;
    using second_argument_type = _Arg2;
    using result_type          = _Result;
};
#line 46 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\xstddef"


template <class _Ty = void>
struct plus {
     typedef _Ty first_argument_type;
     typedef _Ty second_argument_type;
     typedef _Ty result_type;

    constexpr _Ty operator()(const _Ty& _Left, const _Ty& _Right) const {
        return _Left + _Right;
    }
};


template <class _Ty = void>
struct minus {
     typedef _Ty first_argument_type;
     typedef _Ty second_argument_type;
     typedef _Ty result_type;

    constexpr _Ty operator()(const _Ty& _Left, const _Ty& _Right) const {
        return _Left - _Right;
    }
};


template <class _Ty = void>
struct multiplies {
     typedef _Ty first_argument_type;
     typedef _Ty second_argument_type;
     typedef _Ty result_type;

    constexpr _Ty operator()(const _Ty& _Left, const _Ty& _Right) const {
        return _Left * _Right;
    }
};


template <class _Ty = void>
struct equal_to {
     typedef _Ty first_argument_type;
     typedef _Ty second_argument_type;
     typedef bool result_type;

    constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const {
        return _Left == _Right;
    }
};


template <class _Ty = void>
struct not_equal_to {
     typedef _Ty first_argument_type;
     typedef _Ty second_argument_type;
     typedef bool result_type;

    constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const {
        return _Left != _Right;
    }
};


template <class _Ty = void>
struct greater {
     typedef _Ty first_argument_type;
     typedef _Ty second_argument_type;
     typedef bool result_type;

    constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const {
        return _Left > _Right;
    }
};


template <class _Ty = void>
struct less {
     typedef _Ty first_argument_type;
     typedef _Ty second_argument_type;
     typedef bool result_type;

    constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const {
        return _Left < _Right;
    }
};


template <class _Ty = void>
struct greater_equal {
     typedef _Ty first_argument_type;
     typedef _Ty second_argument_type;
     typedef bool result_type;

    constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const {
        return _Left >= _Right;
    }
};


template <class _Ty = void>
struct less_equal {
     typedef _Ty first_argument_type;
     typedef _Ty second_argument_type;
     typedef bool result_type;

    constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const {
        return _Left <= _Right;
    }
};


template <>
struct plus<void> {
    using is_transparent = int;

    template <class _Ty1, class _Ty2>
    constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        noexcept(noexcept(static_cast<_Ty1&&>(_Left) + static_cast<_Ty2&&>(_Right))) 
        -> decltype(static_cast<_Ty1&&>(_Left) + static_cast<_Ty2&&>(_Right)) {
        return static_cast<_Ty1&&>(_Left) + static_cast<_Ty2&&>(_Right);
    }
};


template <>
struct minus<void> {
    using is_transparent = int;

    template <class _Ty1, class _Ty2>
    constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        noexcept(noexcept(static_cast<_Ty1&&>(_Left) - static_cast<_Ty2&&>(_Right))) 
        -> decltype(static_cast<_Ty1&&>(_Left) - static_cast<_Ty2&&>(_Right)) {
        return static_cast<_Ty1&&>(_Left) - static_cast<_Ty2&&>(_Right);
    }
};


template <>
struct multiplies<void> {
    using is_transparent = int;

    template <class _Ty1, class _Ty2>
    constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        noexcept(noexcept(static_cast<_Ty1&&>(_Left) * static_cast<_Ty2&&>(_Right))) 
        -> decltype(static_cast<_Ty1&&>(_Left) * static_cast<_Ty2&&>(_Right)) {
        return static_cast<_Ty1&&>(_Left) * static_cast<_Ty2&&>(_Right);
    }
};


template <>
struct equal_to<void> {
    using is_transparent = int;

    template <class _Ty1, class _Ty2>
    constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        noexcept(noexcept(static_cast<_Ty1&&>(_Left) == static_cast<_Ty2&&>(_Right))) 
        -> decltype(static_cast<_Ty1&&>(_Left) == static_cast<_Ty2&&>(_Right)) {
        return static_cast<_Ty1&&>(_Left) == static_cast<_Ty2&&>(_Right);
    }
};


template <>
struct not_equal_to<void> {
    using is_transparent = int;

    template <class _Ty1, class _Ty2>
    constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        noexcept(noexcept(static_cast<_Ty1&&>(_Left) != static_cast<_Ty2&&>(_Right))) 
        -> decltype(static_cast<_Ty1&&>(_Left) != static_cast<_Ty2&&>(_Right)) {
        return static_cast<_Ty1&&>(_Left) != static_cast<_Ty2&&>(_Right);
    }
};


template <>
struct greater<void> {
    using is_transparent = int;

    template <class _Ty1, class _Ty2>
    constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        noexcept(noexcept(static_cast<_Ty1&&>(_Left) > static_cast<_Ty2&&>(_Right))) 
        -> decltype(static_cast<_Ty1&&>(_Left) > static_cast<_Ty2&&>(_Right)) {
        return static_cast<_Ty1&&>(_Left) > static_cast<_Ty2&&>(_Right);
    }
};


template <>
struct less<void> {
    using is_transparent = int;

    template <class _Ty1, class _Ty2>
    constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        noexcept(noexcept(static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right))) 
        -> decltype(static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right)) {
        return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);
    }
};


template <>
struct greater_equal<void> {
    using is_transparent = int;

    template <class _Ty1, class _Ty2>
    constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        noexcept(noexcept(static_cast<_Ty1&&>(_Left) >= static_cast<_Ty2&&>(_Right))) 
        -> decltype(static_cast<_Ty1&&>(_Left) >= static_cast<_Ty2&&>(_Right)) {
        return static_cast<_Ty1&&>(_Left) >= static_cast<_Ty2&&>(_Right);
    }
};


template <>
struct less_equal<void> {
    using is_transparent = int;

    template <class _Ty1, class _Ty2>
    constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        noexcept(noexcept(static_cast<_Ty1&&>(_Left) <= static_cast<_Ty2&&>(_Right))) 
        -> decltype(static_cast<_Ty1&&>(_Left) <= static_cast<_Ty2&&>(_Right)) {
        return static_cast<_Ty1&&>(_Left) <= static_cast<_Ty2&&>(_Right);
    }
};


template <class _Ty>
[[nodiscard]] constexpr _Ty* addressof(_Ty& _Val) noexcept {
    return __builtin_addressof(_Val);
}

template <class _Ty>
const _Ty* addressof(const _Ty&&) = delete;


template <class _Ptrty>
[[nodiscard]] constexpr auto _Unfancy(_Ptrty _Ptr) noexcept { 
    return ::std:: addressof(*_Ptr);
}

template <class _Ty>
[[nodiscard]] constexpr _Ty* _Unfancy(_Ty* _Ptr) noexcept { 
    return _Ptr;
}
}








#line 301 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\xstddef"




#line 306 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\xstddef"

#line 308 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\xstddef"








#line 317 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\xstddef"






#line 324 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\xstddef"

























#line 350 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\xstddef"


























#line 377 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\xstddef"













































#line 423 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\xstddef"



#pragma warning(pop)
#pragma pack(pop)
#line 429 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\xstddef"
#line 430 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\xstddef"
#line 12 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\type_traits"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4472 4494 4514 4571 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4702 4793 4820 4988 5026 5027 5045  4984 5053 )




namespace std {

template <class _Ty, _Ty... _Vals>
struct integer_sequence { 
    static_assert(is_integral_v<_Ty>, "integer_sequence<T, I...> requires T to be an integral type.");

    using value_type = _Ty;

    [[nodiscard]] static constexpr size_t size() noexcept {
        return sizeof...(_Vals);
    }
};


template <class _Ty, _Ty _Size>
using make_integer_sequence = __make_integer_seq<integer_sequence, _Ty, _Size>;

template <size_t... _Vals>
using index_sequence = integer_sequence<size_t, _Vals...>;

template <size_t _Size>
using make_index_sequence = make_integer_sequence<size_t, _Size>;

template <class... _Types>
using index_sequence_for = make_index_sequence<sizeof...(_Types)>;


template <bool _First_value, class _First, class... _Rest>
struct _Conjunction { 
    using type = _First;
};

template <class _True, class _Next, class... _Rest>
struct _Conjunction<true, _True, _Next, _Rest...> { 
    using type = typename _Conjunction<_Next::value, _Next, _Rest...>::type;
};

template <class... _Traits>
struct conjunction : true_type {}; 

template <class _First, class... _Rest>
struct conjunction<_First, _Rest...> : _Conjunction<_First::value, _First, _Rest...>::type {
    
};

template <class... _Traits>
 constexpr bool conjunction_v = conjunction<_Traits...>::value;


template <class _Trait>
struct negation : bool_constant<!static_cast<bool>(_Trait::value)> {}; 

template <class _Trait>
 constexpr bool negation_v = negation<_Trait>::value;




#line 79 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\type_traits"


template <class... _Types>
struct _Arg_types {}; 

template <class _Ty1>
struct _Arg_types<_Ty1> {
     typedef _Ty1 argument_type;
};

template <class _Ty1, class _Ty2>
struct _Arg_types<_Ty1, _Ty2> {
     typedef _Ty1 first_argument_type;
     typedef _Ty2 second_argument_type;
};


template <class _Ty>
struct _Is_function { 
    using _Bool_type = false_type; 
};








template <class _Ret, class... _Types> struct _Is_function<_Ret __cdecl(_Types...)   > : _Arg_types<_Types...> { using _Bool_type = true_type;  typedef _Ret result_type; };    template <class _Ret, class... _Types> struct _Is_function<_Ret __vectorcall(_Types...)   > : _Arg_types<_Types...> { using _Bool_type = true_type;  typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Is_function<_Ret __cdecl(_Types...) const  > : _Arg_types<_Types...> { using _Bool_type = true_type;  typedef _Ret result_type; };    template <class _Ret, class... _Types> struct _Is_function<_Ret __vectorcall(_Types...) const  > : _Arg_types<_Types...> { using _Bool_type = true_type;  typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Is_function<_Ret __cdecl(_Types...) volatile  > : _Arg_types<_Types...> { using _Bool_type = true_type;  typedef _Ret result_type; };    template <class _Ret, class... _Types> struct _Is_function<_Ret __vectorcall(_Types...) volatile  > : _Arg_types<_Types...> { using _Bool_type = true_type;  typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Is_function<_Ret __cdecl(_Types...) const volatile  > : _Arg_types<_Types...> { using _Bool_type = true_type;  typedef _Ret result_type; };    template <class _Ret, class... _Types> struct _Is_function<_Ret __vectorcall(_Types...) const volatile  > : _Arg_types<_Types...> { using _Bool_type = true_type;  typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Is_function<_Ret __cdecl(_Types...)  & > : _Arg_types<_Types...> { using _Bool_type = true_type;  typedef _Ret result_type; };    template <class _Ret, class... _Types> struct _Is_function<_Ret __vectorcall(_Types...)  & > : _Arg_types<_Types...> { using _Bool_type = true_type;  typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Is_function<_Ret __cdecl(_Types...) const & > : _Arg_types<_Types...> { using _Bool_type = true_type;  typedef _Ret result_type; };    template <class _Ret, class... _Types> struct _Is_function<_Ret __vectorcall(_Types...) const & > : _Arg_types<_Types...> { using _Bool_type = true_type;  typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Is_function<_Ret __cdecl(_Types...) volatile & > : _Arg_types<_Types...> { using _Bool_type = true_type;  typedef _Ret result_type; };    template <class _Ret, class... _Types> struct _Is_function<_Ret __vectorcall(_Types...) volatile & > : _Arg_types<_Types...> { using _Bool_type = true_type;  typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Is_function<_Ret __cdecl(_Types...) const volatile & > : _Arg_types<_Types...> { using _Bool_type = true_type;  typedef _Ret result_type; };    template <class _Ret, class... _Types> struct _Is_function<_Ret __vectorcall(_Types...) const volatile & > : _Arg_types<_Types...> { using _Bool_type = true_type;  typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Is_function<_Ret __cdecl(_Types...)  && > : _Arg_types<_Types...> { using _Bool_type = true_type;  typedef _Ret result_type; };    template <class _Ret, class... _Types> struct _Is_function<_Ret __vectorcall(_Types...)  && > : _Arg_types<_Types...> { using _Bool_type = true_type;  typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Is_function<_Ret __cdecl(_Types...) const && > : _Arg_types<_Types...> { using _Bool_type = true_type;  typedef _Ret result_type; };    template <class _Ret, class... _Types> struct _Is_function<_Ret __vectorcall(_Types...) const && > : _Arg_types<_Types...> { using _Bool_type = true_type;  typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Is_function<_Ret __cdecl(_Types...) volatile && > : _Arg_types<_Types...> { using _Bool_type = true_type;  typedef _Ret result_type; };    template <class _Ret, class... _Types> struct _Is_function<_Ret __vectorcall(_Types...) volatile && > : _Arg_types<_Types...> { using _Bool_type = true_type;  typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Is_function<_Ret __cdecl(_Types...) const volatile && > : _Arg_types<_Types...> { using _Bool_type = true_type;  typedef _Ret result_type; };    template <class _Ret, class... _Types> struct _Is_function<_Ret __vectorcall(_Types...) const volatile && > : _Arg_types<_Types...> { using _Bool_type = true_type;  typedef _Ret result_type; };









template <class _Ret, class... _Types> struct _Is_function<_Ret(_Types..., ...) > { using _Bool_type = true_type;  typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Is_function<_Ret(_Types..., ...) const> { using _Bool_type = true_type;  typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Is_function<_Ret(_Types..., ...) volatile> { using _Bool_type = true_type;  typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Is_function<_Ret(_Types..., ...) const volatile> { using _Bool_type = true_type;  typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Is_function<_Ret(_Types..., ...) &> { using _Bool_type = true_type;  typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Is_function<_Ret(_Types..., ...) const&> { using _Bool_type = true_type;  typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Is_function<_Ret(_Types..., ...) volatile&> { using _Bool_type = true_type;  typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Is_function<_Ret(_Types..., ...) const volatile&> { using _Bool_type = true_type;  typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Is_function<_Ret(_Types..., ...) &&> { using _Bool_type = true_type;  typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Is_function<_Ret(_Types..., ...) const&&> { using _Bool_type = true_type;  typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Is_function<_Ret(_Types..., ...) volatile&&> { using _Bool_type = true_type;  typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Is_function<_Ret(_Types..., ...) const volatile&&> { using _Bool_type = true_type;  typedef _Ret result_type; };


template <class _Ty>
struct is_function : _Is_function<_Ty>::_Bool_type {}; 

template <class _Ty>
 constexpr bool is_function_v = _Is_function<_Ty>::_Bool_type::value;


template <class _Ty>
struct _Is_memfunptr { 
    using _Bool_type = false_type; 
};











template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...)   > : _Arg_types< _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int , int&&>, _Ret(_Types...)>; };     template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...)   > : _Arg_types< _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int , int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const  > : _Arg_types<const _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int , int&&>, _Ret(_Types...)>; };     template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const  > : _Arg_types<const _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int , int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) volatile  > : _Arg_types<volatile _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int , int&&>, _Ret(_Types...)>; };     template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) volatile  > : _Arg_types<volatile _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int , int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const volatile  > : _Arg_types<const volatile _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int , int&&>, _Ret(_Types...)>; };     template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const volatile  > : _Arg_types<const volatile _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int , int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...)  & > : _Arg_types< _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &, int&&>, _Ret(_Types...)>; };     template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...)  & > : _Arg_types< _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const & > : _Arg_types<const _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &, int&&>, _Ret(_Types...)>; };     template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const & > : _Arg_types<const _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) volatile & > : _Arg_types<volatile _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &, int&&>, _Ret(_Types...)>; };     template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) volatile & > : _Arg_types<volatile _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const volatile & > : _Arg_types<const volatile _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &, int&&>, _Ret(_Types...)>; };     template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const volatile & > : _Arg_types<const volatile _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...)  && > : _Arg_types< _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &&, int&&>, _Ret(_Types...)>; };     template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...)  && > : _Arg_types< _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &&, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const && > : _Arg_types<const _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &&, int&&>, _Ret(_Types...)>; };     template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const && > : _Arg_types<const _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &&, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) volatile && > : _Arg_types<volatile _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &&, int&&>, _Ret(_Types...)>; };     template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) volatile && > : _Arg_types<volatile _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &&, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const volatile && > : _Arg_types<const volatile _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &&, int&&>, _Ret(_Types...)>; };     template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const volatile && > : _Arg_types<const volatile _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &&, int&&>, _Ret(_Types...)>; };












template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) > { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) volatile> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const volatile> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) &> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const&> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) volatile&> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const volatile&> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) &&> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const&&> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) volatile&&> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const volatile&&> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; };



template <class _Ty>
 constexpr bool is_void_v = is_same_v<remove_cv_t<_Ty>, void>;

template <class _Ty>
struct is_void : bool_constant<is_void_v<_Ty>> {};


template <class... _Types>
using void_t = void;



template <class _Ty>
struct add_const { 
    using type = const _Ty;
};

template <class _Ty>
using add_const_t = typename add_const<_Ty>::type;


template <class _Ty>
struct add_volatile { 
    using type = volatile _Ty;
};

template <class _Ty>
using add_volatile_t = typename add_volatile<_Ty>::type;


template <class _Ty>
struct add_cv { 
    using type = const volatile _Ty;
};

template <class _Ty>
using add_cv_t = typename add_cv<_Ty>::type;


template <class _Ty, class = void>
struct _Add_reference { 
    using _Lvalue = _Ty;
    using _Rvalue = _Ty;
};

template <class _Ty>
struct _Add_reference<_Ty, void_t<_Ty&>> { 
    using _Lvalue = _Ty&;
    using _Rvalue = _Ty&&;
};


template <class _Ty>
struct add_lvalue_reference {
    using type = typename _Add_reference<_Ty>::_Lvalue;
};

template <class _Ty>
using add_lvalue_reference_t = typename _Add_reference<_Ty>::_Lvalue;


template <class _Ty>
struct add_rvalue_reference {
    using type = typename _Add_reference<_Ty>::_Rvalue;
};

template <class _Ty>
using add_rvalue_reference_t = typename _Add_reference<_Ty>::_Rvalue;


template <class _Ty>
add_rvalue_reference_t<_Ty> declval() noexcept;


template <class _Ty>
struct remove_extent { 
    using type = _Ty;
};

template <class _Ty, size_t _Ix>
struct remove_extent<_Ty[_Ix]> {
    using type = _Ty;
};

template <class _Ty>
struct remove_extent<_Ty[]> {
    using type = _Ty;
};

template <class _Ty>
using remove_extent_t = typename remove_extent<_Ty>::type;


template <class _Ty>
struct remove_all_extents { 
    using type = _Ty;
};

template <class _Ty, size_t _Ix>
struct remove_all_extents<_Ty[_Ix]> {
    using type = typename remove_all_extents<_Ty>::type;
};

template <class _Ty>
struct remove_all_extents<_Ty[]> {
    using type = typename remove_all_extents<_Ty>::type;
};

template <class _Ty>
using remove_all_extents_t = typename remove_all_extents<_Ty>::type;


template <class _Ty>
struct remove_pointer {
    using type = _Ty;
};

template <class _Ty>
struct remove_pointer<_Ty*> {
    using type = _Ty;
};

template <class _Ty>
struct remove_pointer<_Ty* const> {
    using type = _Ty;
};

template <class _Ty>
struct remove_pointer<_Ty* volatile> {
    using type = _Ty;
};


template <class _Ty>
struct remove_pointer<_Ty* const volatile> {
    using type = _Ty;
};

template <class _Ty>
using remove_pointer_t = typename remove_pointer<_Ty>::type;


template <class _Ty, class = void>
struct _Add_pointer { 
    using type = _Ty;
};

template <class _Ty>
struct _Add_pointer<_Ty, void_t<remove_reference_t<_Ty>*>> { 
    using type = remove_reference_t<_Ty>*;
};

template <class _Ty>
struct add_pointer {
    using type = typename _Add_pointer<_Ty>::type;
};

template <class _Ty>
using add_pointer_t = typename _Add_pointer<_Ty>::type;



template <class>
 constexpr bool is_array_v = false; 

template <class _Ty, size_t _Nx>
 constexpr bool is_array_v<_Ty[_Nx]> = true;

template <class _Ty>
 constexpr bool is_array_v<_Ty[]> = true;

template <class _Ty>
struct is_array : bool_constant<is_array_v<_Ty>> {};


template <class>
 constexpr bool is_lvalue_reference_v = false; 

template <class _Ty>
 constexpr bool is_lvalue_reference_v<_Ty&> = true;

template <class _Ty>
struct is_lvalue_reference : bool_constant<is_lvalue_reference_v<_Ty>> {};


template <class>
 constexpr bool is_rvalue_reference_v = false; 

template <class _Ty>
 constexpr bool is_rvalue_reference_v<_Ty&&> = true;

template <class _Ty>
struct is_rvalue_reference : bool_constant<is_rvalue_reference_v<_Ty>> {};


template <class>
 constexpr bool is_reference_v = false; 

template <class _Ty>
 constexpr bool is_reference_v<_Ty&> = true;

template <class _Ty>
 constexpr bool is_reference_v<_Ty&&> = true;

template <class _Ty>
struct is_reference : bool_constant<is_reference_v<_Ty>> {};


template <class _Ty, bool _Pmf = _Is_memfunptr<_Ty>::_Bool_type::value>
struct _Is_member_object_pointer { 
    static constexpr bool value = false;
};

template <class _Ty1, class _Ty2>
struct _Is_member_object_pointer<_Ty1 _Ty2::*, false> {
    static constexpr bool value = true;
    using _Class_type           = _Ty2;
};

template <class _Ty>
 constexpr bool is_member_object_pointer_v = 
    _Is_member_object_pointer<remove_cv_t<_Ty>>::value;

template <class _Ty>
struct is_member_object_pointer : bool_constant<is_member_object_pointer_v<_Ty>> {};


template <class _Ty>
 constexpr bool is_member_function_pointer_v = 
    _Is_memfunptr<remove_cv_t<_Ty>>::_Bool_type::value;

template <class _Ty>
struct is_member_function_pointer : bool_constant<is_member_function_pointer_v<_Ty>> {};


template <class>
 constexpr bool is_pointer_v = false; 

template <class _Ty>
 constexpr bool is_pointer_v<_Ty*> = true;

template <class _Ty>
 constexpr bool is_pointer_v<_Ty* const> = true;

template <class _Ty>
 constexpr bool is_pointer_v<_Ty* volatile> = true;

template <class _Ty>
 constexpr bool is_pointer_v<_Ty* const volatile> = true;

template <class _Ty>
struct is_pointer : bool_constant<is_pointer_v<_Ty>> {};


template <class _Ty>
 constexpr bool is_null_pointer_v =
    is_same_v<remove_cv_t<_Ty>, nullptr_t>; 

template <class _Ty>
struct is_null_pointer : bool_constant<is_null_pointer_v<_Ty>> {};


template <class _Ty>
struct is_union : bool_constant<__is_union(_Ty)> {}; 

template <class _Ty>
 constexpr bool is_union_v = __is_union(_Ty);


template <class _Ty>
struct is_class : bool_constant<__is_class(_Ty)> {}; 

template <class _Ty>
 constexpr bool is_class_v = __is_class(_Ty);


template <class _Ty>
 constexpr bool is_fundamental_v = is_arithmetic_v<_Ty> || is_void_v<_Ty> || is_null_pointer_v<_Ty>;

template <class _Ty>
struct is_fundamental : bool_constant<is_fundamental_v<_Ty>> {}; 


template <class _Ty>
 constexpr bool is_object_v = !is_function_v<_Ty> && !is_reference_v<_Ty> && !is_void_v<_Ty>;

template <class _Ty>
struct is_object : bool_constant<is_object_v<_Ty>> {}; 


template <class _From, class _To>
struct is_convertible : bool_constant<__is_convertible_to(_From, _To)> {
    
};

template <class _From, class _To>
 constexpr bool is_convertible_v = __is_convertible_to(_From, _To);


template <class _Ty>
struct is_enum : bool_constant<__is_enum(_Ty)> {}; 

template <class _Ty>
 constexpr bool is_enum_v = __is_enum(_Ty);


template <class _Ty>
struct is_compound : bool_constant<!is_fundamental_v<_Ty>> {}; 

template <class _Ty>
 constexpr bool is_compound_v = !is_fundamental_v<_Ty>;


template <class _Ty>
 constexpr bool is_member_pointer_v = is_member_object_pointer_v<_Ty> || is_member_function_pointer_v<_Ty>;

template <class _Ty>
struct is_member_pointer : bool_constant<is_member_pointer_v<_Ty>> {}; 


template <class _Ty>
 constexpr bool is_scalar_v = 
    is_arithmetic_v<_Ty> || is_enum_v<_Ty> || is_pointer_v<_Ty> || is_member_pointer_v<_Ty> || is_null_pointer_v<_Ty>;

template <class _Ty>
struct is_scalar : bool_constant<is_scalar_v<_Ty>> {};


template <class>
 constexpr bool is_const_v = false; 

template <class _Ty>
 constexpr bool is_const_v<const _Ty> = true;

template <class _Ty>
struct is_const : bool_constant<is_const_v<_Ty>> {};


template <class>
 constexpr bool is_volatile_v = false; 

template <class _Ty>
 constexpr bool is_volatile_v<volatile _Ty> = true;

template <class _Ty>
struct is_volatile : bool_constant<is_volatile_v<_Ty>> {};


template <class _Ty>
struct is_pod : bool_constant<__is_pod(_Ty)> {}; 

template <class _Ty>
 constexpr bool is_pod_v = __is_pod(_Ty);


template <class _Ty>
struct is_empty : bool_constant<__is_empty(_Ty)> {}; 

template <class _Ty>
 constexpr bool is_empty_v = __is_empty(_Ty);


template <class _Ty>
struct is_polymorphic : bool_constant<__is_polymorphic(_Ty)> {}; 

template <class _Ty>
 constexpr bool is_polymorphic_v = __is_polymorphic(_Ty);


template <class _Ty>
struct is_abstract : bool_constant<__is_abstract(_Ty)> {}; 

template <class _Ty>
 constexpr bool is_abstract_v = __is_abstract(_Ty);


template <class _Ty>
struct is_final : bool_constant<__is_final(_Ty)> {}; 

template <class _Ty>
 constexpr bool is_final_v = __is_final(_Ty);


template <class _Ty>
struct is_standard_layout : bool_constant<__is_standard_layout(_Ty)> {}; 

template <class _Ty>
 constexpr bool is_standard_layout_v = __is_standard_layout(_Ty);


template <class _Ty>
struct  is_literal_type : bool_constant<__is_literal_type(_Ty)> {
    
};

template <class _Ty>
  constexpr bool is_literal_type_v = __is_literal_type(_Ty);



template <class _Ty>
struct is_trivial : bool_constant<__is_trivially_constructible(_Ty) && __is_trivially_copyable(_Ty)> {
    
};

template <class _Ty>
 constexpr bool is_trivial_v = __is_trivially_constructible(_Ty) && __is_trivially_copyable(_Ty);






#line 574 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\type_traits"


template <class _Ty>
struct is_trivially_copyable : bool_constant<__is_trivially_copyable(_Ty)> {
    
};

template <class _Ty>
 constexpr bool is_trivially_copyable_v = __is_trivially_copyable(_Ty);


template <class _Ty>
struct has_virtual_destructor : bool_constant<__has_virtual_destructor(_Ty)> {
    
};

template <class _Ty>
 constexpr bool has_virtual_destructor_v = __has_virtual_destructor(_Ty);

















#line 610 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\type_traits"



template <class _Ty, class... _Args>
struct is_constructible : bool_constant<__is_constructible(_Ty, _Args...)> {
    
};

template <class _Ty, class... _Args>
 constexpr bool is_constructible_v = __is_constructible(_Ty, _Args...);


template <class _Ty>
struct is_copy_constructible : bool_constant<__is_constructible(_Ty, add_lvalue_reference_t<const _Ty>)> {
    
};

template <class _Ty>
 constexpr bool is_copy_constructible_v = __is_constructible(_Ty, add_lvalue_reference_t<const _Ty>);


template <class _Ty>
struct is_default_constructible : bool_constant<__is_constructible(_Ty)> {
    
};

template <class _Ty>
 constexpr bool is_default_constructible_v = __is_constructible(_Ty);


template <class _Ty, class = void>
struct _Is_implicitly_default_constructible : false_type {
    
};

template <class _Ty>
void _Implicitly_default_construct(const _Ty&);

template <class _Ty>
struct _Is_implicitly_default_constructible<_Ty, void_t<decltype(_Implicitly_default_construct<_Ty>({}))>> : true_type {
};


template <class _Ty>
struct is_move_constructible : bool_constant<__is_constructible(_Ty, _Ty)> {
    
};

template <class _Ty>
 constexpr bool is_move_constructible_v = __is_constructible(_Ty, _Ty);


template <class _To, class _From>
struct is_assignable : bool_constant<__is_assignable(_To, _From)> {}; 

template <class _To, class _From>
 constexpr bool is_assignable_v = __is_assignable(_To, _From);


template <class _Ty>
struct is_copy_assignable
    : bool_constant<__is_assignable(add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<const _Ty>)> {
    
};

template <class _Ty>
 constexpr bool is_copy_assignable_v = __is_assignable(
    add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<const _Ty>);


template <class _Ty>
struct _Is_copy_assignable_no_precondition_check
    : bool_constant<__is_assignable_no_precondition_check(
          add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<const _Ty>)> {};

template <class _Ty>
 constexpr bool _Is_copy_assignable_unchecked_v = __is_assignable_no_precondition_check(
    add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<const _Ty>);






#line 695 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\type_traits"


template <class _Ty>
struct is_move_assignable : bool_constant<__is_assignable(add_lvalue_reference_t<_Ty>, _Ty)> {
    
};

template <class _Ty>
 constexpr bool is_move_assignable_v = __is_assignable(add_lvalue_reference_t<_Ty>, _Ty);


template <class _Ty>
struct _Is_move_assignable_no_precondition_check
    : bool_constant<__is_assignable_no_precondition_check(add_lvalue_reference_t<_Ty>, _Ty)> {};

template <class _Ty>
 constexpr bool _Is_move_assignable_unchecked_v = __is_assignable_no_precondition_check(
    add_lvalue_reference_t<_Ty>, _Ty);






#line 720 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\type_traits"


template <class _Ty>
struct is_destructible : bool_constant<__is_destructible(_Ty)> {
    
};

template <class _Ty>
 constexpr bool is_destructible_v = __is_destructible(_Ty);



template <class _Ty, class... _Args>
struct is_trivially_constructible : bool_constant<__is_trivially_constructible(_Ty, _Args...)> {
    
};

template <class _Ty, class... _Args>
 constexpr bool is_trivially_constructible_v = __is_trivially_constructible(_Ty, _Args...);


template <class _Ty>
struct is_trivially_copy_constructible
    : bool_constant<__is_trivially_constructible(_Ty, add_lvalue_reference_t<const _Ty>)> {
    
};

template <class _Ty>
 constexpr bool is_trivially_copy_constructible_v = __is_trivially_constructible(
    _Ty, add_lvalue_reference_t<const _Ty>);


template <class _Ty>
struct is_trivially_default_constructible : bool_constant<__is_trivially_constructible(_Ty)> {
    
};

template <class _Ty>
 constexpr bool is_trivially_default_constructible_v = __is_trivially_constructible(_Ty);


template <class _Ty>
struct is_trivially_move_constructible : bool_constant<__is_trivially_constructible(_Ty, _Ty)> {
    
};

template <class _Ty>
 constexpr bool is_trivially_move_constructible_v = __is_trivially_constructible(_Ty, _Ty);


template <class _To, class _From>
struct is_trivially_assignable : bool_constant<__is_trivially_assignable(_To, _From)> {
    
};

template <class _To, class _From>
 constexpr bool is_trivially_assignable_v = __is_trivially_assignable(_To, _From);


template <class _Ty>
struct is_trivially_copy_assignable
    : bool_constant<__is_trivially_assignable(add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<const _Ty>)> {
    
};

template <class _Ty>
 constexpr bool is_trivially_copy_assignable_v = __is_trivially_assignable(
    add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<const _Ty>);


template <class _Ty>
struct is_trivially_move_assignable : bool_constant<__is_trivially_assignable(add_lvalue_reference_t<_Ty>, _Ty)> {
    
};

template <class _Ty>
 constexpr bool is_trivially_move_assignable_v = __is_trivially_assignable(add_lvalue_reference_t<_Ty>, _Ty);


template <class _Ty>
struct is_trivially_destructible : bool_constant<__is_trivially_destructible(_Ty)> {
    
};

template <class _Ty>
 constexpr bool is_trivially_destructible_v = __is_trivially_destructible(_Ty);



template <class _Ty, class... _Args>
struct is_nothrow_constructible : bool_constant<__is_nothrow_constructible(_Ty, _Args...)> {
    
};

template <class _Ty, class... _Args>
 constexpr bool is_nothrow_constructible_v = __is_nothrow_constructible(_Ty, _Args...);


template <class _Ty>
struct is_nothrow_copy_constructible
    : bool_constant<__is_nothrow_constructible(_Ty, add_lvalue_reference_t<const _Ty>)> {
    
    
};

template <class _Ty>
 constexpr bool is_nothrow_copy_constructible_v = __is_nothrow_constructible(
    _Ty, add_lvalue_reference_t<const _Ty>);


template <class _Ty>
struct is_nothrow_default_constructible : bool_constant<__is_nothrow_constructible(_Ty)> {
    
};

template <class _Ty>
 constexpr bool is_nothrow_default_constructible_v = __is_nothrow_constructible(_Ty);


template <class _Ty>
struct is_nothrow_move_constructible : bool_constant<__is_nothrow_constructible(_Ty, _Ty)> {
    
};

template <class _Ty>
 constexpr bool is_nothrow_move_constructible_v = __is_nothrow_constructible(_Ty, _Ty);


template <class _To, class _From>
struct is_nothrow_assignable : bool_constant<__is_nothrow_assignable(_To, _From)> {
    
};

template <class _To, class _From>
 constexpr bool is_nothrow_assignable_v = __is_nothrow_assignable(_To, _From);


template <class _Ty>
struct is_nothrow_copy_assignable
    : bool_constant<__is_nothrow_assignable(add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<const _Ty>)> {
    
};

template <class _Ty>
 constexpr bool is_nothrow_copy_assignable_v = __is_nothrow_assignable(
    add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<const _Ty>);


template <class _Ty>
struct is_nothrow_move_assignable : bool_constant<__is_nothrow_assignable(add_lvalue_reference_t<_Ty>, _Ty)> {
    
};

template <class _Ty>
 constexpr bool is_nothrow_move_assignable_v = __is_nothrow_assignable(add_lvalue_reference_t<_Ty>, _Ty);


template <class _Ty>
struct is_nothrow_destructible : bool_constant<__is_nothrow_destructible(_Ty)> {
    
    
};

template <class _Ty>
 constexpr bool is_nothrow_destructible_v = __is_nothrow_destructible(_Ty);


template <class _Ty, bool = is_integral_v<_Ty>>
struct _Sign_base { 
    using _Uty = remove_cv_t<_Ty>;

    static constexpr bool _Signed   = _Uty(-1) < _Uty(0);
    static constexpr bool _Unsigned = !_Signed;
};

template <class _Ty>
struct _Sign_base<_Ty, false> { 
                                
    static constexpr bool _Signed   = is_floating_point_v<_Ty>;
    static constexpr bool _Unsigned = false;
};

template <class _Ty>
struct is_signed : bool_constant<_Sign_base<_Ty>::_Signed> {}; 

template <class _Ty>
 constexpr bool is_signed_v = _Sign_base<_Ty>::_Signed;


template <class _Ty>
struct is_unsigned : bool_constant<_Sign_base<_Ty>::_Unsigned> {}; 

template <class _Ty>
 constexpr bool is_unsigned_v = _Sign_base<_Ty>::_Unsigned;


template <class _Ty>
 constexpr bool _Is_nonbool_integral = is_integral_v<_Ty> && !is_same_v<remove_cv_t<_Ty>, bool>;


template <bool>
struct _Select { 
    template <class _Ty1, class>
    using _Apply = _Ty1;
};

template <>
struct _Select<false> {
    template <class, class _Ty2>
    using _Apply = _Ty2;
};

template <size_t>
struct _Make_signed2; 

template <>
struct _Make_signed2<1> {
    template <class>
    using _Apply = signed char;
};

template <>
struct _Make_signed2<2> {
    template <class>
    using _Apply = short;
};

template <>
struct _Make_signed2<4> {
    template <class _Ty>
    using _Apply = 
        typename _Select<is_same_v<_Ty, long> || is_same_v<_Ty, unsigned long>>::template _Apply<long, int>;
};

template <>
struct _Make_signed2<8> {
    template <class>
    using _Apply = long long;
};

template <class _Ty>
using _Make_signed1 = 
    typename _Make_signed2<sizeof(_Ty)>::template _Apply<_Ty>;

template <class _Ty>
struct make_signed { 
    static_assert(_Is_nonbool_integral<_Ty> || is_enum_v<_Ty>,
        "make_signed<T> requires that T shall be a (possibly cv-qualified) "
        "integral type or enumeration but not a bool type.");

    using type = typename remove_cv<_Ty>::template _Apply<_Make_signed1>;
};

template <class _Ty>
using make_signed_t = typename make_signed<_Ty>::type;


template <size_t>
struct _Make_unsigned2; 

template <>
struct _Make_unsigned2<1> {
    template <class>
    using _Apply = unsigned char;
};

template <>
struct _Make_unsigned2<2> {
    template <class>
    using _Apply = unsigned short;
};

template <>
struct _Make_unsigned2<4> {
    template <class _Ty>
    using _Apply = 
        typename _Select<is_same_v<_Ty, long> || is_same_v<_Ty, unsigned long>>::template _Apply<unsigned long,
            unsigned int>;
};

template <>
struct _Make_unsigned2<8> {
    template <class>
    using _Apply = unsigned long long;
};

template <class _Ty>
using _Make_unsigned1 = 
    typename _Make_unsigned2<sizeof(_Ty)>::template _Apply<_Ty>;

template <class _Ty>
struct make_unsigned { 
    static_assert(_Is_nonbool_integral<_Ty> || is_enum_v<_Ty>,
        "make_unsigned<T> requires that T shall be a (possibly cv-qualified) "
        "integral type or enumeration but not a bool type.");

    using type = typename remove_cv<_Ty>::template _Apply<_Make_unsigned1>;
};

template <class _Ty>
using make_unsigned_t = typename make_unsigned<_Ty>::type;


template <class _Rep>
constexpr make_unsigned_t<_Rep> _Unsigned_value(_Rep _Val) { 
    return static_cast<make_unsigned_t<_Rep>>(_Val);
}


template <class _Ty>
struct alignment_of : integral_constant<size_t, alignof(_Ty)> {}; 

template <class _Ty>
 constexpr size_t alignment_of_v = alignof(_Ty);





template <class _Ty, size_t _Len>
union _Align_type { 
    _Ty _Val;
    char _Pad[_Len];
};

template <size_t _Len, size_t _Align, class _Ty, bool _Ok>
struct _Aligned; 

template <size_t _Len, size_t _Align, class _Ty>
struct _Aligned<_Len, _Align, _Ty, true> {
    using type = _Align_type<_Ty, _Len>;
};

template <size_t _Len, size_t _Align>
struct _Aligned<_Len, _Align, double, false> {






    static_assert(_Always_false<_Aligned>,
        "You've instantiated std::aligned_storage<Len, Align> with an extended alignment (in other "
        "words, Align > alignof(max_align_t)). Before VS 2017 15.8, the member \"type\" would "
        "non-conformingly have an alignment of only alignof(max_align_t). VS 2017 15.8 was fixed to "
        "handle this correctly, but the fix inherently changes layout and breaks binary compatibility "
        "(*only* for uses of aligned_storage with extended alignments). "
        "Please define either "
        "(1) _ENABLE_EXTENDED_ALIGNED_STORAGE to acknowledge that you understand this message and "
        "that you actually want a type with an extended alignment, or "
        "(2) _DISABLE_EXTENDED_ALIGNED_STORAGE to silence this message and get the old non-conforming "
        "behavior.");
#line 1073 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\type_traits"
    using type = _Align_type<max_align_t, _Len>;
#line 1075 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\type_traits"
};

template <size_t _Len, size_t _Align>
struct _Aligned<_Len, _Align, int, false> {
    using type = typename _Aligned<_Len, _Align, double, _Align <= alignof(double)>::type;
};

template <size_t _Len, size_t _Align>
struct _Aligned<_Len, _Align, short, false> {
    using type = typename _Aligned<_Len, _Align, int, _Align <= alignof(int)>::type;
};

template <size_t _Len, size_t _Align>
struct _Aligned<_Len, _Align, char, false> {
    using type = typename _Aligned<_Len, _Align, short, _Align <= alignof(short)>::type;
};

template <size_t _Len, size_t _Align = alignof(max_align_t)>
struct aligned_storage { 
    using type = typename _Aligned<_Len, _Align, char, _Align <= alignof(char)>::type;
};




template <size_t _Len, size_t _Align = alignof(max_align_t)>
using aligned_storage_t = typename aligned_storage<_Len, _Align>::type;


template <size_t... _Vals>
struct _Maximum;

template <>
struct _Maximum<> : integral_constant<size_t, 0> {}; 

template <size_t _Val>
struct _Maximum<_Val> : integral_constant<size_t, _Val> {}; 

template <size_t _First, size_t _Second, size_t... _Rest>
struct _Maximum<_First, _Second, _Rest...> : _Maximum<(_First < _Second ? _Second : _First), _Rest...>::type {
    
};

template <size_t _Len, class... _Types>
struct aligned_union { 
    static constexpr size_t _Max_len        = _Maximum<_Len, sizeof(_Types)...>::value; 
    static constexpr size_t alignment_value = _Maximum<alignof(_Types)...>::value;

    using type = aligned_storage_t<_Max_len, alignment_value>;
};

template <size_t _Len, class... _Types>
using aligned_union_t = typename aligned_union<_Len, _Types...>::type;


template <class _Ty>
struct underlying_type { 
    using type = __underlying_type(_Ty);
};

template <class _Ty>
using underlying_type_t = typename underlying_type<_Ty>::type;


template <class _Ty>
 constexpr size_t rank_v = 0; 

template <class _Ty, size_t _Nx>
 constexpr size_t rank_v<_Ty[_Nx]> = rank_v<_Ty> + 1;

template <class _Ty>
 constexpr size_t rank_v<_Ty[]> = rank_v<_Ty> + 1;

template <class _Ty>
struct rank : integral_constant<size_t, rank_v<_Ty>> {};


template <class _Ty, unsigned int _Ix = 0>
 constexpr size_t extent_v = 0; 

template <class _Ty, size_t _Nx>
 constexpr size_t extent_v<_Ty[_Nx], 0> = _Nx;

template <class _Ty, unsigned int _Ix, size_t _Nx>
 constexpr size_t extent_v<_Ty[_Nx], _Ix> = extent_v<_Ty, _Ix - 1>;

template <class _Ty, unsigned int _Ix>
 constexpr size_t extent_v<_Ty[], _Ix> = extent_v<_Ty, _Ix - 1>;

template <class _Ty, unsigned int _Ix = 0>
struct extent : integral_constant<size_t, extent_v<_Ty, _Ix>> {};


template <class _Base, class _Derived>
struct is_base_of : bool_constant<__is_base_of(_Base, _Derived)> {
    
};

template <class _Base, class _Derived>
 constexpr bool is_base_of_v = __is_base_of(_Base, _Derived);


template <class _Ty>
struct decay { 
    using _Ty1 = remove_reference_t<_Ty>;
    using _Ty2 = typename _Select<is_function_v<_Ty1>>::template _Apply<add_pointer<_Ty1>, remove_cv<_Ty1>>;
    using type = typename _Select<is_array_v<_Ty1>>::template _Apply<add_pointer<remove_extent_t<_Ty1>>, _Ty2>::type;
};

template <class _Ty>
using decay_t = typename decay<_Ty>::type;


template <class _Ty1, class _Ty2>
using _Conditional_type = decltype(false ? ::std:: declval<_Ty1>() : ::std:: declval<_Ty2>());














#line 1205 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\type_traits"
template <class _Ty1, class _Ty2, class = void>
struct _Decayed_cond_oper {};
#line 1208 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\type_traits"

template <class _Ty1, class _Ty2>
struct _Decayed_cond_oper<_Ty1, _Ty2, void_t<_Conditional_type<_Ty1, _Ty2>>> {
    using type = decay_t<_Conditional_type<_Ty1, _Ty2>>;
};

template <class... _Ty>
struct common_type;

template <class... _Ty>
using common_type_t = typename common_type<_Ty...>::type;

template <>
struct common_type<> {};

template <class _Ty1>
struct common_type<_Ty1> : common_type<_Ty1, _Ty1> {};

template <class _Ty1, class _Ty2, class _Decayed1 = decay_t<_Ty1>, class _Decayed2 = decay_t<_Ty2>>
struct _Common_type2 : common_type<_Decayed1, _Decayed2> {};

template <class _Ty1, class _Ty2>
struct _Common_type2<_Ty1, _Ty2, _Ty1, _Ty2> : _Decayed_cond_oper<_Ty1, _Ty2> {};

template <class _Ty1, class _Ty2>
struct common_type<_Ty1, _Ty2> : _Common_type2<_Ty1, _Ty2> {};

template <class _Void, class _Ty1, class _Ty2, class... _Rest>
struct _Common_type3 {};

template <class _Ty1, class _Ty2, class... _Rest>
struct _Common_type3<void_t<common_type_t<_Ty1, _Ty2>>, _Ty1, _Ty2, _Rest...>
    : common_type<common_type_t<_Ty1, _Ty2>, _Rest...> {};

template <class _Ty1, class _Ty2, class... _Rest>
struct common_type<_Ty1, _Ty2, _Rest...> : _Common_type3<void, _Ty1, _Ty2, _Rest...> {};






















































































































































#line 1395 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\type_traits"


template <class _Ty>
struct _Identity {
    using type = _Ty;
};
template <class _Ty>
using _Identity_t = typename _Identity<_Ty>::type;









#line 1413 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\type_traits"


template <class _Type, template <class...> class _Template>
 constexpr bool _Is_specialization_v = false; 
template <template <class...> class _Template, class... _Types>
 constexpr bool _Is_specialization_v<_Template<_Types...>, _Template> = true;

template <class _Type, template <class...> class _Template>
struct _Is_specialization : bool_constant<_Is_specialization_v<_Type, _Template>> {};


template <class _Ty>
[[nodiscard]] constexpr _Ty&& forward(
    remove_reference_t<_Ty>& _Arg) noexcept { 
    return static_cast<_Ty&&>(_Arg);
}

template <class _Ty>
[[nodiscard]] constexpr _Ty&& forward(remove_reference_t<_Ty>&& _Arg) noexcept { 
    static_assert(!is_lvalue_reference_v<_Ty>, "bad forward call");
    return static_cast<_Ty&&>(_Arg);
}


template <class _Ty>
[[nodiscard]] constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept { 
    return static_cast<remove_reference_t<_Ty>&&>(_Arg);
}


template <class _Ty>
[[nodiscard]] constexpr conditional_t<!is_nothrow_move_constructible_v<_Ty> && is_copy_constructible_v<_Ty>, const _Ty&,
    _Ty&&>
    move_if_noexcept(_Ty& _Arg) noexcept { 
    return ::std:: move(_Arg);
}

template <class _Ty>
class reference_wrapper;































































































































struct _Invoker_pmf_object { template <class _Decayed, class _Ty1, class... _Types2> static inline auto _Call(_Decayed _Pmf, _Ty1&& _Arg1, _Types2&&... _Args2) noexcept( noexcept((::std:: forward<_Ty1>(_Arg1).*_Pmf)(::std:: forward<_Types2>(_Args2)...))) -> decltype((::std:: forward<_Ty1>(_Arg1).*_Pmf)( ::std:: forward<_Types2>(_Args2)...)) { return (::std:: forward<_Ty1>(_Arg1).*_Pmf)(::std:: forward<_Types2>(_Args2)...); } }; struct _Invoker_pmf_refwrap { template <class _Decayed, class _Ty1, class... _Types2> static inline auto _Call(_Decayed _Pmf, _Ty1&& _Arg1, _Types2&&... _Args2) noexcept( noexcept((::std:: forward<_Ty1>(_Arg1).get().*_Pmf)(::std:: forward<_Types2>(_Args2)...))) -> decltype((::std:: forward<_Ty1>(_Arg1).get().*_Pmf)( ::std:: forward<_Types2>(_Args2)...)) { return (::std:: forward<_Ty1>(_Arg1).get().*_Pmf)(::std:: forward<_Types2>(_Args2)...); } }; struct _Invoker_pmf_pointer { template <class _Decayed, class _Ty1, class... _Types2> static inline auto _Call(_Decayed _Pmf, _Ty1&& _Arg1, _Types2&&... _Args2) noexcept( noexcept(((*::std:: forward<_Ty1>(_Arg1)).*_Pmf)(::std:: forward<_Types2>(_Args2)...))) -> decltype(((*::std:: forward<_Ty1>(_Arg1)).*_Pmf)( ::std:: forward<_Types2>(_Args2)...)) { return ((*::std:: forward<_Ty1>(_Arg1)).*_Pmf)(::std:: forward<_Types2>(_Args2)...); } }; struct _Invoker_pmd_object { template <class _Decayed, class _Ty1> static inline auto _Call(_Decayed _Pmd, _Ty1&& _Arg1) noexcept(noexcept(::std:: forward<_Ty1>(_Arg1).*_Pmd)) -> decltype(::std:: forward<_Ty1>(_Arg1).*_Pmd) { return ::std:: forward<_Ty1>(_Arg1).*_Pmd; } }; struct _Invoker_pmd_refwrap { template <class _Decayed, class _Ty1> static inline auto _Call(_Decayed _Pmd, _Ty1&& _Arg1) noexcept( noexcept(::std:: forward<_Ty1>(_Arg1).get().*_Pmd)) -> decltype( ::std:: forward<_Ty1>(_Arg1).get().*_Pmd) { return ::std:: forward<_Ty1>(_Arg1).get().*_Pmd; } }; struct _Invoker_pmd_pointer { template <class _Decayed, class _Ty1> static inline auto _Call(_Decayed _Pmd, _Ty1&& _Arg1) noexcept( noexcept((*::std:: forward<_Ty1>(_Arg1)).*_Pmd)) -> decltype( (*::std:: forward<_Ty1>(_Arg1)).*_Pmd) { return (*::std:: forward<_Ty1>(_Arg1)).*_Pmd; } }; struct _Invoker_functor { template <class _Callable, class... _Types> static inline auto _Call(_Callable&& _Obj, _Types&&... _Args) noexcept( noexcept(::std:: forward<_Callable>(_Obj)(::std:: forward<_Types>(_Args)...))) -> decltype( ::std:: forward<_Callable>(_Obj)(::std:: forward<_Types>(_Args)...)) { return ::std:: forward<_Callable>(_Obj)(::std:: forward<_Types>(_Args)...); } }; template <class _Callable, class _Ty1, class _Removed_cvref = _Remove_cvref_t<_Callable>, bool _Is_pmf = is_member_function_pointer_v<_Removed_cvref>, bool _Is_pmd = is_member_object_pointer_v<_Removed_cvref>> struct _Invoker1; template <class _Callable, class _Ty1, class _Removed_cvref> struct _Invoker1<_Callable, _Ty1, _Removed_cvref, true, false> : conditional_t<is_base_of_v<typename _Is_memfunptr<_Removed_cvref>::_Class_type, remove_reference_t<_Ty1>>, _Invoker_pmf_object, conditional_t<_Is_specialization_v<_Remove_cvref_t<_Ty1>, reference_wrapper>, _Invoker_pmf_refwrap, _Invoker_pmf_pointer>> { }; template <class _Callable, class _Ty1, class _Removed_cvref> struct _Invoker1<_Callable, _Ty1, _Removed_cvref, false, true> : conditional_t< is_base_of_v<typename _Is_member_object_pointer<_Removed_cvref>::_Class_type, remove_reference_t<_Ty1>>, _Invoker_pmd_object, conditional_t<_Is_specialization_v<_Remove_cvref_t<_Ty1>, reference_wrapper>, _Invoker_pmd_refwrap, _Invoker_pmd_pointer>> { }; template <class _Callable, class _Ty1, class _Removed_cvref> struct _Invoker1<_Callable, _Ty1, _Removed_cvref, false, false> : _Invoker_functor { }; template <class _Callable, class... _Types> struct _Invoker; template <class _Callable> struct _Invoker<_Callable> : _Invoker_functor { }; template <class _Callable, class _Ty1, class... _Types2> struct _Invoker<_Callable, _Ty1, _Types2...> : _Invoker1<_Callable, _Ty1> { }; template <class _Callable, class... _Types> inline auto invoke(_Callable && _Obj, _Types && ... _Args) noexcept( noexcept(_Invoker < _Callable, _Types... > ::_Call(::std:: forward<_Callable>(_Obj), ::std:: forward<_Types>(_Args)...))) ->decltype(_Invoker < _Callable, _Types... > ::_Call( ::std:: forward<_Callable>(_Obj), ::std:: forward<_Types>(_Args)...)) { return _Invoker<_Callable, _Types...>::_Call( ::std:: forward<_Callable>(_Obj), ::std:: forward<_Types>(_Args)...); }




#line 1585 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\type_traits"



template <class _Rx, bool = is_void_v<_Rx>>
struct _Invoker_ret {}; 

struct _Unforced {}; 

template <class _Cv_void>
struct _Invoker_ret<_Cv_void, true> { 
    template <class... _Valtys>
    static void _Call(_Valtys&&... _Vals) { 
        ::std:: invoke(::std:: forward<_Valtys>(_Vals)...);
    }
};

template <class _Rx>
struct _Invoker_ret<_Rx, false> { 
    template <class... _Valtys>
    static _Rx _Call(_Valtys&&... _Vals) { 
        return ::std:: invoke(::std:: forward<_Valtys>(_Vals)...);
    }
};

template <>
struct _Invoker_ret<_Unforced, false> { 
    template <class... _Valtys>
    static auto _Call(_Valtys&&... _Vals)
        -> decltype(::std:: invoke(::std:: forward<_Valtys>(_Vals)...)) { 
        return ::std:: invoke(::std:: forward<_Valtys>(_Vals)...);
    }
};



template <class _To>
void _Implicitly_convert_to(_To) noexcept; 

#pragma warning(push)
#pragma warning(disable : 4242) 
#pragma warning(disable : 4244) 
#pragma warning(disable : 4365) 
template <class _From, class _To, bool = is_convertible_v<_From, _To>, bool = is_void_v<_To>>
 constexpr bool _Is_nothrow_convertible_v = noexcept(_Implicitly_convert_to<_To>(::std:: declval<_From>()));
#pragma warning(pop)
template <class _From, class _To, bool _IsVoid>
 constexpr bool _Is_nothrow_convertible_v<_From, _To, false, _IsVoid> = false;

template <class _From, class _To>
 constexpr bool _Is_nothrow_convertible_v<_From, _To, true, true> = true;

template <class _From, class _To>
struct _Is_nothrow_convertible : bool_constant<_Is_nothrow_convertible_v<_From, _To>> {
    
};







#line 1648 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\type_traits"

template <class _Void, class... _Types>
struct _Invoke_traits { 
    using _Is_invocable         = false_type;
    using _Is_nothrow_invocable = false_type;
    template <class _Rx>
    using _Is_invocable_r = false_type;
    template <class _Rx>
    using _Is_nothrow_invocable_r = false_type;
};

template <class... _Types>
struct _Invoke_traits<void_t<decltype(::std:: invoke(::std:: declval<_Types>()...))>,
    _Types...> { 
    using type                  = decltype(::std:: invoke(::std:: declval<_Types>()...));
    using _Is_invocable         = true_type;
    using _Is_nothrow_invocable = bool_constant<noexcept(::std:: invoke(::std:: declval<_Types>()...))>;
    template <class _Rx>
    using _Is_invocable_r = bool_constant<disjunction_v<is_void<_Rx>, is_convertible<type, _Rx>>>;
    template <class _Rx>
    using _Is_nothrow_invocable_r = bool_constant<
        conjunction_v<_Is_nothrow_invocable, disjunction<is_void<_Rx>, _Is_nothrow_convertible<type, _Rx>>>>;
};


template <class _Fty>
struct  result_of { 
    static_assert(_Always_false<_Fty>, "result_of<CallableType> is invalid; use "
                                       "result_of<CallableType(zero or more argument types)> instead.");
};







template <class _Callable, class... _Args> struct  result_of<_Callable __cdecl(_Args...)> : _Invoke_traits<void, _Callable, _Args...> { };    template <class _Callable, class... _Args> struct  result_of<_Callable __vectorcall(_Args...)> : _Invoke_traits<void, _Callable, _Args...> { };


__pragma(warning(push)) __pragma(warning(disable : 4996))
template <class _Ty>
using result_of_t  = typename result_of<_Ty>::type;
__pragma(warning(pop))

template <class _Callable, class... _Args>
using _Invoke_result_t = typename _Invoke_traits<void, _Callable, _Args...>::type;

template <class _Rx, class _Callable, class... _Args>
using _Is_invocable_r_ = typename _Invoke_traits<void, _Callable, _Args...>::template _Is_invocable_r<_Rx>;

template <class _Rx, class _Callable, class... _Args>
struct _Is_invocable_r : _Is_invocable_r_<_Rx, _Callable, _Args...> {
    
};















































#line 1751 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\type_traits"



template <class _Ty, class = void>
struct _Weak_result_type {}; 

__pragma(warning(push)) __pragma(warning(disable : 4996))
template <class _Ty>
struct _Weak_result_type<_Ty, void_t<typename _Ty::result_type>> { 
     typedef typename _Ty::result_type result_type;
};
__pragma(warning(pop))

template <class _Ty, class = void>
struct _Weak_argument_type : _Weak_result_type<_Ty> {}; 

__pragma(warning(push)) __pragma(warning(disable : 4996))
template <class _Ty>
struct _Weak_argument_type<_Ty, void_t<typename _Ty::argument_type>>
    : _Weak_result_type<_Ty> { 
     typedef typename _Ty::argument_type argument_type;
};
__pragma(warning(pop))

template <class _Ty, class = void>
struct _Weak_binary_args : _Weak_argument_type<_Ty> {}; 

__pragma(warning(push)) __pragma(warning(disable : 4996))
template <class _Ty>
struct _Weak_binary_args<_Ty, void_t<typename _Ty::first_argument_type,
                                  typename _Ty::second_argument_type>>
    : _Weak_argument_type<_Ty> { 
     typedef typename _Ty::first_argument_type first_argument_type;
     typedef typename _Ty::second_argument_type second_argument_type;
};
__pragma(warning(pop))

template <class _Ty>
struct _Weak_types { 
    using _Is_f_or_pf = _Is_function<remove_pointer_t<_Ty>>;
    using _Is_pmf     = _Is_memfunptr<remove_cv_t<_Ty>>;
    using type        = conditional_t<is_function_v<remove_pointer_t<_Ty>>, _Is_f_or_pf,
        conditional_t<is_member_function_pointer_v<_Ty>, _Is_pmf, _Weak_binary_args<_Ty>>>;
};


template <class _Ty>
void _Refwrap_ctor_fun(_Identity_t<_Ty&>) noexcept;
template <class _Ty>
void _Refwrap_ctor_fun(_Identity_t<_Ty&&>) = delete;

template <class _Ty, class _Uty, class = void>
struct _Refwrap_has_ctor_from : false_type {};

template <class _Ty, class _Uty>
struct _Refwrap_has_ctor_from<_Ty, _Uty, void_t<decltype(_Refwrap_ctor_fun<_Ty>(::std:: declval<_Uty>()))>> : true_type {};

template <class _Ty>
class reference_wrapper : public _Weak_types<_Ty>::type { 
public:
    static_assert(is_object_v<_Ty> || is_function_v<_Ty>,
        "reference_wrapper<T> requires T to be an object type or a function type.");

    using type = _Ty;

    template <class _Uty, enable_if_t<conjunction_v<negation<is_same<_Remove_cvref_t<_Uty>, reference_wrapper>>,
                                          _Refwrap_has_ctor_from<_Ty, _Uty>>,
                              int> = 0>
    reference_wrapper(_Uty&& _Val) noexcept(noexcept(_Refwrap_ctor_fun<_Ty>(::std:: declval<_Uty>()))) {
        _Ty& _Ref = ::std:: forward<_Uty>(_Val);
        _Ptr      = ::std:: addressof(_Ref);
    }

    operator _Ty&() const noexcept {
        return *_Ptr;
    }

    [[nodiscard]] _Ty& get() const noexcept {
        return *_Ptr;
    }

    template <class... _Types>
    auto operator()(_Types&&... _Args) const -> decltype(::std:: invoke(get(), ::std:: forward<_Types>(_Args)...)) {
        return ::std:: invoke(get(), ::std:: forward<_Types>(_Args)...);
    }

private:
    _Ty* _Ptr;
};




#line 1845 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\type_traits"


template <class _Ty>
[[nodiscard]] reference_wrapper<_Ty> ref(_Ty& _Val) noexcept {
    return reference_wrapper<_Ty>(_Val);
}

template <class _Ty>
void ref(const _Ty&&) = delete;

template <class _Ty>
[[nodiscard]] reference_wrapper<_Ty> ref(reference_wrapper<_Ty> _Val) noexcept {
    return ::std:: ref(_Val.get());
}

template <class _Ty>
[[nodiscard]] reference_wrapper<const _Ty> cref(const _Ty& _Val) noexcept {
    return reference_wrapper<const _Ty>(_Val);
}

template <class _Ty>
void cref(const _Ty&&) = delete;

template <class _Ty>
[[nodiscard]] reference_wrapper<const _Ty> cref(reference_wrapper<_Ty> _Val) noexcept {
    return ::std:: cref(_Val.get());
}





















#line 1894 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\type_traits"


template <class _Ty>
struct _Is_swappable;


template <class _Ty>
struct _Is_nothrow_swappable;




#line 1907 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\type_traits"
template <class _Ty, class = void>
#line 1909 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\type_traits"
void swap(_Ty&, _Ty&) noexcept(is_nothrow_move_constructible_v<_Ty>&& is_nothrow_move_assignable_v<_Ty>);

template <class _Ty, size_t _Size, class = enable_if_t<_Is_swappable<_Ty>::value>>
void swap(_Ty (&)[_Size], _Ty (&)[_Size]) noexcept(_Is_nothrow_swappable<_Ty>::value);


template <class _Ty1, class _Ty2, class = void>
struct _Swappable_with_helper : false_type {}; 

template <class _Ty1, class _Ty2>
struct _Swappable_with_helper<_Ty1, _Ty2, void_t<decltype(swap(::std:: declval<_Ty1>(), ::std:: declval<_Ty2>()))>>
    : true_type {}; 


template <class _Ty1, class _Ty2>
struct _Is_swappable_with
    : bool_constant<conjunction_v<_Swappable_with_helper<_Ty1, _Ty2>, _Swappable_with_helper<_Ty2, _Ty1>>> {
    
};


template <class _Ty>
struct _Is_swappable : _Is_swappable_with<add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<_Ty>>::type {
    
};


template <class _Ty1, class _Ty2>
struct _Swap_cannot_throw : bool_constant<noexcept(swap(::std:: declval<_Ty1>(), ::std:: declval<_Ty2>()))
                                          && noexcept(swap(::std:: declval<_Ty2>(), ::std:: declval<_Ty1>()))> {
    
    
};


template <class _Ty1, class _Ty2>
struct _Is_nothrow_swappable_with
    : bool_constant<conjunction_v<_Is_swappable_with<_Ty1, _Ty2>, _Swap_cannot_throw<_Ty1, _Ty2>>> {
    
    
};


template <class _Ty>
struct _Is_nothrow_swappable
    : _Is_nothrow_swappable_with<add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<_Ty>>::type {
    
};






































#line 1996 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\type_traits"


namespace _Has_ADL_swap_detail {
    void swap(); 

    template <class, class = void>
    struct _Has_ADL_swap : false_type {};
    template <class _Ty>
    struct _Has_ADL_swap<_Ty, void_t<decltype(swap(::std:: declval<_Ty&>(), ::std:: declval<_Ty&>()))>> : true_type {};
} 
using _Has_ADL_swap_detail::_Has_ADL_swap;

template <class _Ty>
 constexpr bool _Is_trivially_swappable_v = conjunction_v<is_trivially_destructible<_Ty>,
    is_trivially_move_constructible<_Ty>, is_trivially_move_assignable<_Ty>, negation<_Has_ADL_swap<_Ty>>>;

template <class _Ty>
struct _Is_trivially_swappable : bool_constant<_Is_trivially_swappable_v<_Ty>> {
    
};

















































 constexpr size_t _FNV_offset_basis = 14695981039346656037ULL;
 constexpr size_t _FNV_prime        = 1099511628211ULL;



#line 2071 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\type_traits"

[[nodiscard]] inline size_t _Fnv1a_append_bytes(size_t _Val, const unsigned char* const _First,
    const size_t _Count) noexcept { 
    for (size_t _Idx = 0; _Idx < _Count; ++_Idx) {
        _Val ^= static_cast<size_t>(_First[_Idx]);
        _Val *= _FNV_prime;
    }

    return _Val;
}

template <class _Ty>
[[nodiscard]] size_t _Fnv1a_append_range(const size_t _Val, const _Ty* const _First,
    const _Ty* const _Last) noexcept { 
    static_assert(is_trivial_v<_Ty>, "Only trivial types can be directly hashed.");
    const auto _Firstb = reinterpret_cast<const unsigned char*>(_First);
    const auto _Lastb  = reinterpret_cast<const unsigned char*>(_Last);
    return _Fnv1a_append_bytes(_Val, _Firstb, static_cast<size_t>(_Lastb - _Firstb));
}

template <class _Kty>
[[nodiscard]] size_t _Fnv1a_append_value(
    const size_t _Val, const _Kty& _Keyval) noexcept { 
    static_assert(is_trivial_v<_Kty>, "Only trivial types can be directly hashed.");
    return _Fnv1a_append_bytes(_Val, &reinterpret_cast<const unsigned char&>(_Keyval), sizeof(_Kty));
}


template <class _Kty>
[[nodiscard]] size_t _Hash_representation(const _Kty& _Keyval) noexcept { 
    return _Fnv1a_append_value(_FNV_offset_basis, _Keyval);
}


template <class _Kty>
[[nodiscard]] size_t _Hash_array_representation(
    const _Kty* const _First, const size_t _Count) noexcept { 
    static_assert(is_trivial_v<_Kty>, "Only trivial types can be directly hashed.");
    return _Fnv1a_append_bytes(
        _FNV_offset_basis, reinterpret_cast<const unsigned char*>(_First), _Count * sizeof(_Kty));
}


template <class _Kty>
struct hash;

template <class _Kty, bool _Enabled>
struct _Conditionally_enabled_hash { 
     typedef _Kty argument_type;
     typedef size_t result_type;

    [[nodiscard]] size_t operator()(const _Kty& _Keyval) const
        noexcept(noexcept(hash<_Kty>::_Do_hash(_Keyval)))  {
        return hash<_Kty>::_Do_hash(_Keyval);
    }
};

template <class _Kty>
struct _Conditionally_enabled_hash<_Kty, false> { 
    _Conditionally_enabled_hash()                                   = delete;
    _Conditionally_enabled_hash(const _Conditionally_enabled_hash&) = delete;
    _Conditionally_enabled_hash(_Conditionally_enabled_hash&&)      = delete;
    _Conditionally_enabled_hash& operator=(const _Conditionally_enabled_hash&) = delete;
    _Conditionally_enabled_hash& operator=(_Conditionally_enabled_hash&&) = delete;
};


template <class _Kty>
struct hash
    : _Conditionally_enabled_hash<_Kty,
          !is_const_v<_Kty> && !is_volatile_v<_Kty> && (is_enum_v<_Kty> || is_integral_v<_Kty> || is_pointer_v<_Kty>)> {
    
    static size_t _Do_hash(const _Kty& _Keyval) noexcept {
        return _Hash_representation(_Keyval);
    }
};

template <>
struct hash<float> {
     typedef float argument_type;
     typedef size_t result_type;
    [[nodiscard]] size_t operator()(const float _Keyval) const noexcept {
        return _Hash_representation(_Keyval == 0.0F ? 0.0F : _Keyval); 
    }
};

template <>
struct hash<double> {
     typedef double argument_type;
     typedef size_t result_type;
    [[nodiscard]] size_t operator()(const double _Keyval) const noexcept {
        return _Hash_representation(_Keyval == 0.0 ? 0.0 : _Keyval); 
    }
};

template <>
struct hash<long double> {
     typedef long double argument_type;
     typedef size_t result_type;
    [[nodiscard]] size_t operator()(const long double _Keyval) const noexcept {
        return _Hash_representation(_Keyval == 0.0L ? 0.0L : _Keyval); 
    }
};

template <>
struct hash<nullptr_t> {
     typedef nullptr_t argument_type;
     typedef size_t result_type;
    [[nodiscard]] size_t operator()(nullptr_t) const noexcept {
        void* _Null{};
        return _Hash_representation(_Null);
    }
};


template <class _Kty, class = void>
struct _Is_nothrow_hashable : false_type {}; 

template <class _Kty>
struct _Is_nothrow_hashable<_Kty, void_t<decltype(hash<_Kty>{}(::std:: declval<const _Kty&>()))>>
    : bool_constant<noexcept(hash<_Kty>{}(::std:: declval<const _Kty&>()))> {};


__pragma(warning(push)) __pragma(warning(disable : 4996))
namespace [[deprecated( "warning STL4002: " "The non-Standard std::tr1 namespace and TR1-only machinery are deprecated and will be REMOVED. You can " "define _SILENCE_TR1_NAMESPACE_DEPRECATION_WARNING to acknowledge that you have received this warning.")]] tr1 {
    using ::std:: add_const;
    using ::std:: add_cv;
    using ::std:: add_pointer;
    using ::std:: add_volatile;
    using ::std:: aligned_storage;
    using ::std:: alignment_of;
    using ::std:: conditional;
    using ::std:: decay;
    using ::std:: enable_if;
    using ::std:: extent;
    using ::std:: false_type;
    using ::std:: has_virtual_destructor;
    using ::std:: integral_constant;
    using ::std:: is_abstract;
    using ::std:: is_arithmetic;
    using ::std:: is_array;
    using ::std:: is_base_of;
    using ::std:: is_class;
    using ::std:: is_compound;
    using ::std:: is_const;
    using ::std:: is_convertible;
    using ::std:: is_empty;
    using ::std:: is_enum;
    using ::std:: is_floating_point;
    using ::std:: is_function;
    using ::std:: is_fundamental;
    using ::std:: is_integral;
    using ::std:: is_member_function_pointer;
    using ::std:: is_member_object_pointer;
    using ::std:: is_member_pointer;
    using ::std:: is_object;
    using ::std:: is_pod;
    using ::std:: is_pointer;
    using ::std:: is_polymorphic;
    using ::std:: is_reference;
    using ::std:: is_same;
    using ::std:: is_scalar;
    using ::std:: is_signed;
    using ::std:: is_union;
    using ::std:: is_unsigned;
    using ::std:: is_void;
    using ::std:: is_volatile;
    using ::std:: make_signed;
    using ::std:: make_unsigned;
    using ::std:: rank;
    using ::std:: remove_all_extents;
    using ::std:: remove_const;
    using ::std:: remove_cv;
    using ::std:: remove_extent;
    using ::std:: remove_pointer;
    using ::std:: remove_reference;
    using ::std:: remove_volatile;
    using ::std:: true_type;
    using ::std:: cref;
    using ::std:: ref;
    using ::std:: reference_wrapper;
    using ::std:: result_of;
    using ::std:: hash;
} 
__pragma(warning(pop))
#line 2257 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\type_traits"

}



#pragma warning(pop)
#pragma pack(pop)
#line 2265 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\type_traits"
#line 2266 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\type_traits"
#line 692 "C:\\Projects\\glm\\glm\\detail/setup.hpp"

namespace glm{
namespace detail
{
	using std::make_unsigned;
}
}













































































#line 777 "C:\\Projects\\glm\\glm\\detail/setup.hpp"








#line 786 "C:\\Projects\\glm\\glm\\detail/setup.hpp"










#line 797 "C:\\Projects\\glm\\glm\\detail/setup.hpp"

#line 799 "C:\\Projects\\glm\\glm\\detail/setup.hpp"

#line 801 "C:\\Projects\\glm\\glm\\detail/setup.hpp"






#line 808 "C:\\Projects\\glm\\glm\\detail/setup.hpp"

#line 810 "C:\\Projects\\glm\\glm\\detail/setup.hpp"










#line 821 "C:\\Projects\\glm\\glm\\detail/setup.hpp"














#line 836 "C:\\Projects\\glm\\glm\\detail/setup.hpp"

#line 838 "C:\\Projects\\glm\\glm\\detail/setup.hpp"






#line 845 "C:\\Projects\\glm\\glm\\detail/setup.hpp"

#line 847 "C:\\Projects\\glm\\glm\\detail/setup.hpp"








#line 856 "C:\\Projects\\glm\\glm\\detail/setup.hpp"










#line 867 "C:\\Projects\\glm\\glm\\detail/setup.hpp"

#line 869 "C:\\Projects\\glm\\glm\\detail/setup.hpp"

#line 871 "C:\\Projects\\glm\\glm\\detail/setup.hpp"

#line 873 "C:\\Projects\\glm\\glm\\detail/setup.hpp"



#line 877 "C:\\Projects\\glm\\glm\\detail/setup.hpp"

#line 879 "C:\\Projects\\glm\\glm\\detail/setup.hpp"

#line 881 "C:\\Projects\\glm\\glm\\detail/setup.hpp"

#line 883 "C:\\Projects\\glm\\glm\\detail/setup.hpp"



#line 887 "C:\\Projects\\glm\\glm\\detail/setup.hpp"

#line 889 "C:\\Projects\\glm\\glm\\detail/setup.hpp"

#line 891 "C:\\Projects\\glm\\glm\\detail/setup.hpp"

#line 893 "C:\\Projects\\glm\\glm\\detail/setup.hpp"



#line 897 "C:\\Projects\\glm\\glm\\detail/setup.hpp"

#line 899 "C:\\Projects\\glm\\glm\\detail/setup.hpp"

#line 901 "C:\\Projects\\glm\\glm\\detail/setup.hpp"

#line 903 "C:\\Projects\\glm\\glm\\detail/setup.hpp"



#line 907 "C:\\Projects\\glm\\glm\\detail/setup.hpp"

#line 909 "C:\\Projects\\glm\\glm\\detail/setup.hpp"

#line 911 "C:\\Projects\\glm\\glm\\detail/setup.hpp"

#line 913 "C:\\Projects\\glm\\glm\\detail/setup.hpp"

namespace glm {
	template<length_t L, typename T> struct vec;
	template<length_t C, length_t R, typename T> struct mat;
	template<typename T> struct qua;


	template <typename T> using tvec1 = vec<1, T>;
	template <typename T> using tvec2 = vec<2, T>;
	template <typename T> using tvec3 = vec<3, T>;
	template <typename T> using tvec4 = vec<4, T>;
	template <typename T> using tmat2x2 = mat<2, 2, T>;
	template <typename T> using tmat2x3 = mat<2, 3, T>;
	template <typename T> using tmat2x4 = mat<2, 4, T>;
	template <typename T> using tmat3x2 = mat<3, 2, T>;
	template <typename T> using tmat3x3 = mat<3, 3, T>;
	template <typename T> using tmat3x4 = mat<3, 4, T>;
	template <typename T> using tmat4x2 = mat<4, 2, T>;
	template <typename T> using tmat4x3 = mat<4, 3, T>;
	template <typename T> using tmat4x4 = mat<4, 4, T>;
	template <typename T> using tquat = qua<T>;
#line 935 "C:\\Projects\\glm\\glm\\detail/setup.hpp"
	namespace detail
	{
		enum genTypeEnum
		{
			GENTYPE_VEC,
			GENTYPE_MAT,
			GENTYPE_QUAT
		};

		template <typename genType>
		struct genTypeTrait
		{};

		template <length_t C, length_t R, typename T>
		struct genTypeTrait<mat<C, R, T> >
		{
			static const genTypeEnum GENTYPE = GENTYPE_MAT;
		};

		template<typename genType, genTypeEnum type>
		struct init_gentype
		{
		};

		template<typename genType>
		struct init_gentype<genType, GENTYPE_QUAT>
		{
			 inline constexpr static genType identity()
			{
				return genType(1, 0, 0, 0);
			}
		};

		template<typename genType>
		struct init_gentype<genType, GENTYPE_MAT>
		{
			 inline constexpr static genType identity()
			{
				return genType(1);
			}
		};
	}
}































































































































































































































#line 1202 "C:\\Projects\\glm\\glm\\detail/setup.hpp"
#line 4 ".\\glm_impl.cpp"
#line 1 "C:\\Projects\\glm\\glm\\vec2.hpp"



#pragma once
#line 1 "C:\\Projects\\glm\\glm\\./ext/vector_bool2.hpp"



#pragma once
#line 1 "C:\\Projects\\glm\\glm\\ext\\../detail/type_vec2.hpp"



#pragma once



#line 9 "C:\\Projects\\glm\\glm\\ext\\../detail/type_vec2.hpp"

#line 11 "C:\\Projects\\glm\\glm\\ext\\../detail/type_vec2.hpp"


namespace glm
{
	template<typename T>
	struct vec<2, T>
	{
		

		typedef T value_type;
		typedef vec<2, T> type;
		typedef vec<2, bool> bool_type;

		













#line 39 "C:\\Projects\\glm\\glm\\ext\\../detail/type_vec2.hpp"



#line 43 "C:\\Projects\\glm\\glm\\ext\\../detail/type_vec2.hpp"




















#line 64 "C:\\Projects\\glm\\glm\\ext\\../detail/type_vec2.hpp"
			union {T x, r, s;};
			union {T y, g, t;};



#line 70 "C:\\Projects\\glm\\glm\\ext\\../detail/type_vec2.hpp"
#line 71 "C:\\Projects\\glm\\glm\\ext\\../detail/type_vec2.hpp"









#line 81 "C:\\Projects\\glm\\glm\\ext\\../detail/type_vec2.hpp"

		

		
		typedef length_t length_type;
		 static constexpr length_type length(){return 2;}

		 constexpr T& operator[](length_type i);
		 constexpr T const& operator[](length_type i) const;

		

		 constexpr vec() = default;
		 constexpr vec(vec const& v) = default;

		

		 constexpr explicit vec(T scalar);
		 constexpr vec(T x, T y);

		

		
		template<typename U>
		 constexpr  vec(vec<3, U> const& v);
		
		template<typename U>
		 constexpr  vec(vec<4, U> const& v);

		
		template<typename U>
		 constexpr  vec(vec<2, U> const& v);

		






#line 122 "C:\\Projects\\glm\\glm\\ext\\../detail/type_vec2.hpp"

		

		 constexpr vec<2, T> & operator=(vec const& v) = default;
		 constexpr vec<2, T> & operator+=(T scalar);
		 constexpr vec<2, T> & operator+=(vec const& v);
		 constexpr vec<2, T> & operator-=(T scalar);
		 constexpr vec<2, T> & operator-=(vec const& v);
		 constexpr vec<2, T> & operator*=(T scalar);
		 constexpr vec<2, T> & operator*=(vec const& v);
		 constexpr vec<2, T> & operator/=(T scalar);
		 constexpr vec<2, T> & operator/=(vec const& v);
	};

	

	template<typename T>
	 constexpr vec<2, T> operator+(vec<2, T> const& v);

	template<typename T>
	 constexpr vec<2, T> operator-(vec<2, T> const& v);

	

	template<typename T>
	 constexpr vec<2, T> operator+(vec<2, T> const& v, T scalar);

	template<typename T>
	 constexpr vec<2, T> operator+(T scalar, vec<2, T> const& v);

	template<typename T>
	 constexpr vec<2, T> operator+(vec<2, T> const& v1, vec<2, T> const& v2);

	template<typename T>
	 constexpr vec<2, T> operator-(vec<2, T> const& v, T scalar);

	template<typename T>
	 constexpr vec<2, T> operator-(T scalar, vec<2, T> const& v);

	template<typename T>
	 constexpr vec<2, T> operator-(vec<2, T> const& v1, vec<2, T> const& v2);

	template<typename T>
	 constexpr vec<2, T> operator*(vec<2, T> const& v, T scalar);

	template<typename T>
	 constexpr vec<2, T> operator*(T scalar, vec<2, T> const& v);

	template<typename T>
	 constexpr vec<2, T> operator*(vec<2, T> const& v1, vec<2, T> const& v2);

	template<typename T>
	 constexpr vec<2, T> operator/(vec<2, T> const& v, T scalar);

	template<typename T>
	 constexpr vec<2, T> operator/(T scalar, vec<2, T> const& v);

	template<typename T>
	 constexpr vec<2, T> operator/(vec<2, T> const& v1, vec<2, T> const& v2);

	

	template<typename T>
	 constexpr bool operator==(vec<2, T> const& v1, vec<2, T> const& v2);

	template<typename T>
	 constexpr bool operator!=(vec<2, T> const& v1, vec<2, T> const& v2);

	 constexpr vec<2, bool> operator&&(vec<2, bool> const& v1, vec<2, bool> const& v2);
	 constexpr vec<2, bool> operator||(vec<2, bool> const& v1, vec<2, bool> const& v2);
}


#line 1 "C:\\Projects\\glm\\glm\\detail\\type_vec2.inl"


#line 1 "C:\\Projects\\glm\\glm\\detail\\./compute_vector_relational.hpp"
#pragma once



#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\limits"





#pragma once




#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\cfloat"





#pragma once




#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\float.h"








#pragma once





__pragma(pack(push, 8)) extern "C" {




    


        


            
        #line 28 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\float.h"
    #line 29 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\float.h"
#line 30 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\float.h"



















    






        
    #line 58 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\float.h"
#line 59 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\float.h"
























































































































































#line 212 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\float.h"

    

#line 216 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\float.h"











 unsigned int __cdecl _clearfp(void);

#pragma warning(push)
#pragma warning(disable: 4141)

 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_controlfp_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
 unsigned int __cdecl _controlfp(
      unsigned int _NewValue,
      unsigned int _Mask
    );

#pragma warning(pop)


 void __cdecl _set_controlfp(
      unsigned int _NewValue,
      unsigned int _Mask
    );


 errno_t __cdecl _controlfp_s(
      unsigned int* _CurrentState,
           unsigned int  _NewValue,
           unsigned int  _Mask
    );


 unsigned int __cdecl _statusfp(void);


 void __cdecl _fpreset(void);















 unsigned int __cdecl _control87(
      unsigned int _NewValue,
      unsigned int _Mask
    );












 
 int* __cdecl __fpecode(void);



 
 int __cdecl __fpe_flt_rounds(void);












   double __cdecl _copysign(  double _Number,   double _Sign);
   double __cdecl _chgsign(  double _X);
   double __cdecl _scalb(  double _X,   long _Y);
   double __cdecl _logb(  double _X);
   double __cdecl _nextafter(  double _X,   double _Y);
   int    __cdecl _finite(  double _X);
   int    __cdecl _isnan(  double _X);
   int    __cdecl _fpclass(  double _X);


       float __cdecl _scalbf(  float _X,   long _Y);
#line 320 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\float.h"










    
    
    

    
     void __cdecl fpreset(void);

    
    

    
    

    
    
    

    
    
    
    
    
    
    

    
    
    

    
    
    
    
    

    
    
    
    

    

    
    
    
    
    
    

    
    
    
    

    
    
    
    
    
    

    
    
    
    

    

#line 399 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\float.h"



} __pragma(pack(pop))
#line 404 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\float.h"
#line 12 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\cfloat"
#line 13 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\cfloat"
#line 12 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\limits"
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\climits"





#pragma once







#line 15 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\climits"
#line 16 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\climits"
#line 13 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\limits"
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\cwchar"





#pragma once





#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\cstdio"





#pragma once





#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"







#pragma once




#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"









#pragma once


#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_stdio_config.h"







#pragma once



__pragma(pack(push, 8)) extern "C" {



#line 17 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_stdio_config.h"




#line 22 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_stdio_config.h"
    
#line 24 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_stdio_config.h"


    

#line 29 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_stdio_config.h"
        
    

#line 33 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_stdio_config.h"
#line 34 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_stdio_config.h"














    








#line 58 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_stdio_config.h"




#line 63 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_stdio_config.h"

    
        


            #pragma detect_mismatch("_CRT_STDIO_ISO_WIDE_SPECIFIERS", "0")
        #line 70 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_stdio_config.h"
    #line 71 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_stdio_config.h"
#line 72 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_stdio_config.h"






#line 79 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_stdio_config.h"


    
    
       
    
    __declspec(noinline) __inline unsigned __int64* __cdecl __local_stdio_printf_options(void)
    {
        static unsigned __int64 _OptionsStorage;
        return &_OptionsStorage;
    }

    
    
       
    
    __declspec(noinline) __inline unsigned __int64* __cdecl __local_stdio_scanf_options(void)
    {
        static unsigned __int64 _OptionsStorage;
        return &_OptionsStorage;
    }
#line 101 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_stdio_config.h"



#line 105 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_stdio_config.h"



















} __pragma(pack(pop))
#line 14 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

__pragma(pack(push, 8)) extern "C" {








    
    typedef struct _iobuf
    {
        void* _Placeholder;
    } FILE;
#line 30 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

 FILE* __cdecl __acrt_iob_func(unsigned _Ix);










    
    
    
    
    
    
     wint_t __cdecl fgetwc(
          FILE* _Stream
        );

    
     wint_t __cdecl _fgetwchar(void);

    
     wint_t __cdecl fputwc(
             wchar_t _Character,
          FILE*   _Stream);

    
     wint_t __cdecl _fputwchar(
          wchar_t _Character
        );

     
     wint_t __cdecl getwc(
          FILE* _Stream
        );

     
     wint_t __cdecl getwchar(void);


    
     
     wchar_t* __cdecl fgetws(
          wchar_t* _Buffer,
                                  int      _BufferCount,
                               FILE*    _Stream
        );

    
     int __cdecl fputws(
           wchar_t const* _Buffer,
          FILE*          _Stream
        );

    
     
     wchar_t* __cdecl _getws_s(
          wchar_t* _Buffer,
                                  size_t   _BufferCount
        );

    extern "C++" { template <size_t _Size> inline   wchar_t* __cdecl _getws_s( wchar_t (&_Buffer)[_Size]) throw() { return _getws_s(_Buffer, _Size); } }
#line 101 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    
     wint_t __cdecl putwc(
             wchar_t _Character,
          FILE*   _Stream
        );

    
     wint_t __cdecl putwchar(
          wchar_t _Character
        );

    
     int __cdecl _putws(
          wchar_t const* _Buffer
        );

    
     wint_t __cdecl ungetwc(
             wint_t _Character,
          FILE*  _Stream
        );

     
     FILE * __cdecl _wfdopen(
            int            _FileHandle,
          wchar_t const* _Mode
        );

      __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wfopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
     FILE* __cdecl _wfopen(
          wchar_t const* _FileName,
          wchar_t const* _Mode
        );

    
     errno_t __cdecl _wfopen_s(
          FILE**         _Stream,
                             wchar_t const* _FileName,
                             wchar_t const* _Mode
        );

     
    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wfreopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
     FILE* __cdecl _wfreopen(
           wchar_t const* _FileName,
           wchar_t const* _Mode,
          FILE*          _OldStream
        );

    
     errno_t __cdecl _wfreopen_s(
          FILE**         _Stream,
                             wchar_t const* _FileName,
                             wchar_t const* _Mode,
                            FILE*          _OldStream
        );

     
     FILE* __cdecl _wfsopen(
          wchar_t const* _FileName,
          wchar_t const* _Mode,
            int            _ShFlag
        );

     void __cdecl _wperror(
          wchar_t const* _ErrorMessage
        );

    

         
         FILE* __cdecl _wpopen(
              wchar_t const* _Command,
              wchar_t const* _Mode
            );

    #line 178 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

     int __cdecl _wremove(
          wchar_t const* _FileName
        );

    
    

     
     __declspec(allocator) wchar_t* __cdecl _wtempnam(
          wchar_t const* _Directory,
          wchar_t const* _FilePrefix
        );

    

     
    
     errno_t __cdecl _wtmpnam_s(
          wchar_t* _Buffer,
                                  size_t   _BufferCount
        );

    extern "C++" { template <size_t _Size> inline   errno_t __cdecl _wtmpnam_s( wchar_t (&_Buffer)[_Size]) throw() { return _wtmpnam_s(_Buffer, _Size); } }
#line 207 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wtmpnam_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))   wchar_t* __cdecl _wtmpnam(  wchar_t *_Buffer);
#line 213 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"



    
    
    
    
    
    
     wint_t __cdecl _fgetwc_nolock(
          FILE* _Stream
        );

    
     wint_t __cdecl _fputwc_nolock(
             wchar_t _Character,
          FILE*   _Stream
        );

    
     wint_t __cdecl _getwc_nolock(
          FILE* _Stream
        );

    
     wint_t __cdecl _putwc_nolock(
             wchar_t _Character,
          FILE*   _Stream
        );

    
     wint_t __cdecl _ungetwc_nolock(
             wint_t _Character,
          FILE*  _Stream
        );

    



#line 253 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"



    
    





    
    
    
    
    
    
     int __cdecl __stdio_common_vfwprintf(
                                             unsigned __int64 _Options,
                                          FILE*            _Stream,
            wchar_t const*   _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

    
     int __cdecl __stdio_common_vfwprintf_s(
                                             unsigned __int64 _Options,
                                          FILE*            _Stream,
            wchar_t const*   _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

    
     int __cdecl __stdio_common_vfwprintf_p(
                                             unsigned __int64 _Options,
                                          FILE*            _Stream,
            wchar_t const*   _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

    
    __inline int __cdecl _vfwprintf_l(
                                          FILE*          const _Stream,
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    

#line 305 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        return __stdio_common_vfwprintf((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
    }
    #line 309 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl vfwprintf(
                                FILE*          const _Stream,
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )
    

#line 319 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwprintf_l(_Stream, _Format, 0, _ArgList);
    }
    #line 323 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _vfwprintf_s_l(
                                          FILE*          const _Stream,
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    

#line 334 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        return __stdio_common_vfwprintf_s((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
    }
    #line 338 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    

        
        __inline int __cdecl vfwprintf_s(
                                    FILE*          const _Stream,
                wchar_t const* const _Format,
                                          va_list              _ArgList
            )
    

#line 350 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
        {
            return _vfwprintf_s_l(_Stream, _Format, 0, _ArgList);
        }
    #line 354 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    #line 356 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _vfwprintf_p_l(
                                          FILE*          const _Stream,
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    

#line 367 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        return __stdio_common_vfwprintf_p((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
    }
    #line 371 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _vfwprintf_p(
                                FILE*          const _Stream,
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )
    

#line 381 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwprintf_p_l(_Stream, _Format, 0, _ArgList);
    }
    #line 385 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _vwprintf_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    

#line 395 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwprintf_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    }
    #line 399 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl vwprintf(
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )
    

#line 408 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwprintf_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
    }
    #line 412 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _vwprintf_s_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    

#line 422 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwprintf_s_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    }
    #line 426 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    

        
        __inline int __cdecl vwprintf_s(
                wchar_t const* const _Format,
                                          va_list              _ArgList
            )
    

#line 437 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
        {
            return _vfwprintf_s_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
        }
    #line 441 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    #line 443 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _vwprintf_p_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    

#line 453 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwprintf_p_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    }
    #line 457 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _vwprintf_p(
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )
    

#line 466 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwprintf_p_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
    }
    #line 470 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _fwprintf_l(
                                          FILE*          const _Stream,
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)
    

#line 480 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfwprintf_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 489 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl fwprintf(
                                FILE*          const _Stream,
            wchar_t const* const _Format,
        ...)
    

#line 498 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfwprintf_l(_Stream, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 507 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _fwprintf_s_l(
                                          FILE*          const _Stream,
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)
    

#line 517 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfwprintf_s_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 526 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    

        
        __inline int __cdecl fwprintf_s(
                                    FILE*          const _Stream,
                wchar_t const* const _Format,
            ...)
    

#line 537 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
            _Result = _vfwprintf_s_l(_Stream, _Format, 0, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    #line 546 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    #line 548 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _fwprintf_p_l(
                                          FILE*          const _Stream,
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)
    

#line 558 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfwprintf_p_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 567 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _fwprintf_p(
                                FILE*          const _Stream,
            wchar_t const* const _Format,
        ...)
    

#line 576 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfwprintf_p_l(_Stream, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 585 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _wprintf_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)
    

#line 594 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfwprintf_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 603 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl wprintf(
            wchar_t const* const _Format,
        ...)
    

#line 611 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfwprintf_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 620 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _wprintf_s_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)
    

#line 629 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfwprintf_s_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 638 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    

        
        __inline int __cdecl wprintf_s(
                wchar_t const* const _Format,
            ...)
    

#line 648 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
            _Result = _vfwprintf_s_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    #line 657 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    #line 659 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _wprintf_p_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)
    

#line 668 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfwprintf_p_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 677 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _wprintf_p(
            wchar_t const* const _Format,
        ...)
    

#line 685 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfwprintf_p_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 694 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"


    
    
    
    
    
    
     int __cdecl __stdio_common_vfwscanf(
                                            unsigned __int64 _Options,
                                         FILE*            _Stream,
            wchar_t const*   _Format,
                                        _locale_t        _Locale,
                                               va_list          _ArgList
        );

    
    __inline int __cdecl _vfwscanf_l(
          FILE*                                const _Stream,
            wchar_t const* const _Format,
                               _locale_t      const _Locale,
                                      va_list              _ArgList
        )
    

#line 720 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        return __stdio_common_vfwscanf(
            (*__local_stdio_scanf_options ()),
            _Stream, _Format, _Locale, _ArgList);
    }
    #line 726 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl vfwscanf(
          FILE*                                const _Stream,
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )
    

#line 736 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwscanf_l(_Stream, _Format, 0, _ArgList);
    }
    #line 740 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _vfwscanf_s_l(
                                FILE*          const _Stream,
            wchar_t const* const _Format,
                               _locale_t      const _Locale,
                                      va_list              _ArgList
        )
    

#line 751 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        return __stdio_common_vfwscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0),
            _Stream, _Format, _Locale, _ArgList);
    }
    #line 757 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    

        
        __inline int __cdecl vfwscanf_s(
                                    FILE*          const _Stream,
                wchar_t const* const _Format,
                                          va_list              _ArgList
            )
    

#line 769 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
        {
            return _vfwscanf_s_l(_Stream, _Format, 0, _ArgList);
        }
    #line 773 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    #line 775 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    __inline int __cdecl _vwscanf_l(
            wchar_t const* const _Format,
                               _locale_t      const _Locale,
                                      va_list              _ArgList
        )
    

#line 784 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwscanf_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
    }
    #line 788 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl vwscanf(
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )
    

#line 797 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwscanf_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
    }
    #line 801 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _vwscanf_s_l(
            wchar_t const* const _Format,
                               _locale_t      const _Locale,
                                      va_list              _ArgList
        )
    

#line 811 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwscanf_s_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
    }
    #line 815 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    

        
        __inline int __cdecl vwscanf_s(
                wchar_t const* const _Format,
                                          va_list              _ArgList
            )
    

#line 826 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
        {
            return _vfwscanf_s_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
        }
    #line 830 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    #line 832 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_fwscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _fwscanf_l(
                                         FILE*          const _Stream,
            wchar_t const* const _Format,
                                        _locale_t      const _Locale,
        ...)
    

#line 842 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfwscanf_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 851 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

      __declspec(deprecated("This function or variable may be unsafe. Consider using " "fwscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl fwscanf(
                               FILE*          const _Stream,
            wchar_t const* const _Format,
        ...)
    

#line 860 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfwscanf_l(_Stream, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 869 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _fwscanf_s_l(
                                           FILE*          const _Stream,
            wchar_t const* const _Format,
                                          _locale_t      const _Locale,
        ...)
    

#line 879 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfwscanf_s_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 888 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    

        
        __inline int __cdecl fwscanf_s(
                                     FILE*          const _Stream,
                wchar_t const* const _Format,
            ...)
    

#line 899 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
            _Result = _vfwscanf_s_l(_Stream, _Format, 0, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    #line 908 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    #line 910 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _wscanf_l(
            wchar_t const* const _Format,
                                        _locale_t      const _Locale,
        ...)
    

#line 919 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfwscanf_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 928 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

      __declspec(deprecated("This function or variable may be unsafe. Consider using " "wscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl wscanf(
            wchar_t const* const _Format,
        ...)
    

#line 936 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfwscanf_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 945 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _wscanf_s_l(
            wchar_t const* const _Format,
                                          _locale_t      const _Locale,
        ...)
    

#line 954 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfwscanf_s_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 963 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    

        
        __inline int __cdecl wscanf_s(
                wchar_t const* const _Format,
            ...)
    

#line 973 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
            _Result = _vfwscanf_s_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    #line 982 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    #line 984 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"



    
    
    
    
    
    
        



    

#line 1000 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

     
    
     int __cdecl __stdio_common_vswprintf(
                                             unsigned __int64 _Options,
                 wchar_t*         _Buffer,
                                             size_t           _BufferCount,
            wchar_t const*   _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

     
    
     int __cdecl __stdio_common_vswprintf_s(
                                             unsigned __int64 _Options,
                     wchar_t*         _Buffer,
                                             size_t           _BufferCount,
            wchar_t const*   _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

     
    
     int __cdecl __stdio_common_vsnwprintf_s(
                                             unsigned __int64 _Options,
                 wchar_t*         _Buffer,
                                             size_t           _BufferCount,
                                             size_t           _MaxCount,
            wchar_t const*   _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

     
    
     int __cdecl __stdio_common_vswprintf_p(
                                             unsigned __int64 _Options,
                     wchar_t*         _Buffer,
                                             size_t           _BufferCount,
            wchar_t const*   _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

     
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vsnwprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _vsnwprintf_l(
            wchar_t*       const _Buffer,
                                                  size_t         const _BufferCount,
                 wchar_t const* const _Format,
                                              _locale_t      const _Locale,
                                                     va_list              _ArgList
        )
    

#line 1058 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        int const _Result = __stdio_common_vswprintf(
            (*__local_stdio_printf_options()) | (1ULL << 0),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1066 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    #pragma warning(push)
    #pragma warning(disable: 4793)

     
    
    __inline int __cdecl _vsnwprintf_s_l(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                                                       size_t         const _MaxCount,
                      wchar_t const* const _Format,
                                                   _locale_t      const _Locale,
                                                          va_list              _ArgList
        )
    

#line 1083 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        int const _Result = __stdio_common_vsnwprintf_s(
            (*__local_stdio_printf_options()),
            _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1091 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _vsnwprintf_s(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                                                       size_t         const _MaxCount,
                                wchar_t const* const _Format,
                                                          va_list              _ArgList
        )
    

#line 1104 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vsnwprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0, _ArgList);
    }
    #line 1108 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_snwprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __inline   int __cdecl _snwprintf(    wchar_t *_Buffer,   size_t _BufferCount,     wchar_t const* _Format, ...); __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vsnwprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __inline   int __cdecl _vsnwprintf(    wchar_t *_Buffer,   size_t _BufferCount,     wchar_t const* _Format, va_list _Args);
#line 1118 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    #pragma warning(pop)

     
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vsnwprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _vsnwprintf(
            wchar_t*       _Buffer,
                                                  size_t         _BufferCount,
                           wchar_t const* _Format,
                                                     va_list        _ArgList
        )
    

#line 1131 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        #pragma warning(push)
        #pragma warning(disable: 4996) 
        return _vsnwprintf_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        #pragma warning(pop)
    }
    #line 1138 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    extern "C++" { template <size_t _Size> inline   int __cdecl _vsnwprintf_s( wchar_t (&_Buffer)[_Size],   size_t _BufferCount,     wchar_t const* _Format, va_list _ArgList) throw() { return _vsnwprintf_s(_Buffer, _Size, _BufferCount, _Format, _ArgList); } }
#line 1148 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _vswprintf_c_l(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                      wchar_t const* const _Format,
                                                   _locale_t      const _Locale,
                                                          va_list              _ArgList
        )
    

#line 1160 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        int const _Result = __stdio_common_vswprintf(
            (*__local_stdio_printf_options()),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1168 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _vswprintf_c(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                                wchar_t const* const _Format,
                                                          va_list              _ArgList
        )
    

#line 1180 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vswprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    }
    #line 1184 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _vswprintf_l(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                      wchar_t const* const _Format,
                                                   _locale_t      const _Locale,
                                                          va_list              _ArgList
        )
    

#line 1197 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        #pragma warning(push)
        #pragma warning(disable: 4996) 
        return _vswprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        #pragma warning(pop)
    }
    #line 1204 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl __vswprintf_l(
                  wchar_t*       const _Buffer,
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    

#line 1216 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vswprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    }
    #line 1220 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _vswprintf(
           wchar_t*       const _Buffer,
               wchar_t const* const _Format,
                                         va_list              _ArgList
        )
    

#line 1231 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vswprintf_l(_Buffer, (size_t)-1, _Format, 0, _ArgList);
    }
    #line 1235 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl vswprintf(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                      wchar_t const* const _Format,
                                                          va_list              _ArgList
        )
    

#line 1247 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vswprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    }
    #line 1251 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _vswprintf_s_l(
           wchar_t*       const _Buffer,
                                                   size_t         const _BufferCount,
                  wchar_t const* const _Format,
                                               _locale_t      const _Locale,
                                                      va_list              _ArgList
        )
    

#line 1264 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        int const _Result = __stdio_common_vswprintf_s(
            (*__local_stdio_printf_options()),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1272 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    

         
        __inline int __cdecl vswprintf_s(
               wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                                wchar_t const* const _Format,
                                                          va_list              _ArgList
            )
    

#line 1285 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
        {
            return _vswprintf_s_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        }
    #line 1289 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    #line 1291 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    extern "C++" { template <size_t _Size> inline   int __cdecl vswprintf_s( wchar_t (&_Buffer)[_Size],     wchar_t const* _Format, va_list _ArgList) throw() { return vswprintf_s(_Buffer, _Size, _Format, _ArgList); } }
#line 1300 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _vswprintf_p_l(
           wchar_t*       const _Buffer,
                                                   size_t         const _BufferCount,
                  wchar_t const* const _Format,
                                               _locale_t      const _Locale,
                                                      va_list              _ArgList
        )
    

#line 1312 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        int const _Result = __stdio_common_vswprintf_p(
            (*__local_stdio_printf_options()),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1320 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _vswprintf_p(
           wchar_t*       const _Buffer,
                                                   size_t         const _BufferCount,
                            wchar_t const* const _Format,
                                                      va_list              _ArgList
        )
    

#line 1332 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vswprintf_p_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    }
    #line 1336 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

     
     
    __inline int __cdecl _vscwprintf_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    

#line 1347 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        int const _Result = __stdio_common_vswprintf(
            (*__local_stdio_printf_options()) | (1ULL << 1),
            0, 0, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1355 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

     
     
    __inline int __cdecl _vscwprintf(
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )
    

#line 1365 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vscwprintf_l(_Format, 0, _ArgList);
    }
    #line 1369 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

     
     
    __inline int __cdecl _vscwprintf_p_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    

#line 1380 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        int const _Result = __stdio_common_vswprintf_p(
            (*__local_stdio_printf_options()) | (1ULL << 1),
            0, 0, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1388 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

     
     
    __inline int __cdecl _vscwprintf_p(
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )
    

#line 1398 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vscwprintf_p_l(_Format, 0, _ArgList);
    }
    #line 1402 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl __swprintf_l(
                  wchar_t*       const _Buffer,
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)
    

#line 1413 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = __vswprintf_l(_Buffer, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1422 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _swprintf_l(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                      wchar_t const* const _Format,
                                                   _locale_t      const _Locale,
        ...)
    

#line 1434 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1443 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _swprintf(
           wchar_t*       const _Buffer,
               wchar_t const* const _Format,
        ...)
    

#line 1453 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = __vswprintf_l(_Buffer, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1462 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl swprintf(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                                wchar_t const* const _Format,
        ...)
    

#line 1473 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1482 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    #pragma warning(push)
    
    
    #pragma warning(disable:4793 4996)

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "__swprintf_l_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __inline   int __cdecl __swprintf_l(   wchar_t *_Buffer,     wchar_t const* _Format,   _locale_t _Locale, ...); __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vswprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __inline   int __cdecl __vswprintf_l(   wchar_t *_Buffer,     wchar_t const* _Format,   _locale_t _Locale, va_list _Args);
#line 1497 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "swprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __inline   int __cdecl _swprintf(   wchar_t *_Buffer,     wchar_t const* _Format, ...); __declspec(deprecated("This function or variable may be unsafe. Consider using " "vswprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __inline   int __cdecl _vswprintf(   wchar_t *_Buffer,     wchar_t const* _Format, va_list _Args);
#line 1504 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    #pragma warning(pop)

     
    
    __inline int __cdecl _swprintf_s_l(
           wchar_t*       const _Buffer,
                                                   size_t         const _BufferCount,
                  wchar_t const* const _Format,
                                               _locale_t      const _Locale,
        ...)
    

#line 1517 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vswprintf_s_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1526 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    

         
        __inline int __cdecl swprintf_s(
               wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                                wchar_t const* const _Format,
            ...)
    

#line 1538 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
            _Result = _vswprintf_s_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    #line 1547 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    #line 1549 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    extern "C++" { __pragma(warning(push)); __pragma(warning(disable: 4793)); template <size_t _Size> inline   int __cdecl swprintf_s( wchar_t (&_Buffer)[_Size],     wchar_t const* _Format, ...) throw() { va_list _ArgList; ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))); return vswprintf_s(_Buffer, _Size, _Format, _ArgList); } __pragma(warning(pop)); }
#line 1557 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _swprintf_p_l(
           wchar_t*       const _Buffer,
                                                   size_t         const _BufferCount,
                  wchar_t const* const _Format,
                                               _locale_t      const _Locale,
        ...)
    

#line 1568 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vswprintf_p_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1577 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _swprintf_p(
           wchar_t*       const _Buffer,
                                                   size_t         const _BufferCount,
                            wchar_t const* const _Format,
        ...)
    

#line 1588 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vswprintf_p_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1597 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _swprintf_c_l(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                      wchar_t const* const _Format,
                                                   _locale_t      const _Locale,
        ...)
    

#line 1609 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1618 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _swprintf_c(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                                wchar_t const* const _Format,
        ...)
    

#line 1629 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1638 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

     
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_snwprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _snwprintf_l(
            wchar_t*       const _Buffer,
                                                  size_t         const _BufferCount,
                 wchar_t const* const _Format,
                                              _locale_t      const _Locale,
        ...)
    

#line 1650 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));

        #pragma warning(push)
        #pragma warning(disable: 4996) 
        _Result = _vsnwprintf_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        #pragma warning(pop)

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1664 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _snwprintf(
            wchar_t*       _Buffer,
                                                  size_t         _BufferCount,
                           wchar_t const* _Format,
        ...)
    

#line 1675 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));

        #pragma warning(push)
        #pragma warning(disable: 4996) 
        _Result = _vsnwprintf_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        #pragma warning(pop)

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1689 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _snwprintf_s_l(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                                                       size_t         const _MaxCount,
                      wchar_t const* const _Format,
                                                   _locale_t      const _Locale,
        ...)
    

#line 1702 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vsnwprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1711 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _snwprintf_s(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                                                       size_t         const _MaxCount,
                                wchar_t const* const _Format,
        ...)
    

#line 1723 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vsnwprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1732 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    extern "C++" { __pragma(warning(push)); __pragma(warning(disable: 4793)); template <size_t _Size> inline   int __cdecl _snwprintf_s( wchar_t (&_Buffer)[_Size],   size_t _BufferCount,     wchar_t const* _Format, ...) throw() { va_list _ArgList; ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))); return _vsnwprintf_s(_Buffer, _Size, _BufferCount, _Format, _ArgList); } __pragma(warning(pop)); }
#line 1741 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

     
    __inline int __cdecl _scwprintf_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)
    

#line 1749 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vscwprintf_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1758 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

     
     
    __inline int __cdecl _scwprintf(
            wchar_t const* const _Format,
        ...)
    

#line 1767 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vscwprintf_l(_Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1776 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

     
     
    __inline int __cdecl _scwprintf_p_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)
    

#line 1786 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vscwprintf_p_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1795 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

     
     
    __inline int __cdecl _scwprintf_p(
            wchar_t const* const _Format,
        ...)
    

#line 1804 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vscwprintf_p_l(_Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1813 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"


    
        #pragma warning(push)
        #pragma warning(disable: 4141 4412 4793 4996 6054)

        

            extern "C++" __declspec(deprecated("function has been changed to conform with the ISO C standard, " "adding an extra character count parameter. To use the traditional " "Microsoft version, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "swprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
            inline int swprintf(
                           wchar_t*       const _Buffer,
                    wchar_t const* const _Format,
                ...) throw()
            {
                int _Result;
                va_list _ArgList;
                ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
                #pragma warning(suppress: 28719)
                _Result = vswprintf(_Buffer, 2147483647, _Format, _ArgList);
                ((void)(_ArgList = (va_list)0));
                return _Result;
            }

            extern "C++" __declspec(deprecated("function has been changed to conform with the ISO C standard, " "adding an extra character count parameter. To use the traditional " "Microsoft version, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "vswprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
            inline int __cdecl vswprintf(
                           wchar_t*       const _Buffer,
                    wchar_t const* const _Format,
                                              va_list              _ArgList
                ) throw()
            {
                #pragma warning(suppress: 28719)
                return vswprintf(_Buffer, 2147483647, _Format, _ArgList);
            }

            extern "C++" __declspec(deprecated("function has been changed to conform with the ISO C standard, " "adding an extra character count parameter. To use the traditional " "Microsoft version, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_swprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
            inline int _swprintf_l(
                                     wchar_t*       const _Buffer,
                    wchar_t const* const _Format,
                                                 _locale_t      const _Locale,
                ...) throw()
            {
                int _Result;
                va_list _ArgList;
                ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
                _Result = _vswprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
                ((void)(_ArgList = (va_list)0));
                return _Result;
            }

            extern "C++" __declspec(deprecated("function has been changed to conform with the ISO C standard, " "adding an extra character count parameter. To use the traditional " "Microsoft version, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vswprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
            inline int __cdecl _vswprintf_l(
                                     wchar_t*       const _Buffer,
                    wchar_t const* const _Format,
                                                 _locale_t      const _Locale,
                                                        va_list              _ArgList
                ) throw()
            {
                return _vswprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
            }

        #line 1874 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

        #pragma warning(pop)
    #line 1877 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    




#line 1884 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"


    
    
    
    
    
     
     int __cdecl __stdio_common_vswscanf(
                                            unsigned __int64 _Options,
                  wchar_t const*   _Buffer,
                                            size_t           _BufferCount,
            wchar_t const*   _Format,
                                        _locale_t        _Locale,
                                               va_list          _ArgList
        );

     
    
    __inline int __cdecl _vswscanf_l(
                                 wchar_t const* const _Buffer,
            wchar_t const* const _Format,
                               _locale_t      const _Locale,
                                      va_list              _ArgList
        )
    

#line 1912 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        return __stdio_common_vswscanf(
            (*__local_stdio_scanf_options ()),
            _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    }
    #line 1918 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl vswscanf(
                                 wchar_t const* _Buffer,
            wchar_t const* _Format,
                                      va_list        _ArgList
        )
    

#line 1929 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vswscanf_l(_Buffer, _Format, 0, _ArgList);
    }
    #line 1933 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _vswscanf_s_l(
                                 wchar_t const* const _Buffer,
            wchar_t const* const _Format,
                               _locale_t      const _Locale,
                                      va_list              _ArgList
        )
    

#line 1945 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        return __stdio_common_vswscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0),
            _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    }
    #line 1951 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    

         
        
        __inline int __cdecl vswscanf_s(
                                     wchar_t const* const _Buffer,
                wchar_t const* const _Format,
                                          va_list              _ArgList
            )
    

#line 1964 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
        {
            return _vswscanf_s_l(_Buffer, _Format, 0, _ArgList);
        }
    #line 1968 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    #line 1970 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    extern "C++" { template <size_t _Size> inline   int __cdecl vswscanf_s(  wchar_t (&_Buffer)[_Size],     wchar_t const* _Format, va_list _ArgList) throw() { return vswscanf_s(_Buffer, _Size, _Format, _ArgList); } }
#line 1979 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

     
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vsnwscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _vsnwscanf_l(
                  wchar_t const* const _Buffer,
                                            size_t         const _BufferCount,
            wchar_t const* const _Format,
                                        _locale_t      const _Locale,
                                               va_list              _ArgList
        )
    

#line 1991 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        return __stdio_common_vswscanf(
            (*__local_stdio_scanf_options ()),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);
    }
    #line 1997 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _vsnwscanf_s_l(
                    wchar_t const* const _Buffer,
                                              size_t         const _BufferCount,
            wchar_t const* const _Format,
                                          _locale_t      const _Locale,
                                                 va_list              _ArgList
        )
    

#line 2010 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        return __stdio_common_vswscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);
    }
    #line 2016 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

     
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_swscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _swscanf_l(
                                          wchar_t const* const _Buffer,
            wchar_t const* const _Format,
                                        _locale_t            _Locale,
        ...)
    

#line 2027 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vswscanf_l(_Buffer, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2036 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

     
      __declspec(deprecated("This function or variable may be unsafe. Consider using " "swscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl swscanf(
                                wchar_t const* const _Buffer,
            wchar_t const* const _Format,
        ...)
    

#line 2046 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vswscanf_l(_Buffer, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2055 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _swscanf_s_l(
                                            wchar_t const* const _Buffer,
            wchar_t const* const _Format,
                                          _locale_t      const _Locale,
        ...)
    

#line 2066 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vswscanf_s_l(_Buffer, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2075 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    

         
        
        __inline int __cdecl swscanf_s(
                                      wchar_t const* const _Buffer,
                wchar_t const* const _Format,
            ...)
    

#line 2087 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
            _Result = _vswscanf_s_l(_Buffer, _Format, 0, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    #line 2096 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    #line 2098 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

     
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_snwscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _snwscanf_l(
                  wchar_t const* const _Buffer,
                                            size_t         const _BufferCount,
            wchar_t const* const _Format,
                                        _locale_t      const _Locale,
        ...)
    

#line 2110 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));

        #pragma warning(push)
        #pragma warning(disable: 4996) 
        _Result = _vsnwscanf_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        #pragma warning(pop)

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2124 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

     
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_snwscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _snwscanf(
            wchar_t const* const _Buffer,
                                      size_t         const _BufferCount,
                wchar_t const* const _Format,
        ...)
    

#line 2135 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));

        #pragma warning(push)
        #pragma warning(disable: 4996) 
        _Result = _vsnwscanf_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        #pragma warning(pop)

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2149 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _snwscanf_s_l(
                    wchar_t const* const _Buffer,
                                              size_t         const _BufferCount,
            wchar_t const* const _Format,
                                          _locale_t      const _Locale,
        ...)
    

#line 2161 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vsnwscanf_s_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2170 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _snwscanf_s(
             wchar_t const* const _Buffer,
                                       size_t         const _BufferCount,
               wchar_t const* const _Format,
        ...)
    

#line 2181 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vsnwscanf_s_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2190 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    


#line 2195 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"



} __pragma(pack(pop))
#line 14 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"

__pragma(pack(push, 8)) extern "C" {































    
#line 49 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"















    
    
#line 67 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"


typedef __int64 fpos_t;





    
     errno_t __cdecl _get_stream_buffer_pointers(
               FILE*   _Stream,
          char*** _Base,
          char*** _Pointer,
          int**   _Count
        );


    
    
    
    
    
    

        
         errno_t __cdecl clearerr_s(
              FILE* _Stream
            );

        
         errno_t __cdecl fopen_s(
              FILE**      _Stream,
                                 char const* _FileName,
                                 char const* _Mode
            );

        
         
         size_t __cdecl fread_s(
                void*  _Buffer,
                                    size_t _BufferSize,
                                                                            size_t _ElementSize,
                                                                            size_t _ElementCount,
                                                                         FILE*  _Stream
            );

        
         errno_t __cdecl freopen_s(
              FILE**      _Stream,
                                 char const* _FileName,
                                 char const* _Mode,
                                FILE*       _OldStream
            );

         
         char* __cdecl gets_s(
              char*   _Buffer,
                               rsize_t _Size
            );

        
         errno_t __cdecl tmpfile_s(
                FILE** _Stream
            );

         
        
         errno_t __cdecl tmpnam_s(
              char*   _Buffer,
                               rsize_t _Size
            );

    #line 140 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"

     void __cdecl clearerr(
          FILE* _Stream
        );

     
    
     int __cdecl fclose(
          FILE* _Stream
        );

    
     int __cdecl _fcloseall(void);

     
     FILE* __cdecl _fdopen(
            int         _FileHandle,
          char const* _Mode
        );

     
     int __cdecl feof(
          FILE* _Stream
        );

     
     int __cdecl ferror(
          FILE* _Stream
        );

    
     int __cdecl fflush(
          FILE* _Stream
        );

     
    
     int __cdecl fgetc(
          FILE* _Stream
        );

    
     int __cdecl _fgetchar(void);

     
    
     int __cdecl fgetpos(
          FILE*   _Stream,
            fpos_t* _Position
        );

     
    
     char* __cdecl fgets(
          char* _Buffer,
                               int   _MaxCount,
                            FILE* _Stream
        );

     
     int __cdecl _fileno(
          FILE* _Stream
        );

    
     int __cdecl _flushall(void);

      __declspec(deprecated("This function or variable may be unsafe. Consider using " "fopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
     FILE* __cdecl fopen(
          char const* _FileName,
          char const* _Mode
        );


     
    
     int __cdecl fputc(
             int   _Character,
          FILE* _Stream
        );

    
     int __cdecl _fputchar(
          int _Character
        );

     
    
     int __cdecl fputs(
           char const* _Buffer,
          FILE*       _Stream
        );

    
     size_t __cdecl fread(
          void*  _Buffer,
                                                      size_t _ElementSize,
                                                      size_t _ElementCount,
                                                   FILE*  _Stream
        );

     
      __declspec(deprecated("This function or variable may be unsafe. Consider using " "freopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
     FILE* __cdecl freopen(
           char const* _FileName,
           char const* _Mode,
          FILE*       _Stream
        );

     
     FILE* __cdecl _fsopen(
          char const* _FileName,
          char const* _Mode,
            int         _ShFlag
        );

     
    
     int __cdecl fsetpos(
          FILE*         _Stream,
             fpos_t const* _Position
        );

     
    
     int __cdecl fseek(
          FILE* _Stream,
             long  _Offset,
             int   _Origin
        );

     
    
     int __cdecl _fseeki64(
          FILE*   _Stream,
             __int64 _Offset,
             int     _Origin
        );

     
     
     long __cdecl ftell(
          FILE* _Stream
        );

     
     
     __int64 __cdecl _ftelli64(
          FILE* _Stream
        );

    
     size_t __cdecl fwrite(
          void const* _Buffer,
                                                    size_t      _ElementSize,
                                                    size_t      _ElementCount,
                                                 FILE*       _Stream
        );

     
     
     int __cdecl getc(
          FILE* _Stream
        );

     
     int __cdecl getchar(void);

     
     int __cdecl _getmaxstdio(void);

    extern "C++" { template <size_t _Size> inline char* __cdecl gets_s(char (&_Buffer)[_Size]) throw() { return gets_s(_Buffer, _Size); } }
#line 315 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"

     
     int __cdecl _getw(
          FILE* _Stream
        );

     void __cdecl perror(
          char const* _ErrorMessage
        );

    

         
        
         int __cdecl _pclose(
              FILE* _Stream
            );

         
         FILE* __cdecl _popen(
              char const* _Command,
              char const* _Mode
            );

    #line 339 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"

     
    
     int __cdecl putc(
             int   _Character,
          FILE* _Stream
        );

    
     int __cdecl putchar(
          int _Character
        );

    
     int __cdecl puts(
          char const* _Buffer
        );

     
    
     int __cdecl _putw(
             int   _Word,
          FILE* _Stream
        );

     int __cdecl remove(
          char const* _FileName
        );

     
     int __cdecl rename(
          char const* _OldFileName,
          char const* _NewFileName
        );

     int __cdecl _unlink(
          char const* _FileName
        );

    

        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_unlink" ". See online help for details."))
         int __cdecl unlink(
              char const* _FileName
            );

    #line 386 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"

     void __cdecl rewind(
          FILE* _Stream
        );

    
     int __cdecl _rmtmp(void);

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "setvbuf" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
     void __cdecl setbuf(
                                                      FILE* _Stream,
            char* _Buffer
        );

    
     int __cdecl _setmaxstdio(
          int _Maximum
        );

     
    
     int __cdecl setvbuf(
                               FILE*  _Stream,
            char*  _Buffer,
                                  int    _Mode,
                                  size_t _Size
        );

    


#line 418 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"

     
     __declspec(allocator) char* __cdecl _tempnam(
          char const* _DirectoryName,
          char const* _FilePrefix
        );

    

#line 428 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"

      __declspec(deprecated("This function or variable may be unsafe. Consider using " "tmpfile_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
     FILE* __cdecl tmpfile(void);

    extern "C++" { template <size_t _Size> inline   errno_t __cdecl tmpnam_s( char (&_Buffer)[_Size]) throw() { return tmpnam_s(_Buffer, _Size); } }
#line 438 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"

#pragma warning(push)
#pragma warning(disable: 28726) 
__declspec(deprecated("This function or variable may be unsafe. Consider using " "tmpnam_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))   char* __cdecl tmpnam(  char *_Buffer);
#line 446 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"
#pragma warning(pop)

     
    
     int __cdecl ungetc(
             int   _Character,
          FILE* _Stream
        );



    
    
    
    
    
     void __cdecl _lock_file(
          FILE* _Stream
        );

     void __cdecl _unlock_file(
          FILE* _Stream
        );

     
    
     int __cdecl _fclose_nolock(
          FILE* _Stream
        );

     
    
     int __cdecl _fflush_nolock(
          FILE* _Stream
        );

     
    
     int __cdecl _fgetc_nolock(
          FILE* _Stream
        );

     
    
     int __cdecl _fputc_nolock(
             int   _Character,
          FILE* _Stream
        );

    
     size_t __cdecl _fread_nolock(
          void*  _Buffer,
                                                      size_t _ElementSize,
                                                      size_t _ElementCount,
                                                   FILE*  _Stream
        );

    
     
     size_t __cdecl _fread_nolock_s(
          void*  _Buffer,
                              size_t _BufferSize,
                                                                      size_t _ElementSize,
                                                                      size_t _ElementCount,
                                                                   FILE*  _Stream
        );

    
     int __cdecl _fseek_nolock(
          FILE* _Stream,
             long  _Offset,
             int   _Origin
        );

    
     int __cdecl _fseeki64_nolock(
          FILE*   _Stream,
             __int64 _Offset,
             int     _Origin
        );

     
     long __cdecl _ftell_nolock(
          FILE* _Stream
        );

     
     __int64 __cdecl _ftelli64_nolock(
          FILE* _Stream
        );

    
     size_t __cdecl _fwrite_nolock(
          void const* _Buffer,
                                                    size_t      _ElementSize,
                                                    size_t      _ElementCount,
                                                 FILE*       _Stream
        );

    
     int __cdecl _getc_nolock(
          FILE* _Stream
        );

    
     int __cdecl _putc_nolock(
             int   _Character,
          FILE* _Stream
        );

    
     int __cdecl _ungetc_nolock(
             int   _Character,
          FILE* _Stream
        );

    
    
    
    



    














#line 584 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"



     int* __cdecl __p__commode(void);

    


        
    #line 594 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"



    
    

#line 601 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"

    
    
    
    
    
     int __cdecl __stdio_common_vfprintf(
                                             unsigned __int64 _Options,
                                          FILE*            _Stream,
            char const*      _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

     int __cdecl __stdio_common_vfprintf_s(
                                             unsigned __int64 _Options,
                                          FILE*            _Stream,
            char const*      _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

     
     int __cdecl __stdio_common_vfprintf_p(
                                             unsigned __int64 _Options,
                                          FILE*            _Stream,
            char const*      _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

    
    __inline int __cdecl _vfprintf_l(
           FILE*       const _Stream,
            char const* const _Format,
          _locale_t   const _Locale,
                 va_list           _ArgList
        )
    

#line 642 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        return __stdio_common_vfprintf((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
    }
    #line 646 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"

    
    __inline int __cdecl vfprintf(
                                FILE*       const _Stream,
            char const* const _Format,
                                      va_list           _ArgList
        )
    

#line 656 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        return _vfprintf_l(_Stream, _Format, 0, _ArgList);
    }
    #line 660 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vfprintf_s_l(
           FILE*       const _Stream,
            char const* const _Format,
          _locale_t   const _Locale,
                 va_list           _ArgList
        )
    

#line 671 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        return __stdio_common_vfprintf_s((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
    }
    #line 675 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"

    

        
        __inline int __cdecl vfprintf_s(
                                    FILE*       const _Stream,
                char const* const _Format,
                                          va_list           _ArgList
            )
    

#line 687 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"
        {
            return _vfprintf_s_l(_Stream, _Format, 0, _ArgList);
        }
    #line 691 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"

    #line 693 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vfprintf_p_l(
           FILE*       const _Stream,
            char const* const _Format,
          _locale_t   const _Locale,
                 va_list           _ArgList
        )
    

#line 704 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        return __stdio_common_vfprintf_p((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
    }
    #line 708 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vfprintf_p(
                                FILE*       const _Stream,
            char const* const _Format,
                                      va_list           _ArgList
        )
    

#line 718 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        return _vfprintf_p_l(_Stream, _Format, 0, _ArgList);
    }
    #line 722 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vprintf_l(
            char const* const _Format,
                                         _locale_t   const _Locale,
                                                va_list           _ArgList
        )
    

#line 732 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        return _vfprintf_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    }
    #line 736 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"

    
    __inline int __cdecl vprintf(
            char const* const _Format,
                                      va_list           _ArgList
        )
    

#line 745 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        return _vfprintf_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
    }
    #line 749 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vprintf_s_l(
            char const* const _Format,
                                         _locale_t   const _Locale,
                                                va_list           _ArgList
        )
    

#line 759 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        return _vfprintf_s_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    }
    #line 763 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"

    

        
        __inline int __cdecl vprintf_s(
                char const* const _Format,
                                          va_list           _ArgList
            )
    

#line 774 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"
        {
            return _vfprintf_s_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
        }
    #line 778 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"

    #line 780 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vprintf_p_l(
            char const* const _Format,
                                         _locale_t   const _Locale,
                                                va_list           _ArgList
        )
    

#line 790 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        return _vfprintf_p_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    }
    #line 794 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vprintf_p(
            char const* const _Format,
                                      va_list           _ArgList
        )
    

#line 803 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        return _vfprintf_p_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
    }
    #line 807 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _fprintf_l(
                                          FILE*       const _Stream,
            char const* const _Format,
                                         _locale_t   const _Locale,
        ...)
    

#line 817 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfprintf_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 826 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"

    
    __inline int __cdecl fprintf(
                                FILE*       const _Stream,
            char const* const _Format,
        ...)
    

#line 835 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfprintf_l(_Stream, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 844 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"

     int __cdecl _set_printf_count_output(
          int _Value
        );

     int __cdecl _get_printf_count_output(void);

    
    __inline int __cdecl _fprintf_s_l(
                                          FILE*       const _Stream,
            char const* const _Format,
                                         _locale_t   const _Locale,
        ...)
    

#line 860 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfprintf_s_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 869 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"

    

        
        __inline int __cdecl fprintf_s(
                                    FILE*       const _Stream,
                char const* const _Format,
            ...)
    

#line 880 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
            _Result = _vfprintf_s_l(_Stream, _Format, 0, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    #line 889 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"

    #line 891 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _fprintf_p_l(
                                          FILE*       const _Stream,
            char const* const _Format,
                                         _locale_t   const _Locale,
        ...)
    

#line 901 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfprintf_p_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 910 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _fprintf_p(
                                FILE*       const _Stream,
            char const* const _Format,
        ...)
    

#line 919 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfprintf_p_l(_Stream, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 928 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _printf_l(
            char const* const _Format,
                                         _locale_t   const _Locale,
        ...)
    

#line 937 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfprintf_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 946 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"

    
    __inline int __cdecl printf(
            char const* const _Format,
        ...)
    

#line 954 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfprintf_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 963 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _printf_s_l(
            char const* const _Format,
                                         _locale_t   const _Locale,
        ...)
    

#line 972 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfprintf_s_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 981 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"

    

        
        __inline int __cdecl printf_s(
                char const* const _Format,
            ...)
    

#line 991 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
            _Result = _vfprintf_s_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    #line 1000 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"

    #line 1002 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _printf_p_l(
            char const* const _Format,
                                         _locale_t   const _Locale,
        ...)
    

#line 1011 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfprintf_p_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1020 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _printf_p(
            char const* const _Format,
        ...)
    

#line 1028 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfprintf_p_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1037 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"


    
    
    
    
    
     int __cdecl __stdio_common_vfscanf(
                                            unsigned __int64 _Options,
                                         FILE*            _Stream,
            char const*      _Format,
                                        _locale_t        _Locale,
                                               va_list          _Arglist
        );

    
    __inline int __cdecl _vfscanf_l(
                                FILE*       const _Stream,
            char const* const _Format,
                               _locale_t   const _Locale,
                                      va_list           _ArgList
        )
    

#line 1062 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        return __stdio_common_vfscanf(
            (*__local_stdio_scanf_options ()),
            _Stream, _Format, _Locale, _ArgList);
    }
    #line 1068 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"

    
    __inline int __cdecl vfscanf(
                                FILE*       const _Stream,
            char const* const _Format,
                                      va_list           _ArgList
        )
    

#line 1078 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        return _vfscanf_l(_Stream, _Format, 0, _ArgList);
    }
    #line 1082 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vfscanf_s_l(
                                FILE*       const _Stream,
            char const* const _Format,
                               _locale_t   const _Locale,
                                      va_list           _ArgList
        )
    

#line 1093 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        return __stdio_common_vfscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0),
            _Stream, _Format, _Locale, _ArgList);
    }
    #line 1099 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"


    

        
        __inline int __cdecl vfscanf_s(
                                    FILE*       const _Stream,
                char const* const _Format,
                                          va_list           _ArgList
            )
    

#line 1112 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"
        {
            return _vfscanf_s_l(_Stream, _Format, 0, _ArgList);
        }
    #line 1116 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"

    #line 1118 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vscanf_l(
            char const* const _Format,
                               _locale_t   const _Locale,
                                      va_list           _ArgList
        )
    

#line 1128 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        return _vfscanf_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
    }
    #line 1132 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"

    
    __inline int __cdecl vscanf(
            char const* const _Format,
                                      va_list           _ArgList
        )
    

#line 1141 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        return _vfscanf_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
    }
    #line 1145 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vscanf_s_l(
            char const* const _Format,
                               _locale_t   const _Locale,
                                      va_list           _ArgList
        )
    

#line 1155 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        return _vfscanf_s_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
    }
    #line 1159 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"

    

        
        __inline int __cdecl vscanf_s(
                char const* const _Format,
                                          va_list           _ArgList
            )
    

#line 1170 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"
        {
            return _vfscanf_s_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
        }
    #line 1174 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"

    #line 1176 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"

     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_fscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _fscanf_l(
                                         FILE*       const _Stream,
            char const* const _Format,
                                        _locale_t   const _Locale,
        ...)
    

#line 1186 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfscanf_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1195 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"

      __declspec(deprecated("This function or variable may be unsafe. Consider using " "fscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl fscanf(
                               FILE*       const _Stream,
            char const* const _Format,
        ...)
    

#line 1204 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfscanf_l(_Stream, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1213 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _fscanf_s_l(
                                           FILE*       const _Stream,
            char const* const _Format,
                                          _locale_t   const _Locale,
        ...)
    

#line 1223 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfscanf_s_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1232 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"

    

        
        __inline int __cdecl fscanf_s(
                                     FILE*       const _Stream,
                char const* const _Format,
            ...)
    

#line 1243 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
            _Result = _vfscanf_s_l(_Stream, _Format, 0, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    #line 1252 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"

    #line 1254 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"

     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_scanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _scanf_l(
            char const* const _Format,
                                        _locale_t   const _Locale,
        ...)
    

#line 1263 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfscanf_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1272 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"

      __declspec(deprecated("This function or variable may be unsafe. Consider using " "scanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl scanf(
            char const* const _Format,
        ...)
    

#line 1280 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfscanf_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1289 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _scanf_s_l(
            char const* const _Format,
                                          _locale_t   const _Locale,
        ...)
    

#line 1298 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfscanf_s_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1307 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"

    

        
        __inline int __cdecl scanf_s(
                char const* const _Format,
            ...)
    

#line 1317 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
            _Result = _vfscanf_s_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    #line 1326 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"

    #line 1328 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"



    
    
    
    
    
     
     int __cdecl __stdio_common_vsprintf(
                                             unsigned __int64 _Options,
                 char*            _Buffer,
                                             size_t           _BufferCount,
            char const*      _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

     
     int __cdecl __stdio_common_vsprintf_s(
                                             unsigned __int64 _Options,
                     char*            _Buffer,
                                             size_t           _BufferCount,
            char const*      _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

     
     int __cdecl __stdio_common_vsnprintf_s(
                                             unsigned __int64 _Options,
                 char*            _Buffer,
                                             size_t           _BufferCount,
                                             size_t           _MaxCount,
            char const*      _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

     
     int __cdecl __stdio_common_vsprintf_p(
                                             unsigned __int64 _Options,
                     char*            _Buffer,
                                             size_t           _BufferCount,
            char const*      _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

     
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vsnprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _vsnprintf_l(
            char*       const _Buffer,
                                                  size_t      const _BufferCount,
                 char const* const _Format,
                                              _locale_t   const _Locale,
                                                     va_list           _ArgList
        )
    

#line 1389 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        int const _Result = __stdio_common_vsprintf(
            (*__local_stdio_printf_options()) | (1ULL << 0),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1397 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl _vsnprintf(
            char*       const _Buffer,
                                                 size_t      const _BufferCount,
                          char const* const _Format,
                                                    va_list           _ArgList
        )
    

#line 1409 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        #pragma warning(push)
        #pragma warning(disable: 4996) 
        return _vsnprintf_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        #pragma warning(pop)
    }
    #line 1416 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"

    








#line 1427 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl vsnprintf(
           char*       const _Buffer,
                                                       size_t      const _BufferCount,
                                char const* const _Format,
                                                          va_list           _ArgList
        )
    

#line 1439 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        int const _Result = __stdio_common_vsprintf(
            (*__local_stdio_printf_options()) | (1ULL << 1),
            _Buffer, _BufferCount, _Format, 0, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1447 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"

     
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vsprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _vsprintf_l(
           char*       const _Buffer,
                                    char const* const _Format,
                                  _locale_t   const _Locale,
                                         va_list           _ArgList
        )
    

#line 1459 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        #pragma warning(push)
        #pragma warning(disable: 4996) 
        return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
        #pragma warning(pop)
    }
    #line 1466 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"

     
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "vsprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl vsprintf(
           char*       const _Buffer,
               char const* const _Format,
                                         va_list           _ArgList
        )
    

#line 1477 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        #pragma warning(push)
        #pragma warning(disable: 4996) 
        return _vsnprintf_l(_Buffer, (size_t)-1, _Format, 0, _ArgList);
        #pragma warning(pop)
    }
    #line 1484 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl _vsprintf_s_l(
           char*       const _Buffer,
                                                   size_t      const _BufferCount,
                  char const* const _Format,
                                               _locale_t   const _Locale,
                                                      va_list           _ArgList
        )
    

#line 1497 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        int const _Result = __stdio_common_vsprintf_s(
            (*__local_stdio_printf_options()),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1505 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"

    

         
        
        __inline int __cdecl vsprintf_s(
               char*       const _Buffer,
                                                       size_t      const _BufferCount,
                                char const* const _Format,
                                                          va_list           _ArgList
            )
    

#line 1519 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"
        {
            return _vsprintf_s_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        }
    #line 1523 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"

        extern "C++" { template <size_t _Size> inline   int __cdecl vsprintf_s( char (&_Buffer)[_Size],     char const* _Format, va_list _ArgList) throw() { return vsprintf_s(_Buffer, _Size, _Format, _ArgList); } }
#line 1532 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"

    #line 1533 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl _vsprintf_p_l(
           char*       const _Buffer,
                                                   size_t      const _BufferCount,
                  char const* const _Format,
                                               _locale_t   const _Locale,
                                                      va_list           _ArgList
        )
    

#line 1546 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        int const _Result = __stdio_common_vsprintf_p(
            (*__local_stdio_printf_options()),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1554 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl _vsprintf_p(
           char*       const _Buffer,
                                                   size_t      const _BufferCount,
                            char const* const _Format,
                                                      va_list           _ArgList
        )
    

#line 1566 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        return _vsprintf_p_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    }
    #line 1570 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl _vsnprintf_s_l(
           char*       const _Buffer,
                                                       size_t      const _BufferCount,
                                                       size_t      const _MaxCount,
                      char const* const _Format,
                                                   _locale_t   const _Locale,
                                                          va_list          _ArgList
        )
    

#line 1584 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        int const _Result = __stdio_common_vsnprintf_s(
            (*__local_stdio_printf_options()),
            _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1592 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl _vsnprintf_s(
           char*       const _Buffer,
                                                       size_t      const _BufferCount,
                                                       size_t      const _MaxCount,
                                char const* const _Format,
                                                          va_list           _ArgList
        )
    

#line 1605 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        return _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0, _ArgList);
    }
    #line 1609 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"

    extern "C++" { template <size_t _Size> inline   int __cdecl _vsnprintf_s( char (&_Buffer)[_Size],   size_t _BufferCount,     char const* _Format, va_list _ArgList) throw() { return _vsnprintf_s(_Buffer, _Size, _BufferCount, _Format, _ArgList); } }
#line 1619 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"

    

         
        
        __inline int __cdecl vsnprintf_s(
               char*       const _Buffer,
                                                           size_t      const _BufferCount,
                                                           size_t      const _MaxCount,
                                    char const* const _Format,
                                                              va_list           _ArgList
            )
    

#line 1633 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"
        {
            return _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0, _ArgList);
        }
    #line 1637 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"

        extern "C++" { template <size_t _Size> inline   int __cdecl vsnprintf_s( char (&_Buffer)[_Size],   size_t _BufferCount,     char const* _Format, va_list _ArgList) throw() { return vsnprintf_s(_Buffer, _Size, _BufferCount, _Format, _ArgList); } }
#line 1647 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"

    #line 1648 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vscprintf_l(
            char const* const _Format,
                                         _locale_t   const _Locale,
                                                va_list           _ArgList
        )
    

#line 1658 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        int const _Result = __stdio_common_vsprintf(
            (*__local_stdio_printf_options()) | (1ULL << 1),
            0, 0, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1666 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"

     
    __inline int __cdecl _vscprintf(
            char const* const _Format,
                                      va_list           _ArgList
        )
    

#line 1675 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        return _vscprintf_l(_Format, 0, _ArgList);
    }
    #line 1679 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vscprintf_p_l(
            char const* const _Format,
                                         _locale_t   const _Locale,
                                                va_list           _ArgList
        )
    

#line 1689 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        int const _Result = __stdio_common_vsprintf_p(
            (*__local_stdio_printf_options()) | (1ULL << 1),
            0, 0, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1697 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"

     
    __inline int __cdecl _vscprintf_p(
            char const* const _Format,
                                      va_list           _ArgList
        )
    

#line 1706 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        return _vscprintf_p_l(_Format, 0, _ArgList);
    }
    #line 1710 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vsnprintf_c_l(
                   char*       const _Buffer,
                                             size_t      const _BufferCount,
            char const* const _Format,
                                         _locale_t   const _Locale,
                                                va_list           _ArgList
        )
    

#line 1722 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        int const _Result = __stdio_common_vsprintf(
            (*__local_stdio_printf_options()),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1730 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl _vsnprintf_c(
          char*       const _Buffer,
                                    size_t      const _BufferCount,
             char const* const _Format,
                                       va_list           _ArgList
        )
    

#line 1742 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        return _vsnprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    }
    #line 1746 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"

     
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_sprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _sprintf_l(
                  char*       const _Buffer,
            char const* const _Format,
                                         _locale_t   const _Locale,
        ...)
    

#line 1757 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));

        #pragma warning(push)
        #pragma warning(disable: 4996) 
        _Result = _vsprintf_l(_Buffer, _Format, _Locale, _ArgList);
        #pragma warning(pop)

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1771 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl sprintf(
           char*       const _Buffer,
               char const* const _Format,
        ...)
    

#line 1781 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));

        #pragma warning(push)
        #pragma warning(disable: 4996) 
        _Result = _vsprintf_l(_Buffer, _Format, 0, _ArgList);
        #pragma warning(pop)

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1795 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"

    #pragma warning(push)
    #pragma warning(disable: 4996)
    #pragma warning(disable: 28719) 
    #pragma warning(disable: 28726) 
    __declspec(deprecated("This function or variable may be unsafe. Consider using " "sprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))   int __cdecl sprintf(  char *_Buffer,  char const* _Format, ...); __declspec(deprecated("This function or variable may be unsafe. Consider using " "vsprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))   int __cdecl vsprintf(  char *_Buffer,  char const* _Format, va_list _Args);
#line 1807 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"
    #pragma warning(pop)

     
    
    __inline int __cdecl _sprintf_s_l(
           char*       const _Buffer,
                                                   size_t      const _BufferCount,
                  char const* const _Format,
                                               _locale_t   const _Locale,
        ...)
    

#line 1819 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vsprintf_s_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1828 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"

    

         
        
        __inline int __cdecl sprintf_s(
               char*       const _Buffer,
                                                       size_t      const _BufferCount,
                                char const* const _Format,
            ...)
    

#line 1841 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
            _Result = _vsprintf_s_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    #line 1850 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"

    #line 1852 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"

    extern "C++" { __pragma(warning(push)); __pragma(warning(disable: 4793)); template <size_t _Size> inline   int __cdecl sprintf_s( char (&_Buffer)[_Size],     char const* _Format, ...) throw() { va_list _ArgList; ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))); return vsprintf_s(_Buffer, _Size, _Format, _ArgList); } __pragma(warning(pop)); }
#line 1860 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl _sprintf_p_l(
           char*       const _Buffer,
                                                   size_t      const _BufferCount,
                  char const* const _Format,
                                               _locale_t   const _Locale,
        ...)
    

#line 1871 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vsprintf_p_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1880 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl _sprintf_p(
           char*       const _Buffer,
                                                   size_t      const _BufferCount,
                            char const* const _Format,
        ...)
    

#line 1891 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vsprintf_p_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1900 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"

     
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_snprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _snprintf_l(
            char*       const _Buffer,
                                                  size_t      const _BufferCount,
                 char const* const _Format,
                                              _locale_t   const _Locale,
        ...)
    

#line 1912 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));

        #pragma warning(push)
        #pragma warning(disable: 4996) 
        _Result = _vsnprintf_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        #pragma warning(pop)

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1926 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"

    








#line 1937 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl snprintf(
           char*       const _Buffer,
                                                       size_t      const _BufferCount,
                                char const* const _Format,
        ...)
    

#line 1948 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
    #pragma warning(suppress:28719)    
        _Result = vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1958 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl _snprintf(
            char*       const _Buffer,
                                                  size_t      const _BufferCount,
                           char const* const _Format,
        ...)
    

#line 1969 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
    #pragma warning(suppress:28719)    
        _Result = _vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1979 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_snprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))    int __cdecl _snprintf(    char *_Buffer,   size_t _BufferCount,     char const* _Format, ...); __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vsnprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))    int __cdecl _vsnprintf(    char *_Buffer,   size_t _BufferCount,     char const* _Format, va_list _Args);
#line 1989 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl _snprintf_c_l(
                   char*       const _Buffer,
                                             size_t      const _BufferCount,
            char const* const _Format,
                                         _locale_t   const _Locale,
        ...)
    

#line 2000 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vsnprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2009 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl _snprintf_c(
          char*       const _Buffer,
                                    size_t      const _BufferCount,
             char const* const _Format,
        ...)
    

#line 2020 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vsnprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2029 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl _snprintf_s_l(
           char*       const _Buffer,
                                                       size_t      const _BufferCount,
                                                       size_t      const _MaxCount,
                      char const* const _Format,
                                                   _locale_t   const _Locale,
        ...)
    

#line 2042 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2051 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl _snprintf_s(
           char*       const _Buffer,
                                                       size_t      const _BufferCount,
                                                       size_t      const _MaxCount,
                                char const* const _Format,
        ...)
    

#line 2063 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2072 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"

    extern "C++" { __pragma(warning(push)); __pragma(warning(disable: 4793)); template <size_t _Size> inline   int __cdecl _snprintf_s( char (&_Buffer)[_Size],   size_t _BufferCount,     char const* _Format, ...) throw() { va_list _ArgList; ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))); return _vsnprintf_s(_Buffer, _Size, _BufferCount, _Format, _ArgList); } __pragma(warning(pop)); }
#line 2081 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _scprintf_l(
            char const* const _Format,
                                         _locale_t   const _Locale,
        ...)
    

#line 2089 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vscprintf_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2098 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"

     
    __inline int __cdecl _scprintf(
            char const* const _Format,
        ...)
    

#line 2106 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vscprintf_l(_Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2115 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _scprintf_p_l(
            char const* const _Format,
                                         _locale_t   const _Locale,
        ...)
    

#line 2124 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vscprintf_p_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2133 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"

     
    __inline int __cdecl _scprintf_p(
            char const* const _Format,
        ...)
    

#line 2141 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vscprintf_p(_Format, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2150 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"

    
    
    
    
    
     int __cdecl __stdio_common_vsscanf(
                                            unsigned __int64 _Options,
                  char const*      _Buffer,
                                            size_t           _BufferCount,
            char const*      _Format,
                                        _locale_t        _Locale,
                                               va_list          _ArgList
        );

    
    __inline int __cdecl _vsscanf_l(
                                 char const* const _Buffer,
            char const* const _Format,
                               _locale_t   const _Locale,
                                      va_list           _ArgList
        )
    

#line 2175 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        return __stdio_common_vsscanf(
            (*__local_stdio_scanf_options ()),
            _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    }
    #line 2181 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"

    
    __inline int __cdecl vsscanf(
                                 char const* const _Buffer,
            char const* const _Format,
                                      va_list           _ArgList
        )
    

#line 2191 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        return _vsscanf_l(_Buffer, _Format, 0, _ArgList);
    }
    #line 2195 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vsscanf_s_l(
                                 char const* const _Buffer,
            char const* const _Format,
                               _locale_t   const _Locale,
                                      va_list           _ArgList
        )
    

#line 2206 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        return __stdio_common_vsscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0),
            _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    }
    #line 2212 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"

    

        #pragma warning(push)
        #pragma warning(disable:6530)

        
        __inline int __cdecl vsscanf_s(
                                     char const* const _Buffer,
                char const* const _Format,
                                          va_list           _ArgList
            )
    

#line 2227 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"
        {
            return _vsscanf_s_l(_Buffer, _Format, 0, _ArgList);
        }
    #line 2231 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"

        extern "C++" { template <size_t _Size> inline int __cdecl vsscanf_s(  char const (&_Buffer)[_Size],     char const* _Format, va_list _ArgList) throw() { return vsscanf_s(_Buffer, _Size, _Format, _ArgList); } }
#line 2239 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"

        #pragma warning(pop)

    #line 2242 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"

     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_sscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _sscanf_l(
                                          char const* const _Buffer,
            char const* const _Format,
                                        _locale_t   const _Locale,
        ...)
    

#line 2252 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vsscanf_l(_Buffer, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2261 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"

      __declspec(deprecated("This function or variable may be unsafe. Consider using " "sscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl sscanf(
                                char const* const _Buffer,
            char const* const _Format,
        ...)
    

#line 2270 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vsscanf_l(_Buffer, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2279 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _sscanf_s_l(
                                            char const* const _Buffer,
            char const* const _Format,
                                          _locale_t   const _Locale,
        ...)
    

#line 2289 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vsscanf_s_l(_Buffer, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2298 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"

    

        
        __inline int __cdecl sscanf_s(
                                      char const* const _Buffer,
                char const* const _Format,
            ...)
    

#line 2309 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));

            #pragma warning(push)
            #pragma warning(disable: 4996) 
            _Result = vsscanf_s(_Buffer, _Format, _ArgList);
            #pragma warning(pop)

            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    #line 2323 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"

    #line 2325 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"

    #pragma warning(push)
    #pragma warning(disable:6530)

     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_snscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _snscanf_l(
            char const* const _Buffer,
                                            size_t      const _BufferCount,
            char const* const _Format,
                                        _locale_t   const _Locale,
        ...)
    

#line 2339 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));

        _Result = __stdio_common_vsscanf(
            (*__local_stdio_scanf_options ()),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2352 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"

     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_snscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _snscanf(
            char const* const _Buffer,
                                            size_t      const _BufferCount,
                      char const* const _Format,
        ...)
    

#line 2362 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));

        _Result = __stdio_common_vsscanf(
            (*__local_stdio_scanf_options ()),
            _Buffer, _BufferCount, _Format, 0, _ArgList);

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2375 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"


    
    __inline int __cdecl _snscanf_s_l(
              char const* const _Buffer,
                                              size_t      const _BufferCount,
            char const* const _Format,
                                          _locale_t   const _Locale,
        ...)
    

#line 2387 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));

        _Result = __stdio_common_vsscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2400 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _snscanf_s(
            char const* const _Buffer,
                                            size_t      const _BufferCount,
                    char const* const _Format,
        ...)
    

#line 2410 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));

        _Result = __stdio_common_vsscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0),
            _Buffer, _BufferCount, _Format, 0, _ArgList);

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2423 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"

    #pragma warning(pop)

    

#line 2429 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"



    
    
    
    
    
    

        

        


#line 2445 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"

        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_tempnam" ". See online help for details."))
         char* __cdecl tempnam(
              char const* _Directory,
              char const* _FilePrefix
            );

        

#line 2455 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"

         __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_fcloseall" ". See online help for details."))  int   __cdecl fcloseall(void);
              __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_fdopen" ". See online help for details."))     FILE* __cdecl fdopen(  int _FileHandle,   char const* _Format);
         __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_fgetchar" ". See online help for details."))   int   __cdecl fgetchar(void);
              __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_fileno" ". See online help for details."))     int   __cdecl fileno(  FILE* _Stream);
         __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_flushall" ". See online help for details."))   int   __cdecl flushall(void);
         __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_fputchar" ". See online help for details."))   int   __cdecl fputchar(  int _Ch);
              __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_getw" ". See online help for details."))       int   __cdecl getw(  FILE* _Stream);
         __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_putw" ". See online help for details."))       int   __cdecl putw(  int _Ch,   FILE* _Stream);
              __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_rmtmp" ". See online help for details."))      int   __cdecl rmtmp(void);

    #line 2467 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"
#line 2468 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"



} __pragma(pack(pop))
#line 2473 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\stdio.h"
#line 13 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\cstdio"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4472 4494 4514 4571 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4702 4793 4820 4988 5026 5027 5045  4984 5053 )
















namespace std {
#pragma warning(push)
#pragma warning(disable : 4995) 

using :: FILE;
using :: _Mbstatet;

using :: size_t;
using :: fpos_t;
using :: FILE;
using :: clearerr;
using :: fclose;
using :: feof;
using :: ferror;
using :: fflush;
using :: fgetc;
using :: fgetpos;
using :: fgets;
using :: fopen;
using :: fprintf;
using :: fputc;
using :: fputs;
using :: fread;
using :: freopen;
using :: fscanf;
using :: fseek;
using :: fsetpos;
using :: ftell;
using :: fwrite;
using :: getc;
using :: getchar;
using :: perror;
using :: putc;
using :: putchar;
using :: printf;
using :: puts;
using :: remove;
using :: rename;
using :: rewind;
using :: scanf;
using :: setbuf;
using :: setvbuf;
using :: sprintf;
using :: sscanf;
using :: tmpfile;
using :: tmpnam;
using :: ungetc;
using :: vfprintf;
using :: vprintf;
using :: vsprintf;

using :: snprintf;
using :: vsnprintf;
using :: vfscanf;
using :: vscanf;
using :: vsscanf;

#pragma warning(pop)
}



#pragma warning(pop)
#pragma pack(pop)

#line 99 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\cstdio"
#line 100 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\cstdio"
#line 13 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\cwchar"
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\wchar.h"









#pragma once




#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_memcpy_s.h"







#pragma once


#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\errno.h"







#pragma once





__pragma(pack(push, 8)) extern "C" {




     int* __cdecl _errno(void);
    

     errno_t __cdecl _set_errno(  int _Value);
     errno_t __cdecl _get_errno(  int* _Value);

     unsigned long* __cdecl __doserrno(void);
    

     errno_t __cdecl _set_doserrno(  unsigned long _Value);
     errno_t __cdecl _get_doserrno(  unsigned long * _Value);
#line 31 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\errno.h"










































    
    
    
    
    
#line 79 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\errno.h"






    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
#line 127 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\errno.h"



} __pragma(pack(pop))
#line 132 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\errno.h"
#line 12 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_memcpy_s.h"
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\vcruntime_string.h"







#pragma once





__pragma(pack(push, 8)) extern "C" {



[[nodiscard]]  
 void const* __cdecl memchr(
      void const* _Buf,
                                 int         _Val,
                                 size_t      _MaxCount
    );

[[nodiscard]]  
int __cdecl memcmp(
      void const* _Buf1,
      void const* _Buf2,
                         size_t      _Size
    );


 

#line 41 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\vcruntime_string.h"
void* __cdecl memcpy(
      void* _Dst,
            void const* _Src,
                               size_t      _Size
    );


 void* __cdecl memmove(
      void*       _Dst,
            void const* _Src,
                                   size_t      _Size
    );

 

#line 61 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\vcruntime_string.h"
void* __cdecl memset(
      void*  _Dst,
                               int    _Val,
                               size_t _Size
    );

[[nodiscard]]  
 char const* __cdecl strchr(
      char const* _Str,
        int         _Val
    );

[[nodiscard]]  
 char const* __cdecl strrchr(
      char const* _Str,
        int         _Ch
    );

[[nodiscard]]    
 char const* __cdecl strstr(
      char const* _Str,
      char const* _SubStr
    );

[[nodiscard]]  

 wchar_t const* __cdecl wcschr(
      wchar_t const* _Str,
        wchar_t        _Ch
    );

[[nodiscard]]  
 wchar_t const* __cdecl wcsrchr(
      wchar_t const* _Str,
        wchar_t        _Ch
    );

[[nodiscard]]    

 wchar_t const* __cdecl wcsstr(
      wchar_t const* _Str,
      wchar_t const* _SubStr
    );



} __pragma(pack(pop))

#line 109 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\vcruntime_string.h"
#line 13 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_memcpy_s.h"

__pragma(pack(push, 8)) extern "C" {


    
#line 19 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_memcpy_s.h"














     
    
    static __inline errno_t __cdecl memcpy_s(
          void*       const _Destination,
                                                              rsize_t     const _DestinationSize,
                                 void const* const _Source,
                                                              rsize_t     const _SourceSize
        )
    {
        if (_SourceSize == 0)
        {
            return 0;
        }

        { int _Expr_val=!!(_Destination != 0); if (!(_Expr_val)) { (*_errno()) = 22; _invalid_parameter_noinfo(); return 22; } };
        if (_Source == 0 || _DestinationSize < _SourceSize)
        {
            memset(_Destination, 0, _DestinationSize);

            { int _Expr_val=!!(_Source != 0); if (!(_Expr_val)) { (*_errno()) = 22; _invalid_parameter_noinfo(); return 22; } };
            { int _Expr_val=!!(_DestinationSize >= _SourceSize); if (!(_Expr_val)) { (*_errno()) = 34; _invalid_parameter_noinfo(); return 34; } };

            
            return 22;
        }
#pragma warning(suppress:4996) 
        memcpy(_Destination, _Source, _SourceSize);
        return 0;
    }

    
    static __inline errno_t __cdecl memmove_s(
          void*       const _Destination,
                                                              rsize_t     const _DestinationSize,
                                 void const* const _Source,
                                                              rsize_t     const _SourceSize
        )
    {
        if (_SourceSize == 0)
        {
            return 0;
        }

        { int _Expr_val=!!(_Destination != 0); if (!(_Expr_val)) { (*_errno()) = 22; _invalid_parameter_noinfo(); return 22; } };
        { int _Expr_val=!!(_Source != 0); if (!(_Expr_val)) { (*_errno()) = 22; _invalid_parameter_noinfo(); return 22; } };
        { int _Expr_val=!!(_DestinationSize >= _SourceSize); if (!(_Expr_val)) { (*_errno()) = 34; _invalid_parameter_noinfo(); return 34; } };

#pragma warning(suppress:4996) 
        memmove(_Destination, _Source, _SourceSize);
        return 0;
    }

#line 86 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_memcpy_s.h"



} __pragma(pack(pop))
#line 16 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\wchar.h"
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wconio.h"








#pragma once




__pragma(pack(push, 8)) extern "C" {









    
     
     errno_t __cdecl _cgetws_s(
          wchar_t* _Buffer,
                                               size_t   _BufferCount,
                                              size_t*  _SizeRead
        );

    extern "C++" { template <size_t _Size> inline   errno_t __cdecl _cgetws_s(  wchar_t (&_Buffer)[_Size],   size_t* _SizeRead) throw() { return _cgetws_s(_Buffer, _Size, _SizeRead); } }
#line 39 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wconio.h"

    
     int __cdecl _cputws(
          wchar_t const* _Buffer
        );

           wint_t __cdecl _getwch  (void);
           wint_t __cdecl _getwche (void);
      wint_t __cdecl _putwch  (  wchar_t _Character);
      wint_t __cdecl _ungetwch(  wint_t  _Character);

           wint_t __cdecl _getwch_nolock  (void);
           wint_t __cdecl _getwche_nolock (void);
      wint_t __cdecl _putwch_nolock  (  wchar_t _Character);
      wint_t __cdecl _ungetwch_nolock(  wint_t  _Character);



    
    
    
    
    
    
     int __cdecl __conio_common_vcwprintf(
                                             unsigned __int64 _Options,
            wchar_t const*   _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

    
     int __cdecl __conio_common_vcwprintf_s(
                                             unsigned __int64 _Options,
            wchar_t const*   _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

    
     int __cdecl __conio_common_vcwprintf_p(
                                             unsigned __int64 _Options,
            wchar_t const*   _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

    
    __inline int __cdecl _vcwprintf_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )


#line 94 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wconio.h"
    {
        return __conio_common_vcwprintf((*__local_stdio_printf_options()), _Format, _Locale, _ArgList);
    }
#line 98 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _vcwprintf(
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )


#line 107 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wconio.h"
    {
        return _vcwprintf_l(_Format, 0, _ArgList);
    }
#line 111 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _vcwprintf_s_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )


#line 121 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wconio.h"
    {
        return __conio_common_vcwprintf_s((*__local_stdio_printf_options()), _Format, _Locale, _ArgList);
    }
#line 125 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _vcwprintf_s(
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )


#line 134 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wconio.h"
    {
        return _vcwprintf_s_l(_Format, 0, _ArgList);
    }
#line 138 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _vcwprintf_p_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )


#line 148 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wconio.h"
    {
        return __conio_common_vcwprintf_p((*__local_stdio_printf_options()), _Format, _Locale, _ArgList);
    }
#line 152 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _vcwprintf_p(
            const wchar_t* const _Format,
                                      va_list              _ArgList
        )


#line 161 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wconio.h"
    {
        return _vcwprintf_p_l(_Format, 0, _ArgList);
    }
#line 165 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _cwprintf_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)


#line 174 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vcwprintf_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 183 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _cwprintf(
            wchar_t const* const _Format,
        ...)


#line 191 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vcwprintf_l(_Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 200 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _cwprintf_s_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)


#line 209 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vcwprintf_s_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 218 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _cwprintf_s(
            wchar_t const* const _Format,
        ...)


#line 226 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vcwprintf_s_l(_Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 235 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _cwprintf_p_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)


#line 244 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vcwprintf_p_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 253 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _cwprintf_p(
            wchar_t const* const _Format,
        ...)


#line 261 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vcwprintf_p_l(_Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 270 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wconio.h"



    
    
    
    
    
    
     int __cdecl __conio_common_vcwscanf(
                                            unsigned __int64 _Options,
            wchar_t const*   _Format,
                                        _locale_t        _Locale,
                                               va_list          _ArgList
        );

     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vcwscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _vcwscanf_l(
            wchar_t const* const _Format,
                                        _locale_t      const _Locale,
                                               va_list              _ArgList
        )


#line 295 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wconio.h"
    {
        return __conio_common_vcwscanf(
            (*__local_stdio_scanf_options ()),
            _Format, _Locale, _ArgList);
    }
#line 301 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wconio.h"

     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vcwscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _vcwscanf(
            wchar_t const* const _Format,
                                               va_list              _ArgList
        )


#line 310 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wconio.h"
    {
        #pragma warning(push)
        #pragma warning(disable: 4996) 
        return _vcwscanf_l(_Format, 0, _ArgList);
        #pragma warning(pop)
    }
#line 317 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _vcwscanf_s_l(
            wchar_t const* const _Format,
                                        _locale_t      const _Locale,
                                               va_list              _ArgList
        )


#line 327 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wconio.h"
    {
        return __conio_common_vcwscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0),
            _Format, _Locale, _ArgList);
    }
#line 333 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _vcwscanf_s(
            wchar_t const* const _Format,
                                               va_list              _ArgList
        )


#line 342 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wconio.h"
    {
        return _vcwscanf_s_l(_Format, 0, _ArgList);
    }
#line 346 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wconio.h"

     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_cwscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _cwscanf_l(
            wchar_t const* const _Format,
                                        _locale_t      const _Locale,
        ...)


#line 355 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));

        #pragma warning(push)
        #pragma warning(disable: 4996) 
        _Result = _vcwscanf_l(_Format, _Locale, _ArgList);
        #pragma warning(pop)

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 369 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wconio.h"

     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_cwscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _cwscanf(
            wchar_t const* const _Format,
        ...)


#line 377 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));

        #pragma warning(push)
        #pragma warning(disable: 4996) 
        _Result = _vcwscanf_l(_Format, 0, _ArgList);
        #pragma warning(pop)

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 391 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _cwscanf_s_l(
            wchar_t const* const _Format,
                                        _locale_t      const _Locale,
        ...)


#line 400 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vcwscanf_s_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 409 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _cwscanf_s(
            wchar_t const* const _Format,
        ...)


#line 417 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vcwscanf_s_l(_Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 426 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wconio.h"

#line 428 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wconio.h"



} __pragma(pack(pop))
#line 17 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\wchar.h"
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wctype.h"








#pragma once



__pragma(pack(push, 8)) extern "C" {











    

#line 28 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wctype.h"
        
    #line 30 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wctype.h"

     const unsigned short* __cdecl __pctype_func(void);
     const wctype_t*       __cdecl __pwctype_func(void);

    



        
        
    #line 41 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wctype.h"
#line 42 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wctype.h"





















   int __cdecl iswalnum  (  wint_t _C);
   int __cdecl iswalpha  (  wint_t _C);
   int __cdecl iswascii  (  wint_t _C);
   int __cdecl iswblank  (  wint_t _C);
   int __cdecl iswcntrl  (  wint_t _C);


   int __cdecl iswdigit  (  wint_t _C);

   int __cdecl iswgraph  (  wint_t _C);
   int __cdecl iswlower  (  wint_t _C);
   int __cdecl iswprint  (  wint_t _C);
   int __cdecl iswpunct  (  wint_t _C);
   int __cdecl iswspace  (  wint_t _C);
   int __cdecl iswupper  (  wint_t _C);
   int __cdecl iswxdigit (  wint_t _C);
   int __cdecl __iswcsymf(  wint_t _C);
   int __cdecl __iswcsym (  wint_t _C);

   int __cdecl _iswalnum_l (  wint_t _C,   _locale_t _Locale);
   int __cdecl _iswalpha_l (  wint_t _C,   _locale_t _Locale);
   int __cdecl _iswblank_l (  wint_t _C,   _locale_t _Locale);
   int __cdecl _iswcntrl_l (  wint_t _C,   _locale_t _Locale);
   int __cdecl _iswdigit_l (  wint_t _C,   _locale_t _Locale);
   int __cdecl _iswgraph_l (  wint_t _C,   _locale_t _Locale);
   int __cdecl _iswlower_l (  wint_t _C,   _locale_t _Locale);
   int __cdecl _iswprint_l (  wint_t _C,   _locale_t _Locale);
   int __cdecl _iswpunct_l (  wint_t _C,   _locale_t _Locale);
   int __cdecl _iswspace_l (  wint_t _C,   _locale_t _Locale);
   int __cdecl _iswupper_l (  wint_t _C,   _locale_t _Locale);
   int __cdecl _iswxdigit_l(  wint_t _C,   _locale_t _Locale);
   int __cdecl _iswcsymf_l (  wint_t _C,   _locale_t _Locale);
   int __cdecl _iswcsym_l  (  wint_t _C,   _locale_t _Locale);


   wint_t __cdecl towupper(  wint_t _C);
   wint_t __cdecl towlower(  wint_t _C);
   int    __cdecl iswctype(  wint_t _C,   wctype_t _Type);

   wint_t __cdecl _towupper_l(  wint_t _C,   _locale_t _Locale);
   wint_t __cdecl _towlower_l(  wint_t _C,   _locale_t _Locale);
   int    __cdecl _iswctype_l(  wint_t _C,   wctype_t _Type,   _locale_t _Locale);



       int __cdecl isleadbyte(  int _C);
       int __cdecl _isleadbyte_l(  int _C,   _locale_t _Locale);

    __declspec(deprecated("This function or variable has been superceded by newer library " "or operating system functionality. Consider using " "iswctype" " " "instead. See online help for details."))  int __cdecl is_wctype(  wint_t _C,   wctype_t _Type);
#line 113 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wctype.h"


















































































#line 196 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wctype.h"



} __pragma(pack(pop))
#line 18 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\wchar.h"
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wdirect.h"








#pragma once



__pragma(pack(push, 8)) extern "C" {






 
   
 __declspec(allocator) wchar_t* __cdecl _wgetcwd(
      wchar_t* _DstBuf,
                                  int      _SizeInWords
    );

 
   
 __declspec(allocator) wchar_t* __cdecl _wgetdcwd(
                                  int      _Drive,
      wchar_t* _DstBuf,
                                  int      _SizeInWords
    );






 
 int __cdecl _wchdir(
      wchar_t const* _Path
    );

 
 int __cdecl _wmkdir(
      wchar_t const* _Path
    );

 
 int __cdecl _wrmdir(
      wchar_t const* _Path
    );



} __pragma(pack(pop))
#line 19 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\wchar.h"
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wio.h"








#pragma once


#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_share.h"








#pragma once












    
    
    
    
#line 27 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_share.h"
#line 13 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wio.h"

__pragma(pack(push, 8)) extern "C" {


#pragma warning(push)
#pragma warning(disable:4820) 











    
    
#line 33 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wio.h"

typedef unsigned long _fsize_t;

struct _wfinddata32_t
{
    unsigned   attrib;
    __time32_t time_create;    
    __time32_t time_access;    
    __time32_t time_write;
    _fsize_t   size;
    wchar_t    name[260];
};

struct _wfinddata32i64_t
{
    unsigned   attrib;
    __time32_t time_create;    
    __time32_t time_access;    
    __time32_t time_write;
    __int64    size;
    wchar_t    name[260];
};

struct _wfinddata64i32_t
{
    unsigned   attrib;
    __time64_t time_create;    
    __time64_t time_access;    
    __time64_t time_write;
    _fsize_t   size;
    wchar_t    name[260];
};

struct _wfinddata64_t
{
    unsigned   attrib;
    __time64_t time_create;    
    __time64_t time_access;    
    __time64_t time_write;
    __int64    size;
    wchar_t    name[260];
};














    
    
    
    
#line 94 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wio.h"

 
 int __cdecl _waccess(
      wchar_t const* _FileName,
        int            _AccessMode
    );


 errno_t __cdecl _waccess_s(
      wchar_t const* _FileName,
        int            _AccessMode
    );

 
 int __cdecl _wchmod(
      wchar_t const* _FileName,
        int            _Mode
    );

  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wsopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
 int __cdecl _wcreat(
      wchar_t const* _FileName,
        int            _PermissionMode
    );

 
 
 intptr_t __cdecl _wfindfirst32(
      wchar_t const*         _FileName,
       struct _wfinddata32_t* _FindData
    );

 
 
 int __cdecl _wfindnext32(
       intptr_t               _FindHandle,
      struct _wfinddata32_t* _FindData
    );

 int __cdecl _wunlink(
      wchar_t const* _FileName
    );

 
 int __cdecl _wrename(
      wchar_t const* _OldFileName,
      wchar_t const* _NewFileName
    );

 errno_t __cdecl _wmktemp_s(
      wchar_t* _TemplateName,
                                 size_t   _SizeInWords
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wmktemp_s(wchar_t (&_TemplateName)[_Size]) throw() { return _wmktemp_s(_TemplateName, _Size); } }
#line 153 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wio.h"

 
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wmktemp_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  wchar_t* __cdecl _wmktemp( wchar_t *_TemplateName);
#line 159 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wio.h"

 
 
 intptr_t __cdecl _wfindfirst32i64(
      wchar_t const*            _FileName,
       struct _wfinddata32i64_t* _FindData
    );

 
 
 intptr_t __cdecl _wfindfirst64i32(
      wchar_t const*            _FileName,
       struct _wfinddata64i32_t* _FindData
    );

 
 
 intptr_t __cdecl _wfindfirst64(
      wchar_t const*         _FileName,
       struct _wfinddata64_t* _FindData
    );

 
 
 int __cdecl _wfindnext32i64(
       intptr_t                  _FindHandle,
      struct _wfinddata32i64_t* _FindData
    );

 
 
 int __cdecl _wfindnext64i32(
       intptr_t                  _FindHandle,
      struct _wfinddata64i32_t* _FindData
    );

 
 
 int __cdecl _wfindnext64(
       intptr_t               _FindHandle,
      struct _wfinddata64_t* _FindData
    );


 errno_t __cdecl _wsopen_s(
       int*           _FileHandle,
      wchar_t const* _FileName,
        int            _OpenFlag,
        int            _ShareFlag,
        int            _PermissionFlag
    );

 errno_t __cdecl _wsopen_dispatch(
      wchar_t const* _FileName,
        int            _OFlag,
        int            _ShFlag,
        int            _PMode,
       int*           _PFileHandle,
        int            _BSecure
    );





    
    extern "C++"   __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wsopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    inline int __cdecl _wopen(
          wchar_t const* _FileName,
            int            _OFlag,
            int            _PMode = 0
        )
    {
        int _FileHandle;
        
        errno_t const _Result = _wsopen_dispatch(_FileName, _OFlag, 0x40, _PMode, &_FileHandle, 0);
        return _Result ? -1 : _FileHandle;
    }

    extern "C++"   __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wsopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    inline int __cdecl _wsopen(
          wchar_t const* _FileName,
            int            _OFlag,
            int            _ShFlag,
            int            _PMode = 0
        )
    {
        int _FileHandle;
        
        errno_t const _Result = _wsopen_dispatch(_FileName, _OFlag, _ShFlag, _PMode, &_FileHandle, 0);
        return _Result ? -1 : _FileHandle;
    }

















#line 268 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wio.h"


#pragma warning(pop)


} __pragma(pack(pop))
#line 20 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\wchar.h"
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wprocess.h"








#pragma once



__pragma(pack(push, 8)) extern "C" {




    

         intptr_t __cdecl _wexecl(
              wchar_t const* _FileName,
              wchar_t const* _ArgList,
            ...);

         intptr_t __cdecl _wexecle(
              wchar_t const* _FileName,
              wchar_t const* _ArgList,
            ...);

         intptr_t __cdecl _wexeclp(
              wchar_t const* _FileName,
              wchar_t const* _ArgList,
            ...);

         intptr_t __cdecl _wexeclpe(
              wchar_t const* _FileName,
              wchar_t const* _ArgList,
            ...);

         intptr_t __cdecl _wexecv(
              wchar_t const*        _FileName,
              wchar_t const* const* _ArgList
            );

         intptr_t __cdecl _wexecve(
                  wchar_t const*        _FileName,
                  wchar_t const* const* _ArgList,
              wchar_t const* const* _Env
            );

         intptr_t __cdecl _wexecvp(
              wchar_t const*        _FileName,
              wchar_t const* const* _ArgList
            );

         intptr_t __cdecl _wexecvpe(
                  wchar_t const*        _FileName,
                  wchar_t const* const* _ArgList,
              wchar_t const* const* _Env
            );

         intptr_t __cdecl _wspawnl(
                int            _Mode,
              wchar_t const* _FileName,
              wchar_t const* _ArgList,
            ...);

         intptr_t __cdecl _wspawnle(
                int            _Mode,
              wchar_t const* _FileName,
              wchar_t const* _ArgList,
            ...);

         intptr_t __cdecl _wspawnlp(
                int            _Mode,
              wchar_t const* _FileName,
              wchar_t const* _ArgList,
            ...);

         intptr_t __cdecl _wspawnlpe(
                int            _Mode,
              wchar_t const* _FileName,
              wchar_t const* _ArgList,
            ...);

         intptr_t __cdecl _wspawnv(
                int                   _Mode,
              wchar_t const*        _FileName,
              wchar_t const* const* _ArgList
            );

         intptr_t __cdecl _wspawnve(
                    int                   _Mode,
                  wchar_t const*        _FileName,
                  wchar_t const* const* _ArgList,
              wchar_t const* const* _Env
            );

         intptr_t __cdecl _wspawnvp(
                int                   _Mode,
              wchar_t const*        _FileName,
              wchar_t const* const* _ArgList
            );

         intptr_t __cdecl _wspawnvpe(
                    int                   _Mode,
                  wchar_t const*        _FileName,
                  wchar_t const* const* _ArgList,
              wchar_t const* const* _Env
            );

         int __cdecl _wsystem(
              wchar_t const* _Command
            );

    #line 117 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wprocess.h"
#line 118 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wprocess.h"



} __pragma(pack(pop))
#line 21 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\wchar.h"


#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstring.h"








#pragma once






__pragma(pack(push, 8)) extern "C" {










    
     errno_t __cdecl wcscat_s(
          wchar_t* _Destination,
          rsize_t _SizeInWords,
          wchar_t const* _Source
        );

    
     errno_t __cdecl wcscpy_s(
          wchar_t* _Destination,
          rsize_t _SizeInWords,
          wchar_t const* _Source
        );

    
     errno_t __cdecl wcsncat_s(
          wchar_t*       _Destination,
                                     rsize_t        _SizeInWords,
               wchar_t const* _Source,
                                     rsize_t        _MaxCount
        );

    
     errno_t __cdecl wcsncpy_s(
          wchar_t*       _Destination,
                                  rsize_t        _SizeInWords,
            wchar_t const* _Source,
                                  rsize_t        _MaxCount
        );

     
     wchar_t* __cdecl wcstok_s(
                          wchar_t*       _String,
                                 wchar_t const* _Delimiter,
            wchar_t**      _Context
        );

#line 65 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstring.h"











#line 77 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstring.h"

 
 __declspec(allocator) wchar_t* __cdecl _wcsdup(
      wchar_t const* _String
    );



#line 86 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstring.h"



extern "C++" { template <size_t _Size> inline errno_t __cdecl wcscat_s(wchar_t (&_Destination)[_Size],   wchar_t const* _Source) throw() { return wcscat_s(_Destination, _Size, _Source); } }
#line 95 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstring.h"



#pragma warning(push)
#pragma warning(disable: 28719) 
#pragma warning(disable: 28726) 
    __declspec(deprecated("This function or variable may be unsafe. Consider using " "wcscat_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  wchar_t* __cdecl wcscat( wchar_t *_Destination,  wchar_t const* _Source);
#line 106 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstring.h"
#pragma warning(pop)
#line 107 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstring.h"

 
 int __cdecl wcscmp(
      wchar_t const* _String1,
      wchar_t const* _String2
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl wcscpy_s(wchar_t (&_Destination)[_Size],   wchar_t const* _Source) throw() { return wcscpy_s(_Destination, _Size, _Source); } }
#line 120 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstring.h"

#pragma warning(push)
#pragma warning(disable: 28719) 
#pragma warning(disable: 28726) 
__declspec(deprecated("This function or variable may be unsafe. Consider using " "wcscpy_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  wchar_t* __cdecl wcscpy( wchar_t *_Destination,  wchar_t const* _Source);
#line 129 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstring.h"
#pragma warning(pop)

 
 size_t __cdecl wcscspn(
      wchar_t const* _String,
      wchar_t const* _Control
    );

 
 size_t __cdecl wcslen(
      wchar_t const* _String
    );

 

#line 147 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstring.h"

#line 151 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstring.h"
 size_t __cdecl wcsnlen(
      wchar_t const* _Source,
                            size_t         _MaxCount
    );



     
    
#line 163 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstring.h"
    
#line 167 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstring.h"
    static __inline size_t __cdecl wcsnlen_s(
          wchar_t const* _Source,
                                size_t         _MaxCount
        )
    {
        return (_Source == 0) ? 0 : wcsnlen(_Source, _MaxCount);
    }

#line 175 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstring.h"

extern "C++" { template <size_t _Size> inline errno_t __cdecl wcsncat_s(  wchar_t (&_Destination)[_Size],   wchar_t const* _Source,   size_t _Count) throw() { return wcsncat_s(_Destination, _Size, _Source, _Count); } }
#line 183 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstring.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "wcsncat_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  wchar_t* __cdecl wcsncat(  wchar_t *_Destination,   wchar_t const* _Source,   size_t _Count);
#line 191 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstring.h"

 
 int __cdecl wcsncmp(
      wchar_t const* _String1,
      wchar_t const* _String2,
                            size_t         _MaxCount
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl wcsncpy_s(wchar_t (&_Destination)[_Size],   wchar_t const* _Source,   size_t _Count) throw() { return wcsncpy_s(_Destination, _Size, _Source, _Count); } }
#line 205 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstring.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "wcsncpy_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  wchar_t* __cdecl wcsncpy(    wchar_t *_Destination,   wchar_t const* _Source,   size_t _Count);
#line 213 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstring.h"

 
 wchar_t const* __cdecl wcspbrk(
      wchar_t const* _String,
      wchar_t const* _Control
    );

 
 size_t __cdecl wcsspn(
      wchar_t const* _String,
      wchar_t const* _Control
    );

  __declspec(deprecated("This function or variable may be unsafe. Consider using " "wcstok_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
 wchar_t* __cdecl wcstok(
                          wchar_t*       _String,
                                 wchar_t const* _Delimiter,
        wchar_t**      _Context
    );



    

#line 237 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstring.h"
        



    #line 242 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstring.h"

    #pragma warning(push)
    #pragma warning(disable: 4141 4996) 
    #pragma warning(disable: 28719 28726 28727) 
      __declspec(deprecated("This function or variable may be unsafe. Consider using " "wcstok_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    static __inline wchar_t* __cdecl _wcstok(
          wchar_t*       const _String,
                 wchar_t const* const _Delimiter
        )
    {
        return wcstok(_String, _Delimiter, 0);
    }

    

#line 258 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstring.h"

    
        extern "C++"   __declspec(deprecated("wcstok has been changed to conform with the ISO C standard, " "adding an extra context parameter. To use the legacy Microsoft " "wcstok, define _CRT_NON_CONFORMING_WCSTOK."))
        inline wchar_t* __cdecl wcstok(
              wchar_t*       _String,
                     wchar_t const* _Delimiter
            ) throw()
        {
            return wcstok(_String, _Delimiter, 0);
        }
    #line 269 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstring.h"

    #pragma warning(pop)

#line 273 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstring.h"



 
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcserror_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
 wchar_t* __cdecl _wcserror(
      int _ErrorNumber
    );


 errno_t __cdecl _wcserror_s(
      wchar_t* _Buffer,
                                  size_t   _SizeInWords,
                                  int      _ErrorNumber
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcserror_s(wchar_t (&_Buffer)[_Size],   int _Error) throw() { return _wcserror_s(_Buffer, _Size, _Error); } }
#line 295 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstring.h"

 
 
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "__wcserror_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
 wchar_t* __cdecl __wcserror(
      wchar_t const* _String
    );

  errno_t __cdecl __wcserror_s(
      wchar_t*       _Buffer,
                                  size_t         _SizeInWords,
                                wchar_t const* _ErrorMessage
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl __wcserror_s(wchar_t (&_Buffer)[_Size],   wchar_t const* _ErrorMessage) throw() { return __wcserror_s(_Buffer, _Size, _ErrorMessage); } }
#line 314 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstring.h"

   int __cdecl _wcsicmp(
      wchar_t const* _String1,
      wchar_t const* _String2
    );

   int __cdecl _wcsicmp_l(
        wchar_t const* _String1,
        wchar_t const* _String2,
      _locale_t      _Locale
    );

   int __cdecl _wcsnicmp(
      wchar_t const* _String1,
      wchar_t const* _String2,
                            size_t         _MaxCount
    );

   int __cdecl _wcsnicmp_l(
      wchar_t const* _String1,
      wchar_t const* _String2,
                            size_t         _MaxCount,
                        _locale_t      _Locale
    );

  errno_t __cdecl _wcsnset_s(
      wchar_t* _Destination,
                                 size_t   _SizeInWords,
                                 wchar_t  _Value,
                                 size_t   _MaxCount
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcsnset_s(  wchar_t (&_Destination)[_Size],   wchar_t _Value,   size_t _MaxCount) throw() { return _wcsnset_s(_Destination, _Size, _Value, _MaxCount); } }
#line 352 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstring.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcsnset_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  wchar_t* __cdecl _wcsnset(  wchar_t *_String,   wchar_t _Value,   size_t _MaxCount);
#line 360 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstring.h"

 wchar_t* __cdecl _wcsrev(
      wchar_t* _String
    );

  errno_t __cdecl _wcsset_s(
      wchar_t* _Destination,
                                 size_t   _SizeInWords,
                                 wchar_t  _Value
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcsset_s(  wchar_t (&_String)[_Size],   wchar_t _Value) throw() { return _wcsset_s(_String, _Size, _Value); } }
#line 376 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstring.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcsset_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  wchar_t* __cdecl _wcsset(  wchar_t *_String,   wchar_t _Value);
#line 383 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstring.h"

  errno_t __cdecl _wcslwr_s(
      wchar_t* _String,
                                 size_t   _SizeInWords
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcslwr_s(  wchar_t (&_String)[_Size]) throw() { return _wcslwr_s(_String, _Size); } }
#line 393 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstring.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcslwr_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  wchar_t* __cdecl _wcslwr( wchar_t *_String);
#line 398 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstring.h"


 errno_t __cdecl _wcslwr_s_l(
      wchar_t*  _String,
                                 size_t    _SizeInWords,
                             _locale_t _Locale
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcslwr_s_l(  wchar_t (&_String)[_Size],   _locale_t _Locale) throw() { return _wcslwr_s_l(_String, _Size, _Locale); } }
#line 411 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstring.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcslwr_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  wchar_t* __cdecl _wcslwr_l(  wchar_t *_String,   _locale_t _Locale);
#line 418 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstring.h"


 errno_t __cdecl _wcsupr_s(
      wchar_t* _String,
                          size_t   _Size
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcsupr_s(  wchar_t (&_String)[_Size]) throw() { return _wcsupr_s(_String, _Size); } }
#line 429 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstring.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcsupr_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  wchar_t* __cdecl _wcsupr( wchar_t *_String);
#line 434 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstring.h"


 errno_t __cdecl _wcsupr_s_l(
      wchar_t*  _String,
                          size_t    _Size,
                      _locale_t _Locale
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcsupr_s_l(  wchar_t (&_String)[_Size],   _locale_t _Locale) throw() { return _wcsupr_s_l(_String, _Size, _Locale); } }
#line 447 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstring.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcsupr_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  wchar_t* __cdecl _wcsupr_l(  wchar_t *_String,   _locale_t _Locale);
#line 454 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstring.h"

 

 size_t __cdecl wcsxfrm(
        wchar_t*       _Destination,
                                         wchar_t const* _Source,
                size_t         _MaxCount
    );

 

 size_t __cdecl _wcsxfrm_l(
        wchar_t*       _Destination,
                                         wchar_t const* _Source,
                size_t         _MaxCount,
                                       _locale_t      _Locale
    );

 
 int __cdecl wcscoll(
      wchar_t const* _String1,
      wchar_t const* _String2
    );

 
 int __cdecl _wcscoll_l(
        wchar_t const* _String1,
        wchar_t const* _String2,
      _locale_t      _Locale
    );

 
 int __cdecl _wcsicoll(
      wchar_t const* _String1,
      wchar_t const* _String2
    );

 
 int __cdecl _wcsicoll_l(
        wchar_t const* _String1,
        wchar_t const* _String2,
      _locale_t      _Locale
    );

 
 int __cdecl _wcsncoll(
      wchar_t const* _String1,
      wchar_t const* _String2,
                            size_t         _MaxCount
    );

 
 int __cdecl _wcsncoll_l(
      wchar_t const* _String1,
      wchar_t const* _String2,
                            size_t         _MaxCount,
                        _locale_t      _Locale
    );

 
 int __cdecl _wcsnicoll(
      wchar_t const* _String1,
      wchar_t const* _String2,
                            size_t         _MaxCount
    );

 
 int __cdecl _wcsnicoll_l(
      wchar_t const* _String1,
      wchar_t const* _String2,
                            size_t         _MaxCount,
                        _locale_t      _Locale
    );









extern "C++" {

     
    
    inline wchar_t* __cdecl wcschr(  wchar_t* _String, wchar_t _C)
    {
        return const_cast<wchar_t*>(wcschr(static_cast<wchar_t const*>(_String), _C));
    }

     
    inline wchar_t* __cdecl wcspbrk(  wchar_t* _String,   wchar_t const* _Control)
    {
        return const_cast<wchar_t*>(wcspbrk(static_cast<wchar_t const*>(_String), _Control));
    }

     
    inline wchar_t* __cdecl wcsrchr(  wchar_t* _String,   wchar_t _C)
    {
        return const_cast<wchar_t*>(wcsrchr(static_cast<wchar_t const*>(_String), _C));
    }

       
    
    inline wchar_t* __cdecl wcsstr(  wchar_t* _String,   wchar_t const*_SubStr)
    {
        return const_cast<wchar_t*>(wcsstr(static_cast<wchar_t const*>(_String), _SubStr));
    }

}
#line 565 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstring.h"









    


#line 578 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstring.h"

      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsdup" ". See online help for details."))
     wchar_t* __cdecl wcsdup(
          wchar_t const* _String
        );

    

#line 587 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstring.h"

    
    

      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsicmp" ". See online help for details."))
     int __cdecl wcsicmp(
          wchar_t const* _String1,
          wchar_t const* _String2
        );

      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsnicmp" ". See online help for details."))
     int __cdecl wcsnicmp(
          wchar_t const* _String1,
          wchar_t const* _String2,
                                size_t         _MaxCount
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsnset" ". See online help for details."))
     
     wchar_t* __cdecl wcsnset(
          wchar_t* _String,
                                  wchar_t  _Value,
                                  size_t   _MaxCount
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsrev" ". See online help for details."))
     
     wchar_t* __cdecl wcsrev(
          wchar_t* _String
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsset" ". See online help for details."))
     
     wchar_t* __cdecl wcsset(
          wchar_t* _String,
               wchar_t  _Value
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcslwr" ". See online help for details."))
     
     wchar_t* __cdecl wcslwr(
          wchar_t* _String
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsupr" ". See online help for details."))
     
     wchar_t* __cdecl wcsupr(
          wchar_t* _String
        );

      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsicoll" ". See online help for details."))
     int __cdecl wcsicoll(
          wchar_t const* _String1,
          wchar_t const* _String2
        );

#line 644 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstring.h"



} __pragma(pack(pop))

#line 650 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wstring.h"
#line 24 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\wchar.h"
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wtime.h"








#pragma once



__pragma(pack(push, 8)) extern "C" {








struct tm
{
    int tm_sec;   
    int tm_min;   
    int tm_hour;  
    int tm_mday;  
    int tm_mon;   
    int tm_year;  
    int tm_wday;  
    int tm_yday;  
    int tm_isdst; 
};







  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wasctime_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
 
 
 wchar_t* __cdecl _wasctime(
      struct tm const* _Tm
    );

 

 errno_t __cdecl _wasctime_s(
        wchar_t*         _Buffer,
                                          size_t           _SizeInWords,
                                                       struct tm const* _Tm
    );

extern "C++" { template <size_t _Size> inline   errno_t __cdecl _wasctime_s(  wchar_t (&_Buffer)[_Size],   struct tm const* _Time) throw() { return _wasctime_s(_Buffer, _Size, _Time); } }
#line 63 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wtime.h"

 

 size_t __cdecl wcsftime(
       wchar_t*         _Buffer,
                               size_t           _SizeInWords,
                             wchar_t const*   _Format,
                               struct tm const* _Tm
    );

 

 size_t __cdecl _wcsftime_l(
       wchar_t*         _Buffer,
                               size_t           _SizeInWords,
                             wchar_t const*   _Format,
                               struct tm const* _Tm,
                           _locale_t        _Locale
    );

 
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wctime32_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
 wchar_t* __cdecl _wctime32(
      __time32_t const* _Time
    );


 errno_t __cdecl _wctime32_s(
        wchar_t*          _Buffer,
                                      size_t            _SizeInWords,
                                                       __time32_t const* _Time
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wctime32_s(  wchar_t (&_Buffer)[_Size],   __time32_t const* _Time) throw() { return _wctime32_s(_Buffer, _Size, _Time); } }
#line 101 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wtime.h"

 
 
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wctime64_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
 wchar_t* __cdecl _wctime64(
      __time64_t const* _Time
    );


 errno_t __cdecl _wctime64_s(
        wchar_t*          _Buffer,
                                      size_t            _SizeInWords,
                                                       __time64_t const* _Time);

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wctime64_s(  wchar_t (&_Buffer)[_Size],   __time64_t const* _Time) throw() { return _wctime64_s(_Buffer, _Size, _Time); } }
#line 120 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wtime.h"


 errno_t __cdecl _wstrdate_s(
       wchar_t* _Buffer,
                                                                                size_t   _SizeInWords
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wstrdate_s(  wchar_t (&_Buffer)[_Size]) throw() { return _wstrdate_s(_Buffer, _Size); } }
#line 131 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wtime.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wstrdate_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))   wchar_t* __cdecl _wstrdate( wchar_t *_Buffer);
#line 136 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wtime.h"


 errno_t __cdecl _wstrtime_s(
       wchar_t* _Buffer,
                                                                                size_t   _SizeInWords
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wstrtime_s(  wchar_t (&_Buffer)[_Size]) throw() { return _wstrtime_s(_Buffer, _Size); } }
#line 147 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wtime.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wstrtime_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))   wchar_t* __cdecl _wstrtime( wchar_t *_Buffer);
#line 152 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wtime.h"









    #pragma warning(push)
    #pragma warning(disable: 4996)

    




















         
        static __inline wchar_t * __cdecl _wctime(
              time_t const* const _Time)
        {
            return _wctime64(_Time);
        }

        
        static __inline errno_t __cdecl _wctime_s(
                  wchar_t*      const _Buffer,
                                                             size_t        const _SizeInWords,
                                                             time_t const* const _Time
            )
        {
            return _wctime64_s(_Buffer, _SizeInWords, _Time);
        }

    #line 202 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wtime.h"

    #pragma warning(pop)
#line 205 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\corecrt_wtime.h"



} __pragma(pack(pop))
#line 25 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\wchar.h"
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\sys/stat.h"







#pragma once


#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\sys/types.h"







#pragma once




    

    typedef unsigned short _ino_t; 

    
        typedef _ino_t ino_t;
    #line 20 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\sys/types.h"
#line 21 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\sys/types.h"




    

    typedef unsigned int _dev_t; 

    
        typedef _dev_t dev_t;
    #line 32 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\sys/types.h"
#line 33 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\sys/types.h"




    

    typedef long _off_t; 

    
        typedef _off_t off_t;
    #line 44 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\sys/types.h"
#line 45 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\sys/types.h"
#line 12 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\sys/stat.h"

__pragma(pack(push, 8)) extern "C" {


#pragma warning(push)
#pragma warning(disable: 4820) 







struct _stat32
{
    _dev_t         st_dev;
    _ino_t         st_ino;
    unsigned short st_mode;
    short          st_nlink;
    short          st_uid;
    short          st_gid;
    _dev_t         st_rdev;
    _off_t         st_size;
    __time32_t     st_atime;
    __time32_t     st_mtime;
    __time32_t     st_ctime;
};

struct _stat32i64
{
    _dev_t         st_dev;
    _ino_t         st_ino;
    unsigned short st_mode;
    short          st_nlink;
    short          st_uid;
    short          st_gid;
    _dev_t         st_rdev;
    __int64        st_size;
    __time32_t     st_atime;
    __time32_t     st_mtime;
    __time32_t     st_ctime;
};

struct _stat64i32
{
    _dev_t         st_dev;
    _ino_t         st_ino;
    unsigned short st_mode;
    short          st_nlink;
    short          st_uid;
    short          st_gid;
    _dev_t         st_rdev;
    _off_t         st_size;
    __time64_t     st_atime;
    __time64_t     st_mtime;
    __time64_t     st_ctime;
};

struct _stat64
{
    _dev_t         st_dev;
    _ino_t         st_ino;
    unsigned short st_mode;
    short          st_nlink;
    short          st_uid;
    short          st_gid;
    _dev_t         st_rdev;
    __int64        st_size;
    __time64_t     st_atime;
    __time64_t     st_mtime;
    __time64_t     st_ctime;
};




    struct stat
    {
        _dev_t         st_dev;
        _ino_t         st_ino;
        unsigned short st_mode;
        short          st_nlink;
        short          st_uid;
        short          st_gid;
        _dev_t         st_rdev;
        _off_t         st_size;
        time_t         st_atime;
        time_t         st_mtime;
        time_t         st_ctime;
    };
#line 103 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\sys/stat.h"


















    
    
    
    
    
    
    
#line 129 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\sys/stat.h"
















    
    
    
    
    
    
#line 152 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\sys/stat.h"



 int __cdecl _fstat32(
       int             _FileHandle,
      struct _stat32* _Stat
    );

 int __cdecl _fstat32i64(
       int                _FileHandle,
      struct _stat32i64* _Stat
    );

 int __cdecl _fstat64i32(
       int                _FileHandle,
      struct _stat64i32* _Stat
    );

 int __cdecl _fstat64(
       int             _FileHandle,
      struct _stat64* _Stat
    );

 int __cdecl _stat32(
      char const*     _FileName,
       struct _stat32* _Stat
    );

 int __cdecl _stat32i64(
      char const*        _FileName,
       struct _stat32i64* _Stat
    );

 int __cdecl _stat64i32(
      char const*        _FileName,
       struct _stat64i32* _Stat
    );

 int __cdecl _stat64(
      char const*     _FileName,
       struct _stat64* _Stat
    );

 int __cdecl _wstat32(
      wchar_t const*  _FileName,
       struct _stat32* _Stat
    );

 int __cdecl _wstat32i64(
      wchar_t const*     _FileName,
       struct _stat32i64* _Stat
    );

 int __cdecl _wstat64i32(
      wchar_t const*     _FileName,
       struct _stat64i32* _Stat
    );

 int __cdecl _wstat64(
      wchar_t const*  _FileName,
       struct _stat64* _Stat
    );




    















        static __inline int __cdecl fstat(int const _FileHandle, struct stat* const _Stat)
        {
            typedef char __static_assert_t[(sizeof(struct stat) == sizeof(struct _stat64i32)) != 0];
            return _fstat64i32(_FileHandle, (struct _stat64i32*)_Stat);
        }
        static __inline int __cdecl stat(char const* const _FileName, struct stat* const _Stat)
        {
            typedef char __static_assert_t[(sizeof(struct stat) == sizeof(struct _stat64i32)) != 0];
            return _stat64i32(_FileName, (struct _stat64i32*)_Stat);
        }

    #line 246 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\sys/stat.h"
#line 247 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\sys/stat.h"


#pragma warning(pop)


} __pragma(pack(pop))
#line 26 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\wchar.h"



__pragma(pack(push, 8)) extern "C" {








typedef wchar_t _Wint_t;





        
     wchar_t* __cdecl _wsetlocale(
                int            _Category,
          wchar_t const* _Locale
        );

    
     _locale_t __cdecl _wcreate_locale(
            int            _Category,
          wchar_t const* _Locale
        );



     wint_t __cdecl btowc(
          int _Ch
        );

     size_t __cdecl mbrlen(
            char const* _Ch,
                                                    size_t      _SizeInBytes,
                                                 mbstate_t*  _State
        );

     size_t __cdecl mbrtowc(
                                  wchar_t*    _DstCh,
            char const* _SrcCh,
                                                    size_t      _SizeInBytes,
                                                 mbstate_t*  _State
        );

     
     errno_t __cdecl mbsrtowcs_s(
                                  size_t*      _Retval,
                  wchar_t*     _Dst,
                                       size_t       _Size,
                          char const** _PSrc,
                                       size_t       _N,
                                    mbstate_t*   _State
        );

    extern "C++" { template <size_t _Size> inline   errno_t __cdecl mbsrtowcs_s(  size_t* _Retval,   wchar_t (&_Dest)[_Size],     char const** _PSource,   size_t _Count,   mbstate_t* _State) throw() { return mbsrtowcs_s(_Retval, _Dest, _Size, _PSource, _Count, _State); } }
#line 95 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\wchar.h"

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "mbsrtowcs_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))   size_t __cdecl mbsrtowcs( wchar_t *_Dest,  char const** _PSrc,  size_t _Count,  mbstate_t* _State);
#line 103 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\wchar.h"

     
     errno_t __cdecl wcrtomb_s(
                                 size_t*    _Retval,
          char*      _Dst,
                                      size_t     _SizeInBytes,
                                      wchar_t    _Ch,
                               mbstate_t* _State
        );

    extern "C++" { template <size_t _Size> inline   errno_t __cdecl wcrtomb_s(  size_t* _Retval,   char (&_Dest)[_Size],   wchar_t _Source,   mbstate_t* _State) throw() { return wcrtomb_s(_Retval, _Dest, _Size, _Source, _State); } }
#line 121 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\wchar.h"

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "wcrtomb_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  size_t __cdecl wcrtomb(  char *_Dest,  wchar_t _Source,  mbstate_t* _State);
#line 128 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\wchar.h"

     
     errno_t __cdecl wcsrtombs_s(
                                                  size_t*         _Retval,
          char*           _Dst,
                                                       size_t          _SizeInBytes,
                                    wchar_t const** _Src,
                                                       size_t          _Size,
                                                mbstate_t*      _State
        );

    extern "C++" { template <size_t _Size> inline   errno_t __cdecl wcsrtombs_s(  size_t* _Retval,   char (&_Dest)[_Size],     wchar_t const** _PSrc,   size_t _Count,   mbstate_t* _State) throw() { return wcsrtombs_s(_Retval, _Dest, _Size, _PSrc, _Count, _State); } }
#line 148 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\wchar.h"

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "wcsrtombs_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  size_t __cdecl wcsrtombs(  char *_Dest,  wchar_t const** _PSource,  size_t _Count,  mbstate_t* _State);
#line 156 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\wchar.h"

     int __cdecl wctob(
          wint_t _WCh
        );

    

         
        errno_t __cdecl wmemcpy_s(
              wchar_t*       _S1,
                                      rsize_t        _N1,
                        wchar_t const* _S2,
                                      rsize_t        _N
            );

         
        errno_t __cdecl wmemmove_s(
              wchar_t*       _S1,
                                      rsize_t        _N1,
                        wchar_t const* _S2,
                                      rsize_t        _N
            );

    #line 179 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\wchar.h"

    __inline int __cdecl fwide(
          FILE* _F,
              int   _M
        )
    {
        (void)_F;
        return (_M);
    }

    __inline int __cdecl mbsinit(
          mbstate_t const* _P
        )
    {
        return _P == 0 || _P->_Wchar == 0;
    }

    __inline wchar_t const* __cdecl wmemchr(
          wchar_t const* _S,
                    wchar_t        _C,
                    size_t         _N
        )
    {
        for (; 0 < _N; ++_S, --_N)
            if (*_S == _C)
                return (wchar_t const*)_S;

        return 0;
    }

    __inline int __cdecl wmemcmp(
          wchar_t const* _S1,
          wchar_t const* _S2,
                    size_t         _N
        )
    {
        for (; 0 < _N; ++_S1, ++_S2, --_N)
            if (*_S1 != *_S2)
                return *_S1 < *_S2 ? -1 : 1;

        return 0;
    }

     
    
    __inline 
    wchar_t* __cdecl wmemcpy(
          wchar_t*       _S1,
                wchar_t const* _S2,
                          size_t         _N
        )
    {
        #pragma warning(push)
        #pragma warning(disable : 4995 4996 6386)
        return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));
        #pragma warning(pop)
    }

    __inline 
    wchar_t* __cdecl wmemmove(
          wchar_t*       _S1,
                wchar_t const* _S2,
                              size_t         _N
        )
    {
        #pragma warning(push)
        #pragma warning(disable : 4996 6386)
        return (wchar_t*)memmove(_S1, _S2, _N*sizeof(wchar_t));
        #pragma warning(pop)
    }

     
    
    __inline wchar_t* __cdecl wmemset(
          wchar_t* _S,
                          wchar_t  _C,
                          size_t   _N
        )
    {
        wchar_t *_Su = _S;
        for (; 0 < _N; ++_Su, --_N)
        {
            *_Su = _C;
        }
        return _S;
    }

    

        extern "C++" inline wchar_t* __cdecl wmemchr(
              wchar_t* _S,
                        wchar_t  _C,
                        size_t   _N
            )
        {
            wchar_t const* const _SC = _S;
            return const_cast<wchar_t*>(wmemchr(_SC, _C, _N));
        }

    #line 279 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\wchar.h"

#line 281 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\wchar.h"



} __pragma(pack(pop))
#line 286 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\ucrt\\wchar.h"
#line 14 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\cwchar"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4472 4494 4514 4571 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4702 4793 4820 4988 5026 5027 5045  4984 5053 )




using _Mbstatet = mbstate_t;

namespace std {
#pragma warning(push)
#pragma warning(disable : 4995) 

using :: _Mbstatet;

using :: mbstate_t;
using :: size_t;
using :: tm;
using :: wint_t;

using :: btowc;
using :: fgetwc;
using :: fgetws;
using :: fputwc;
using :: fputws;
using :: fwide;
using :: fwprintf;
using :: fwscanf;
using :: getwc;
using :: getwchar;
using :: mbrlen;
using :: mbrtowc;
using :: mbsrtowcs;
using :: mbsinit;
using :: putwc;
using :: putwchar;
using :: swprintf;
using :: swscanf;
using :: ungetwc;
using :: vfwprintf;
using :: vswprintf;
using :: vwprintf;
using :: wcrtomb;
using :: wprintf;
using :: wscanf;
using :: wcsrtombs;
using :: wcstol;
using :: wcscat;
using :: wcschr;
using :: wcscmp;
using :: wcscoll;
using :: wcscpy;
using :: wcscspn;
using :: wcslen;
using :: wcsncat;
using :: wcsncmp;
using :: wcsncpy;
using :: wcspbrk;
using :: wcsrchr;
using :: wcsspn;
using :: wcstod;
using :: wcstoul;
using :: wcsstr;
using :: wcstok;
using :: wcsxfrm;
using :: wctob;
using :: wmemchr;
using :: wmemcmp;
using :: wmemcpy;
using :: wmemmove;
using :: wmemset;
using :: wcsftime;

using :: vfwscanf;
using :: vswscanf;
using :: vwscanf;
using :: wcstof;
using :: wcstold;
using :: wcstoll;
using :: wcstoull;

#pragma warning(pop)
}



#pragma warning(pop)
#pragma pack(pop)

#line 105 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\cwchar"
#line 106 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\cwchar"
#line 14 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\limits"


#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4472 4494 4514 4571 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4702 4793 4820 4988 5026 5027 5045  4984 5053 )




namespace std {

enum float_denorm_style { 
    denorm_indeterminate = -1,
    denorm_absent        = 0,
    denorm_present       = 1
};


enum float_round_style { 
    round_indeterminate       = -1,
    round_toward_zero         = 0,
    round_to_nearest          = 1,
    round_toward_infinity     = 2,
    round_toward_neg_infinity = 3
};


struct _Num_base { 
    static constexpr float_denorm_style has_denorm = denorm_absent;
    static constexpr bool has_denorm_loss          = false;
    static constexpr bool has_infinity             = false;
    static constexpr bool has_quiet_NaN            = false;
    static constexpr bool has_signaling_NaN        = false;
    static constexpr bool is_bounded               = false;
    static constexpr bool is_exact                 = false;
    static constexpr bool is_iec559                = false;
    static constexpr bool is_integer               = false;
    static constexpr bool is_modulo                = false;
    static constexpr bool is_signed                = false;
    static constexpr bool is_specialized           = false;
    static constexpr bool tinyness_before          = false;
    static constexpr bool traps                    = false;
    static constexpr float_round_style round_style = round_toward_zero;
    static constexpr int digits                    = 0;
    static constexpr int digits10                  = 0;
    static constexpr int max_digits10              = 0;
    static constexpr int max_exponent              = 0;
    static constexpr int max_exponent10            = 0;
    static constexpr int min_exponent              = 0;
    static constexpr int min_exponent10            = 0;
    static constexpr int radix                     = 0;
};


template <class _Ty>
class numeric_limits : public _Num_base { 
public:
    [[nodiscard]] static constexpr _Ty(min)() noexcept {
        return _Ty();
    }

    [[nodiscard]] static constexpr _Ty(max)() noexcept {
        return _Ty();
    }

    [[nodiscard]] static constexpr _Ty lowest() noexcept {
        return _Ty();
    }

    [[nodiscard]] static constexpr _Ty epsilon() noexcept {
        return _Ty();
    }

    [[nodiscard]] static constexpr _Ty round_error() noexcept {
        return _Ty();
    }

    [[nodiscard]] static constexpr _Ty denorm_min() noexcept {
        return _Ty();
    }

    [[nodiscard]] static constexpr _Ty infinity() noexcept {
        return _Ty();
    }

    [[nodiscard]] static constexpr _Ty quiet_NaN() noexcept {
        return _Ty();
    }

    [[nodiscard]] static constexpr _Ty signaling_NaN() noexcept {
        return _Ty();
    }
};

template <class _Ty>
class numeric_limits<const _Ty> : public numeric_limits<_Ty> { 
};

template <class _Ty>
class numeric_limits<volatile _Ty> : public numeric_limits<_Ty> { 
};

template <class _Ty>
class numeric_limits<const volatile _Ty> : public numeric_limits<_Ty> { 
};


struct _Num_int_base : _Num_base { 
    static constexpr bool is_bounded     = true;
    static constexpr bool is_exact       = true;
    static constexpr bool is_integer     = true;
    static constexpr bool is_specialized = true;
    static constexpr int radix           = 2;
};


struct _Num_float_base : _Num_base { 
    static constexpr float_denorm_style has_denorm = denorm_present;
    static constexpr bool has_infinity             = true;
    static constexpr bool has_quiet_NaN            = true;
    static constexpr bool has_signaling_NaN        = true;
    static constexpr bool is_bounded               = true;
    static constexpr bool is_iec559                = true;
    static constexpr bool is_signed                = true;
    static constexpr bool is_specialized           = true;
    static constexpr float_round_style round_style = round_to_nearest;
    static constexpr int radix                     = 2;
};


template <>
class numeric_limits<bool> : public _Num_int_base {
public:
    [[nodiscard]] static constexpr bool(min)() noexcept {
        return false;
    }

    [[nodiscard]] static constexpr bool(max)() noexcept {
        return true;
    }

    [[nodiscard]] static constexpr bool lowest() noexcept {
        return (min)();
    }

    [[nodiscard]] static constexpr bool epsilon() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr bool round_error() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr bool denorm_min() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr bool infinity() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr bool quiet_NaN() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr bool signaling_NaN() noexcept {
        return 0;
    }

    static constexpr int digits = 1;
};


template <>
class numeric_limits<char> : public _Num_int_base {
public:
    [[nodiscard]] static constexpr char(min)() noexcept {
        return (-128);
    }

    [[nodiscard]] static constexpr char(max)() noexcept {
        return 127;
    }

    [[nodiscard]] static constexpr char lowest() noexcept {
        return (min)();
    }

    [[nodiscard]] static constexpr char epsilon() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char round_error() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char denorm_min() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char infinity() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char quiet_NaN() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char signaling_NaN() noexcept {
        return 0;
    }

    static constexpr bool is_signed = (-128) != 0;
    static constexpr bool is_modulo = (-128) == 0;
    static constexpr int digits     = 8 - ((-128) != 0);
    static constexpr int digits10   = 2;
};


template <>
class numeric_limits<signed char> : public _Num_int_base {
public:
    [[nodiscard]] static constexpr signed char(min)() noexcept {
        return (-128);
    }

    [[nodiscard]] static constexpr signed char(max)() noexcept {
        return 127;
    }

    [[nodiscard]] static constexpr signed char lowest() noexcept {
        return (min)();
    }

    [[nodiscard]] static constexpr signed char epsilon() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr signed char round_error() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr signed char denorm_min() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr signed char infinity() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr signed char quiet_NaN() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr signed char signaling_NaN() noexcept {
        return 0;
    }

    static constexpr bool is_signed = true;
    static constexpr int digits     = 7;
    static constexpr int digits10   = 2;
};


template <>
class numeric_limits<unsigned char> : public _Num_int_base {
public:
    [[nodiscard]] static constexpr unsigned char(min)() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned char(max)() noexcept {
        return 0xff;
    }

    [[nodiscard]] static constexpr unsigned char lowest() noexcept {
        return (min)();
    }

    [[nodiscard]] static constexpr unsigned char epsilon() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned char round_error() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned char denorm_min() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned char infinity() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned char quiet_NaN() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned char signaling_NaN() noexcept {
        return 0;
    }

    static constexpr bool is_modulo = true;
    static constexpr int digits     = 8;
    static constexpr int digits10   = 2;
};

















































template <>
class numeric_limits<char16_t> : public _Num_int_base {
public:
    [[nodiscard]] static constexpr char16_t(min)() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char16_t(max)() noexcept {
        return 0xffff;
    }

    [[nodiscard]] static constexpr char16_t lowest() noexcept {
        return (min)();
    }

    [[nodiscard]] static constexpr char16_t epsilon() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char16_t round_error() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char16_t denorm_min() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char16_t infinity() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char16_t quiet_NaN() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char16_t signaling_NaN() noexcept {
        return 0;
    }

    static constexpr bool is_modulo = true;
    static constexpr int digits     = 16;
    static constexpr int digits10   = 4;
};


template <>
class numeric_limits<char32_t> : public _Num_int_base {
public:
    [[nodiscard]] static constexpr char32_t(min)() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char32_t(max)() noexcept {
        return 0xffffffff;
    }

    [[nodiscard]] static constexpr char32_t lowest() noexcept {
        return (min)();
    }

    [[nodiscard]] static constexpr char32_t epsilon() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char32_t round_error() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char32_t denorm_min() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char32_t infinity() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char32_t quiet_NaN() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char32_t signaling_NaN() noexcept {
        return 0;
    }

    static constexpr bool is_modulo = true;
    static constexpr int digits     = 32;
    static constexpr int digits10   = 9;
};


template <>
class numeric_limits<wchar_t> : public _Num_int_base {
public:
    [[nodiscard]] static constexpr wchar_t(min)() noexcept {
        return 0x0000;
    }

    [[nodiscard]] static constexpr wchar_t(max)() noexcept {
        return 0xffff;
    }

    [[nodiscard]] static constexpr wchar_t lowest() noexcept {
        return (min)();
    }

    [[nodiscard]] static constexpr wchar_t epsilon() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr wchar_t round_error() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr wchar_t denorm_min() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr wchar_t infinity() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr wchar_t quiet_NaN() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr wchar_t signaling_NaN() noexcept {
        return 0;
    }

    static constexpr bool is_modulo = true;
    static constexpr int digits     = 16;
    static constexpr int digits10   = 4;
};


template <>
class numeric_limits<short> : public _Num_int_base {
public:
    [[nodiscard]] static constexpr short(min)() noexcept {
        return (-32768);
    }

    [[nodiscard]] static constexpr short(max)() noexcept {
        return 32767;
    }

    [[nodiscard]] static constexpr short lowest() noexcept {
        return (min)();
    }

    [[nodiscard]] static constexpr short epsilon() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr short round_error() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr short denorm_min() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr short infinity() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr short quiet_NaN() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr short signaling_NaN() noexcept {
        return 0;
    }

    static constexpr bool is_signed = true;
    static constexpr int digits     = 15;
    static constexpr int digits10   = 4;
};


template <>
class numeric_limits<int> : public _Num_int_base {
public:
    [[nodiscard]] static constexpr int(min)() noexcept {
        return (-2147483647 - 1);
    }

    [[nodiscard]] static constexpr int(max)() noexcept {
        return 2147483647;
    }

    [[nodiscard]] static constexpr int lowest() noexcept {
        return (min)();
    }

    [[nodiscard]] static constexpr int epsilon() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr int round_error() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr int denorm_min() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr int infinity() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr int quiet_NaN() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr int signaling_NaN() noexcept {
        return 0;
    }

    static constexpr bool is_signed = true;
    static constexpr int digits     = 31;
    static constexpr int digits10   = 9;
};


template <>
class numeric_limits<long> : public _Num_int_base {
public:
    [[nodiscard]] static constexpr long(min)() noexcept {
        return (-2147483647L - 1);
    }

    [[nodiscard]] static constexpr long(max)() noexcept {
        return 2147483647L;
    }

    [[nodiscard]] static constexpr long lowest() noexcept {
        return (min)();
    }

    [[nodiscard]] static constexpr long epsilon() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr long round_error() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr long denorm_min() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr long infinity() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr long quiet_NaN() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr long signaling_NaN() noexcept {
        return 0;
    }

    static_assert(sizeof(int) == sizeof(long), "LLP64 assumption");
    static constexpr bool is_signed = true;
    static constexpr int digits     = 31;
    static constexpr int digits10   = 9;
};


template <>
class numeric_limits<long long> : public _Num_int_base {
public:
    [[nodiscard]] static constexpr long long(min)() noexcept {
        return (-9223372036854775807i64 - 1);
    }

    [[nodiscard]] static constexpr long long(max)() noexcept {
        return 9223372036854775807i64;
    }

    [[nodiscard]] static constexpr long long lowest() noexcept {
        return (min)();
    }

    [[nodiscard]] static constexpr long long epsilon() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr long long round_error() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr long long denorm_min() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr long long infinity() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr long long quiet_NaN() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr long long signaling_NaN() noexcept {
        return 0;
    }

    static constexpr bool is_signed = true;
    static constexpr int digits     = 63;
    static constexpr int digits10   = 18;
};



template <>
class numeric_limits<unsigned short> : public _Num_int_base {
public:
    [[nodiscard]] static constexpr unsigned short(min)() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned short(max)() noexcept {
        return 0xffff;
    }

    [[nodiscard]] static constexpr unsigned short lowest() noexcept {
        return (min)();
    }

    [[nodiscard]] static constexpr unsigned short epsilon() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned short round_error() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned short denorm_min() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned short infinity() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned short quiet_NaN() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned short signaling_NaN() noexcept {
        return 0;
    }

    static constexpr bool is_modulo = true;
    static constexpr int digits     = 16;
    static constexpr int digits10   = 4;
};
#line 731 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\limits"


template <>
class numeric_limits<unsigned int> : public _Num_int_base {
public:
    [[nodiscard]] static constexpr unsigned int(min)() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned int(max)() noexcept {
        return 0xffffffff;
    }

    [[nodiscard]] static constexpr unsigned int lowest() noexcept {
        return (min)();
    }

    [[nodiscard]] static constexpr unsigned int epsilon() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned int round_error() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned int denorm_min() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned int infinity() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned int quiet_NaN() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned int signaling_NaN() noexcept {
        return 0;
    }

    static constexpr bool is_modulo = true;
    static constexpr int digits     = 32;
    static constexpr int digits10   = 9;
};


template <>
class numeric_limits<unsigned long> : public _Num_int_base {
public:
    [[nodiscard]] static constexpr unsigned long(min)() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned long(max)() noexcept {
        return 0xffffffffUL;
    }

    [[nodiscard]] static constexpr unsigned long lowest() noexcept {
        return (min)();
    }

    [[nodiscard]] static constexpr unsigned long epsilon() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned long round_error() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned long denorm_min() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned long infinity() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned long quiet_NaN() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned long signaling_NaN() noexcept {
        return 0;
    }

    static_assert(sizeof(unsigned int) == sizeof(unsigned long), "LLP64 assumption");
    static constexpr bool is_modulo = true;
    static constexpr int digits     = 32;
    static constexpr int digits10   = 9;
};


template <>
class numeric_limits<unsigned long long> : public _Num_int_base {
public:
    [[nodiscard]] static constexpr unsigned long long(min)() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned long long(max)() noexcept {
        return 0xffffffffffffffffui64;
    }

    [[nodiscard]] static constexpr unsigned long long lowest() noexcept {
        return (min)();
    }

    [[nodiscard]] static constexpr unsigned long long epsilon() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned long long round_error() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned long long denorm_min() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned long long infinity() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned long long quiet_NaN() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned long long signaling_NaN() noexcept {
        return 0;
    }

    static constexpr bool is_modulo = true;
    static constexpr int digits     = 64;
    static constexpr int digits10   = 19;
};


template <>
class numeric_limits<float> : public _Num_float_base {
public:
    [[nodiscard]] static constexpr float(min)() noexcept {
        return 1.175494351e-38F;
    }

    [[nodiscard]] static constexpr float(max)() noexcept {
        return 3.402823466e+38F;
    }

    [[nodiscard]] static constexpr float lowest() noexcept {
        return -(max)();
    }

    [[nodiscard]] static constexpr float epsilon() noexcept {
        return 1.192092896e-07F;
    }

    [[nodiscard]] static constexpr float round_error() noexcept {
        return 0.5F;
    }

    [[nodiscard]] static constexpr float denorm_min() noexcept {
        return 1.401298464e-45F;
    }

    [[nodiscard]] static constexpr float infinity() noexcept {
        return __builtin_huge_valf();
    }

    [[nodiscard]] static constexpr float quiet_NaN() noexcept {
        return __builtin_nanf("0");
    }

    [[nodiscard]] static constexpr float signaling_NaN() noexcept {
        return __builtin_nansf("1");
    }

    static constexpr int digits         = 24;
    static constexpr int digits10       = 6;
    static constexpr int max_digits10   = 9;
    static constexpr int max_exponent   = 128;
    static constexpr int max_exponent10 = 38;
    static constexpr int min_exponent   = (-125);
    static constexpr int min_exponent10 = (-37);
};


template <>
class numeric_limits<double> : public _Num_float_base {
public:
    [[nodiscard]] static constexpr double(min)() noexcept {
        return 2.2250738585072014e-308;
    }

    [[nodiscard]] static constexpr double(max)() noexcept {
        return 1.7976931348623158e+308;
    }

    [[nodiscard]] static constexpr double lowest() noexcept {
        return -(max)();
    }

    [[nodiscard]] static constexpr double epsilon() noexcept {
        return 2.2204460492503131e-016;
    }

    [[nodiscard]] static constexpr double round_error() noexcept {
        return 0.5;
    }

    [[nodiscard]] static constexpr double denorm_min() noexcept {
        return 4.9406564584124654e-324;
    }

    [[nodiscard]] static constexpr double infinity() noexcept {
        return __builtin_huge_val();
    }

    [[nodiscard]] static constexpr double quiet_NaN() noexcept {
        return __builtin_nan("0");
    }

    [[nodiscard]] static constexpr double signaling_NaN() noexcept {
        return __builtin_nans("1");
    }

    static constexpr int digits         = 53;
    static constexpr int digits10       = 15;
    static constexpr int max_digits10   = 17;
    static constexpr int max_exponent   = 1024;
    static constexpr int max_exponent10 = 308;
    static constexpr int min_exponent   = (-1021);
    static constexpr int min_exponent10 = (-307);
};


template <>
class numeric_limits<long double> : public _Num_float_base {
public:
    [[nodiscard]] static constexpr long double(min)() noexcept {
        return 2.2250738585072014e-308;
    }

    [[nodiscard]] static constexpr long double(max)() noexcept {
        return 1.7976931348623158e+308;
    }

    [[nodiscard]] static constexpr long double lowest() noexcept {
        return -(max)();
    }

    [[nodiscard]] static constexpr long double epsilon() noexcept {
        return 2.2204460492503131e-016;
    }

    [[nodiscard]] static constexpr long double round_error() noexcept {
        return 0.5L;
    }

    [[nodiscard]] static constexpr long double denorm_min() noexcept {
        return 4.9406564584124654e-324;
    }

    [[nodiscard]] static constexpr long double infinity() noexcept {
        return __builtin_huge_val();
    }

    [[nodiscard]] static constexpr long double quiet_NaN() noexcept {
        return __builtin_nan("0");
    }

    [[nodiscard]] static constexpr long double signaling_NaN() noexcept {
        return __builtin_nans("1");
    }

    static constexpr int digits         = 53;
    static constexpr int digits10       = 15;
    static constexpr int max_digits10   = 17;
    static constexpr int max_exponent   = 1024;
    static constexpr int max_exponent10 = 308;
    static constexpr int min_exponent   = (-1021);
    static constexpr int min_exponent10 = (-307);
};
}


#pragma warning(pop)
#pragma pack(pop)
#line 1020 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\limits"
#line 1021 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\limits"
#line 6 "C:\\Projects\\glm\\glm\\detail\\./compute_vector_relational.hpp"

namespace glm{
namespace detail
{
	template <typename T, bool isFloat>
	struct compute_equal
	{
		 inline constexpr static bool call(T a, T b)
		{
			return a == b;
		}
	};











}
}
#line 4 "C:\\Projects\\glm\\glm\\detail\\type_vec2.inl"

namespace glm
{
	













#line 22 "C:\\Projects\\glm\\glm\\detail\\type_vec2.inl"

	

	template<typename T>
	 inline constexpr vec<2, T>::vec(T scalar)
		: x(scalar), y(scalar)
	{}

	template<typename T>
	 inline constexpr vec<2, T>::vec(T _x, T _y)
		: x(_x), y(_y)
	{}

	

	template<typename T>
	template<typename U>
	 inline constexpr vec<2, T>::vec(vec<2, U> const& v)
		: x(static_cast<T>(v.x))
		, y(static_cast<T>(v.y))
	{}

	template<typename T>
	template<typename U>
	 inline constexpr vec<2, T>::vec(vec<3, U> const& v)
		: x(static_cast<T>(v.x))
		, y(static_cast<T>(v.y))
	{}

	template<typename T>
	template<typename U>
	 inline constexpr vec<2, T>::vec(vec<4, U> const& v)
		: x(static_cast<T>(v.x))
		, y(static_cast<T>(v.y))
	{}

	

	template<typename T>
	 inline constexpr T & vec<2, T>::operator[](typename vec<2, T>::length_type i)
	{
		(void)( (!!(i >= 0 && i < this->length())) || (_wassert(L"i >= 0 && i < this->length()", L"C:\\Projects\\glm\\glm\\detail\\type_vec2.inl", (unsigned)(63)), 0) );
		switch(i)
		{
		default:
		case 0:
			return x;
		case 1:
			return y;
		}
	}

	template<typename T>
	 inline constexpr T const& vec<2, T>::operator[](typename vec<2, T>::length_type i) const
	{
		(void)( (!!(i >= 0 && i < this->length())) || (_wassert(L"i >= 0 && i < this->length()", L"C:\\Projects\\glm\\glm\\detail\\type_vec2.inl", (unsigned)(77)), 0) );
		switch(i)
		{
		default:
		case 0:
			return x;
		case 1:
			return y;
		}
	}

	









#line 99 "C:\\Projects\\glm\\glm\\detail\\type_vec2.inl"

	template<typename T>
	 inline constexpr vec<2, T> & vec<2, T>::operator+=(T scalar)
	{
		this->x += static_cast<T>(scalar);
		this->y += static_cast<T>(scalar);
		return *this;
	}

	template<typename T>
	 inline constexpr vec<2, T> & vec<2, T>::operator+=(vec const& v)
	{
		this->x += static_cast<T>(v.x);
		this->y += static_cast<T>(v.y);
		return *this;
	}

	template<typename T>
	 inline constexpr vec<2, T> & vec<2, T>::operator-=(T scalar)
	{
		this->x -= static_cast<T>(scalar);
		this->y -= static_cast<T>(scalar);
		return *this;
	}

	template<typename T>
	 inline constexpr vec<2, T> & vec<2, T>::operator-=(vec const& v)
	{
		this->x -= static_cast<T>(v.x);
		this->y -= static_cast<T>(v.y);
		return *this;
	}

	template<typename T>
	 inline constexpr vec<2, T> & vec<2, T>::operator*=(T scalar)
	{
		this->x *= static_cast<T>(scalar);
		this->y *= static_cast<T>(scalar);
		return *this;
	}

	template<typename T>
	 inline constexpr vec<2, T> & vec<2, T>::operator*=(vec const& v)
	{
		this->x *= static_cast<T>(v.x);
		this->y *= static_cast<T>(v.y);
		return *this;
	}

	template<typename T>
	 inline constexpr vec<2, T> & vec<2, T>::operator/=(T scalar)
	{
		this->x /= static_cast<T>(scalar);
		this->y /= static_cast<T>(scalar);
		return *this;
	}

	
	template<typename T>
	 inline constexpr vec<2, T> & vec<2, T>::operator/=(vec const& v)
	{
		this->x /= static_cast<T>(v.x);
		this->y /= static_cast<T>(v.y);
		return *this;
	}

	

	template<typename T>
	 inline constexpr vec<2, T> operator+(vec<2, T> const& v)
	{
		return v;
	}

	template<typename T>
	 inline constexpr vec<2, T> operator-(vec<2, T> const& v)
	{
		return vec<2, T>(
			-v.x,
			-v.y);
	}

	

	template<typename T>
	 inline constexpr vec<2, T> operator+(vec<2, T> const& v, T scalar)
	{
		return vec<2, T>(
			v.x + scalar,
			v.y + scalar);
	}

	template<typename T>
	 inline constexpr vec<2, T> operator+(T scalar, vec<2, T> const& v)
	{
		return vec<2, T>(
			scalar + v.x,
			scalar + v.y);
	}

	template<typename T>
	 inline constexpr vec<2, T> operator+(vec<1, T> const& v1, vec<2, T> const& v2)
	{
		return vec<2, T>(
			v1.x + v2.x,
			v1.x + v2.y);
	}

	template<typename T>
	 inline constexpr vec<2, T> operator+(vec<2, T> const& v1, vec<2, T> const& v2)
	{
		return vec<2, T>(
			v1.x + v2.x,
			v1.y + v2.y);
	}

	template<typename T>
	 inline constexpr vec<2, T> operator-(vec<2, T> const& v, T scalar)
	{
		return vec<2, T>(
			v.x - scalar,
			v.y - scalar);
	}

	template<typename T>
	 inline constexpr vec<2, T> operator-(T scalar, vec<2, T> const& v)
	{
		return vec<2, T>(
			scalar - v.x,
			scalar - v.y);
	}

	template<typename T>
	 inline constexpr vec<2, T> operator-(vec<2, T> const& v1, vec<2, T> const& v2)
	{
		return vec<2, T>(
			v1.x - v2.x,
			v1.y - v2.y);
	}

	template<typename T>
	 inline constexpr vec<2, T> operator*(vec<2, T> const& v, T scalar)
	{
		return vec<2, T>(
			v.x * scalar,
			v.y * scalar);
	}

	template<typename T>
	 inline constexpr vec<2, T> operator*(T scalar, vec<2, T> const& v)
	{
		return vec<2, T>(
			scalar * v.x,
			scalar * v.y);
	}

	template<typename T>
	 inline constexpr vec<2, T> operator*(vec<1, T> const& v1, vec<2, T> const& v2)
	{
		return vec<2, T>(
			v1.x * v2.x,
			v1.x * v2.y);
	}

	template<typename T>
	 inline constexpr vec<2, T> operator*(vec<2, T> const& v1, vec<2, T> const& v2)
	{
		return vec<2, T>(
			v1.x * v2.x,
			v1.y * v2.y);
	}

	template<typename T>
	 inline constexpr vec<2, T> operator/(vec<2, T> const& v, T scalar)
	{
		return vec<2, T>(
			v.x / scalar,
			v.y / scalar);
	}

	template<typename T>
	 inline constexpr vec<2, T> operator/(T scalar, vec<2, T> const& v)
	{
		return vec<2, T>(
			scalar / v.x,
			scalar / v.y);
	}

	template<typename T>
	 inline constexpr vec<2, T> operator/(vec<2, T> const& v1, vec<2, T> const& v2)
	{
		return vec<2, T>(
			v1.x / v2.x,
			v1.y / v2.y);
	}

	

	template<typename T>
	 inline constexpr vec<2, T> operator%(vec<2, T> const& v, T scalar)
	{
		return vec<2, T>(
			v.x % scalar,
			v.y % scalar);
	}

	template<typename T>
	 inline constexpr vec<2, T> operator%(vec<2, T> const& v1, vec<1, T> const& v2)
	{
		return vec<2, T>(
			v1.x % v2.x,
			v1.y % v2.x);
	}

	template<typename T>
	 inline constexpr vec<2, T> operator%(T scalar, vec<2, T> const& v)
	{
		return vec<2, T>(
			scalar % v.x,
			scalar % v.y);
	}

	template<typename T>
	 inline constexpr vec<2, T> operator%(vec<2, T> const& v1, vec<2, T> const& v2)
	{
		return vec<2, T>(
			v1.x % v2.x,
			v1.y % v2.y);
	}

	template<typename T>
	 inline constexpr vec<2, T> operator&(vec<2, T> const& v, T scalar)
	{
		return vec<2, T>(
			v.x & scalar,
			v.y & scalar);
	}

	template<typename T>
	 inline constexpr vec<2, T> operator&(T scalar, vec<2, T> const& v)
	{
		return vec<2, T>(
			scalar & v.x,
			scalar & v.y);
	}

	template<typename T>
	 inline constexpr vec<2, T> operator&(vec<2, T> const& v1, vec<2, T> const& v2)
	{
		return vec<2, T>(
			v1.x & v2.x,
			v1.y & v2.y);
	}

	template<typename T>
	 inline constexpr vec<2, T> operator|(vec<2, T> const& v, T scalar)
	{
		return vec<2, T>(
			v.x | scalar,
			v.y | scalar);
	}

	template<typename T>
	 inline constexpr vec<2, T> operator|(T scalar, vec<2, T> const& v)
	{
		return vec<2, T>(
			scalar | v.x,
			scalar | v.y);
	}

	template<typename T>
	 inline constexpr vec<2, T> operator|(vec<2, T> const& v1, vec<2, T> const& v2)
	{
		return vec<2, T>(
			v1.x | v2.x,
			v1.y | v2.y);
	}

	template<typename T>
	 inline constexpr vec<2, T> operator^(vec<2, T> const& v, T scalar)
	{
		return vec<2, T>(
			v.x ^ scalar,
			v.y ^ scalar);
	}

	template<typename T>
	 inline constexpr vec<2, T> operator^(T scalar, vec<2, T> const& v)
	{
		return vec<2, T>(
			scalar ^ v.x,
			scalar ^ v.y);
	}

	template<typename T>
	 inline constexpr vec<2, T> operator^(vec<2, T> const& v1, vec<2, T> const& v2)
	{
		return vec<2, T>(
			v1.x ^ v2.x,
			v1.y ^ v2.y);
	}

	template<typename T>
	 inline constexpr vec<2, T> operator<<(vec<2, T> const& v, T scalar)
	{
		return vec<2, T>(
			v.x << scalar,
			v.y << scalar);
	}

	template<typename T>
	 inline constexpr vec<2, T> operator<<(T scalar, vec<2, T> const& v)
	{
		return vec<2, T>(
			scalar << v.x,
			scalar << v.y);
	}

	template<typename T>
	 inline constexpr vec<2, T> operator<<(vec<2, T> const& v1, vec<2, T> const& v2)
	{
		return vec<2, T>(
			v1.x << v2.x,
			v1.y << v2.y);
	}

	template<typename T>
	 inline constexpr vec<2, T> operator>>(vec<2, T> const& v, T scalar)
	{
		return vec<2, T>(
			v.x >> scalar,
			v.y >> scalar);
	}

	template<typename T>
	 inline constexpr vec<2, T> operator>>(T scalar, vec<2, T> const& v)
	{
		return vec<2, T>(
			scalar >> v.x,
			scalar >> v.y);
	}

	template<typename T>
	 inline constexpr vec<2, T> operator>>(vec<2, T> const& v1, vec<2, T> const& v2)
	{
		return vec<2, T>(
			v1.x >> v2.x,
			v1.y >> v2.y);
	}

	template<typename T>
	 inline constexpr vec<2, T> operator~(vec<2, T> const& v)
	{
		return vec<2, T>(
			~v.x,
			~v.y);
	}

	

	template<typename T>
	 inline constexpr bool operator==(vec<2, T> const& v1, vec<2, T> const& v2)
	{
		return
			detail::compute_equal<T, std::numeric_limits<T>::is_iec559>::call(v1.x, v2.x) &&
			detail::compute_equal<T, std::numeric_limits<T>::is_iec559>::call(v1.y, v2.y);
	}

	template<typename T>
	 inline constexpr bool operator!=(vec<2, T> const& v1, vec<2, T> const& v2)
	{
		return !(v1 == v2);
	}

	 inline constexpr vec<2, bool> operator&&(vec<2, bool> const& v1, vec<2, bool> const& v2)
	{
		return vec<2, bool>(v1.x && v2.x, v1.y && v2.y);
	}

	 inline constexpr vec<2, bool> operator||(vec<2, bool> const& v1, vec<2, bool> const& v2)
	{
		return vec<2, bool>(v1.x || v2.x, v1.y || v2.y);
	}
}
#line 196 "C:\\Projects\\glm\\glm\\ext\\../detail/type_vec2.hpp"
#line 197 "C:\\Projects\\glm\\glm\\ext\\../detail/type_vec2.hpp"
#line 6 "C:\\Projects\\glm\\glm\\./ext/vector_bool2.hpp"

namespace glm
{
	
	

	
	
	
	typedef vec<2, bool>		bvec2;

	
}
#line 6 "C:\\Projects\\glm\\glm\\vec2.hpp"
#line 1 "C:\\Projects\\glm\\glm\\./ext/vector_float2.hpp"



#pragma once


namespace glm
{
	
	

	
	
	
	typedef vec<2, float>	vec2;

	
}
#line 7 "C:\\Projects\\glm\\glm\\vec2.hpp"
#line 1 "C:\\Projects\\glm\\glm\\./ext/vector_double2.hpp"



#pragma once


namespace glm
{
	
	

	
	
	
	typedef vec<2, double>		dvec2;

	
}
#line 8 "C:\\Projects\\glm\\glm\\vec2.hpp"
#line 1 "C:\\Projects\\glm\\glm\\./ext/vector_int2.hpp"



#pragma once


namespace glm
{
	
	

	
	
	
	typedef vec<2, int>		ivec2;

	
}
#line 9 "C:\\Projects\\glm\\glm\\vec2.hpp"
#line 1 "C:\\Projects\\glm\\glm\\./ext/vector_uint2.hpp"



#pragma once


namespace glm
{
	
	

	
	
	
	typedef vec<2, unsigned int>		uvec2;

	
}
#line 10 "C:\\Projects\\glm\\glm\\vec2.hpp"
#line 5 ".\\glm_impl.cpp"
#line 1 "C:\\Projects\\glm\\glm\\vec3.hpp"



#pragma once
#line 1 "C:\\Projects\\glm\\glm\\./ext/vector_bool3.hpp"



#pragma once
#line 1 "C:\\Projects\\glm\\glm\\ext\\../detail/type_vec3.hpp"



#pragma once




#line 10 "C:\\Projects\\glm\\glm\\ext\\../detail/type_vec3.hpp"

#line 12 "C:\\Projects\\glm\\glm\\ext\\../detail/type_vec3.hpp"


namespace glm
{
	template<length_t L, typename T> struct vec;
	template<typename T>
	struct vec<3, T>
	{
		

		typedef T value_type;
		typedef vec<3, T> type;
		typedef vec<3, bool> bool_type;

		
















#line 44 "C:\\Projects\\glm\\glm\\ext\\../detail/type_vec3.hpp"



#line 48 "C:\\Projects\\glm\\glm\\ext\\../detail/type_vec3.hpp"




















#line 69 "C:\\Projects\\glm\\glm\\ext\\../detail/type_vec3.hpp"
			union { T x, r, s; };
			union { T y, g, t; };
			union { T z, b, p; };



#line 76 "C:\\Projects\\glm\\glm\\ext\\../detail/type_vec3.hpp"
#line 77 "C:\\Projects\\glm\\glm\\ext\\../detail/type_vec3.hpp"









#line 87 "C:\\Projects\\glm\\glm\\ext\\../detail/type_vec3.hpp"

		

		
		typedef length_t length_type;
		 static constexpr length_type length(){return 3;}

		 constexpr T & operator[](length_type i);
		 constexpr T const& operator[](length_type i) const;

		

		 constexpr vec() = default;
		 constexpr vec(vec const& v) = default;

		

		 constexpr explicit vec(T scalar);
		 constexpr vec(T a, T b, T c);

		

		
		template<typename A, typename B>
		 constexpr vec(vec<2, A> const& _xy, B _z);
		
		template<typename A, typename B>
		 constexpr vec(A _x, vec<2, B> const& _yz);
		
		template<typename U>
		 constexpr  vec(vec<4, U> const& v);

		
		template<typename U>
		 constexpr  vec(vec<3, U> const& v);

		


















#line 143 "C:\\Projects\\glm\\glm\\ext\\../detail/type_vec3.hpp"

		

		 constexpr vec<3, T>& operator=(vec<3, T> const& v) = default;
		
		 constexpr vec<3, T> & operator+=(T scalar);
		
		 constexpr vec<3, T> & operator+=(vec<3, T> const& v);
		
		 constexpr vec<3, T> & operator-=(T scalar);
		
		 constexpr vec<3, T> & operator-=(vec<3, T> const& v);
		
		 constexpr vec<3, T> & operator*=(T scalar);
		
		 constexpr vec<3, T> & operator*=(vec<3, T> const& v);
		
		 constexpr vec<3, T> & operator/=(T scalar);
		
		 constexpr vec<3, T> & operator/=(vec<3, T> const& v);
	};

	

	template<typename T>
	 constexpr vec<3, T> operator+(vec<3, T> const& v);

	template<typename T>
	 constexpr vec<3, T> operator-(vec<3, T> const& v);

	

	template<typename T>
	 constexpr vec<3, T> operator+(vec<3, T> const& v, T scalar);

	template<typename T>
	 constexpr vec<3, T> operator+(T scalar, vec<3, T> const& v);

	template<typename T>
	 constexpr vec<3, T> operator+(vec<3, T> const& v1, vec<3, T> const& v2);

	template<typename T>
	 constexpr vec<3, T> operator-(vec<3, T> const& v, T scalar);

	template<typename T>
	 constexpr vec<3, T> operator-(T scalar, vec<3, T> const& v);

	template<typename T>
	 constexpr vec<3, T> operator-(vec<3, T> const& v1, vec<3, T> const& v2);

	template<typename T>
	 constexpr vec<3, T> operator*(vec<3, T> const& v, T scalar);

	template<typename T>
	 constexpr vec<3, T> operator*(T scalar, vec<3, T> const& v);

	template<typename T>
	 constexpr vec<3, T> operator*(vec<3, T> const& v1, vec<3, T> const& v2);

	template<typename T>
	 constexpr vec<3, T> operator/(vec<3, T> const& v, T scalar);

	template<typename T>
	 constexpr vec<3, T> operator/(T scalar, vec<3, T> const& v);

	template<typename T>
	 constexpr vec<3, T> operator/(vec<3, T> const& v1, vec<3, T> const& v2);

	

	template<typename T>
	 constexpr bool operator==(vec<3, T> const& v1, vec<3, T> const& v2);

	template<typename T>
	 constexpr bool operator!=(vec<3, T> const& v1, vec<3, T> const& v2);


	 constexpr vec<3, bool> operator&&(vec<3, bool> const& v1, vec<3, bool> const& v2);

	 constexpr vec<3, bool> operator||(vec<3, bool> const& v1, vec<3, bool> const& v2);
}


#line 1 "C:\\Projects\\glm\\glm\\detail\\type_vec3.inl"




namespace glm
{
	













#line 22 "C:\\Projects\\glm\\glm\\detail\\type_vec3.inl"

	

	template<typename T>
	 inline constexpr vec<3, T>::vec(T scalar)
		: x(scalar), y(scalar), z(scalar)
	{}

	template <typename T>
	 inline constexpr vec<3, T>::vec(T _x, T _y, T _z)
		: x(_x), y(_y), z(_z)
	{}

	

	template<typename T>
	template<typename A, typename B>
	 inline constexpr vec<3, T>::vec(vec<2, A> const& _xy, B _z)
		: x(static_cast<T>(_xy.x))
		, y(static_cast<T>(_xy.y))
		, z(static_cast<T>(_z))
	{}

	template<typename T>
	template<typename A, typename B>
	 inline constexpr vec<3, T>::vec(A _x, vec<2, B> const& _yz)
		: x(static_cast<T>(_x))
		, y(static_cast<T>(_yz.x))
		, z(static_cast<T>(_yz.y))
	{}

	template<typename T>
	template<typename U>
	 inline constexpr vec<3, T>::vec(vec<3, U> const& v)
		: x(static_cast<T>(v.x))
		, y(static_cast<T>(v.y))
		, z(static_cast<T>(v.z))
	{}

	template<typename T>
	template<typename U>
	 inline constexpr vec<3, T>::vec(vec<4, U> const& v)
		: x(static_cast<T>(v.x))
		, y(static_cast<T>(v.y))
		, z(static_cast<T>(v.z))
	{}

	

	template<typename T>
	 inline constexpr T & vec<3, T>::operator[](typename vec<3, T>::length_type i)
	{
		(void)( (!!(i >= 0 && i < this->length())) || (_wassert(L"i >= 0 && i < this->length()", L"C:\\Projects\\glm\\glm\\detail\\type_vec3.inl", (unsigned)(74)), 0) );
		switch(i)
		{
		default:
			case 0:
		return x;
			case 1:
		return y;
			case 2:
		return z;
		}
	}

	template<typename T>
	 inline constexpr T const& vec<3, T>::operator[](typename vec<3, T>::length_type i) const
	{
		(void)( (!!(i >= 0 && i < this->length())) || (_wassert(L"i >= 0 && i < this->length()", L"C:\\Projects\\glm\\glm\\detail\\type_vec3.inl", (unsigned)(90)), 0) );
		switch(i)
		{
		default:
		case 0:
			return x;
		case 1:
			return y;
		case 2:
			return z;
		}
	}

	










#line 115 "C:\\Projects\\glm\\glm\\detail\\type_vec3.inl"

	template<typename T>
	
	 inline constexpr vec<3, T> & vec<3, T>::operator+=(T scalar)
	{
		this->x += static_cast<T>(scalar);
		this->y += static_cast<T>(scalar);
		this->z += static_cast<T>(scalar);
		return *this;
	}

	template<typename T>
	 inline constexpr vec<3, T> & vec<3, T>::operator+=(vec<3, T> const& v)
	{
		this->x += static_cast<T>(v.x);
		this->y += static_cast<T>(v.y);
		this->z += static_cast<T>(v.z);
		return *this;
	}

	template<typename T>
	 inline constexpr vec<3, T> & vec<3, T>::operator-=(T scalar)
	{
		this->x -= static_cast<T>(scalar);
		this->y -= static_cast<T>(scalar);
		this->z -= static_cast<T>(scalar);
		return *this;
	}

	template<typename T>	
	 inline constexpr vec<3, T> & vec<3, T>::operator-=(vec<3, T> const& v)
	{
		this->x -= static_cast<T>(v.x);
		this->y -= static_cast<T>(v.y);
		this->z -= static_cast<T>(v.z);
		return *this;
	}

	template<typename T>
	
	 inline constexpr vec<3, T> & vec<3, T>::operator*=(T  scalar)
	{
		this->x *= static_cast<T>(scalar);
		this->y *= static_cast<T>(scalar);
		this->z *= static_cast<T>(scalar);
		return *this;
	}

	template<typename T>	
	 inline constexpr vec<3, T> & vec<3, T>::operator*=(vec<3, T> const& v)
	{
		this->x *= static_cast<T>(v.x);
		this->y *= static_cast<T>(v.y);
		this->z *= static_cast<T>(v.z);
		return *this;
	}

	template<typename T>
	 inline constexpr vec<3, T> & vec<3, T>::operator/=(T v)
	{
		this->x /= static_cast<T>(v);
		this->y /= static_cast<T>(v);
		this->z /= static_cast<T>(v);
		return *this;
	}

	template<typename T>
	 inline constexpr vec<3, T> & vec<3, T>::operator/=(vec<3, T> const& v)
	{
		this->x /= static_cast<T>(v.x);
		this->y /= static_cast<T>(v.y);
		this->z /= static_cast<T>(v.z);
		return *this;
	}

	

	template<typename T>
	 inline constexpr vec<3, T> operator+(vec<3, T> const& v)
	{
		return v;
	}

	template<typename T>
	 inline constexpr vec<3, T> operator-(vec<3, T> const& v)
	{
		return vec<3, T>(
			-v.x,
			-v.y,
			-v.z);
	}

	

	template<typename T>
	 inline constexpr vec<3, T> operator+(vec<3, T> const& v, T scalar)
	{
		return vec<3, T>(
			v.x + scalar,
			v.y + scalar,
			v.z + scalar);
	}

	template<typename T>
	 inline constexpr vec<3, T> operator+(vec<3, T> const& v, vec<1, T> const& scalar)
	{
		return vec<3, T>(
			v.x + scalar.x,
			v.y + scalar.x,
			v.z + scalar.x);
	}

	template<typename T>
	 inline constexpr vec<3, T> operator+(T scalar, vec<3, T> const& v)
	{
		return vec<3, T>(
			scalar + v.x,
			scalar + v.y,
			scalar + v.z);
	}

	template<typename T>
	 inline constexpr vec<3, T> operator+(vec<1, T> const& scalar, vec<3, T> const& v)
	{
		return vec<3, T>(
			scalar.x + v.x,
			scalar.x + v.y,
			scalar.x + v.z);
	}

	template<typename T>
	 inline constexpr vec<3, T> operator+(vec<3, T> const& v1, vec<3, T> const& v2)
	{
		return vec<3, T>(
			v1.x + v2.x,
			v1.y + v2.y,
			v1.z + v2.z);
	}

	template<typename T>
	 inline constexpr vec<3, T> operator-(vec<3, T> const& v, T scalar)
	{
		return vec<3, T>(
			v.x - scalar,
			v.y - scalar,
			v.z - scalar);
	}

	template<typename T>
	 inline constexpr vec<3, T> operator-(vec<3, T> const& v, vec<1, T> const& scalar)
	{
		return vec<3, T>(
			v.x - scalar.x,
			v.y - scalar.x,
			v.z - scalar.x);
	}

	template<typename T>
	 inline constexpr vec<3, T> operator-(T scalar, vec<3, T> const& v)
	{
		return vec<3, T>(
			scalar - v.x,
			scalar - v.y,
			scalar - v.z);
	}

	template<typename T>
	 inline constexpr vec<3, T> operator-(vec<1, T> const& scalar, vec<3, T> const& v)
	{
		return vec<3, T>(
			scalar.x - v.x,
			scalar.x - v.y,
			scalar.x - v.z);
	}

	template<typename T>
	 inline constexpr vec<3, T> operator-(vec<3, T> const& v1, vec<3, T> const& v2)
	{
		return vec<3, T>(
			v1.x - v2.x,
			v1.y - v2.y,
			v1.z - v2.z);
	}

	template<typename T>
	 inline constexpr vec<3, T> operator*(vec<3, T> const& v, T scalar)
	{
		return vec<3, T>(
			v.x * scalar,
			v.y * scalar,
			v.z * scalar);
	}

	template<typename T>
	 inline constexpr vec<3, T> operator*(vec<3, T> const& v, vec<1, T> const& scalar)
	{
		return vec<3, T>(
			v.x * scalar.x,
			v.y * scalar.x,
			v.z * scalar.x);
	}

	template<typename T>
	 inline constexpr vec<3, T> operator*(T scalar, vec<3, T> const& v)
	{
		return vec<3, T>(
			scalar * v.x,
			scalar * v.y,
			scalar * v.z);
	}

	template<typename T>
	 inline constexpr vec<3, T> operator*(vec<1, T> const& scalar, vec<3, T> const& v)
	{
		return vec<3, T>(
			scalar.x * v.x,
			scalar.x * v.y,
			scalar.x * v.z);
	}

	template<typename T>
	 inline constexpr vec<3, T> operator*(vec<3, T> const& v1, vec<3, T> const& v2)
	{
		return vec<3, T>(
			v1.x * v2.x,
			v1.y * v2.y,
			v1.z * v2.z);
	}

	template<typename T>
	 inline constexpr vec<3, T> operator/(vec<3, T> const& v, T scalar)
	{
		return vec<3, T>(
			v.x / scalar,
			v.y / scalar,
			v.z / scalar);
	}

	template<typename T>
	 inline constexpr vec<3, T> operator/(vec<3, T> const& v, vec<1, T> const& scalar)
	{
		return vec<3, T>(
			v.x / scalar.x,
			v.y / scalar.x,
			v.z / scalar.x);
	}

	template<typename T>
	 inline constexpr vec<3, T> operator/(T scalar, vec<3, T> const& v)
	{
		return vec<3, T>(
			scalar / v.x,
			scalar / v.y,
			scalar / v.z);
	}

	template<typename T>
	 inline constexpr vec<3, T> operator/(vec<1, T> const& scalar, vec<3, T> const& v)
	{
		return vec<3, T>(
			scalar.x / v.x,
			scalar.x / v.y,
			scalar.x / v.z);
	}

	template<typename T>
	 inline constexpr vec<3, T> operator/(vec<3, T> const& v1, vec<3, T> const& v2)
	{
		return vec<3, T>(
			v1.x / v2.x,
			v1.y / v2.y,
			v1.z / v2.z);
	}

	

	template<typename T>
	 inline constexpr vec<3, T> operator%(vec<3, T> const& v, T scalar)
	{
		return vec<3, T>(
			v.x % scalar,
			v.y % scalar,
			v.z % scalar);
	}

	template<typename T>
	 inline constexpr vec<3, T> operator%(vec<3, T> const& v, vec<1, T> const& scalar)
	{
		return vec<3, T>(
			v.x % scalar.x,
			v.y % scalar.x,
			v.z % scalar.x);
	}

	template<typename T>
	 inline constexpr vec<3, T> operator%(T scalar, vec<3, T> const& v)
	{
		return vec<3, T>(
			scalar % v.x,
			scalar % v.y,
			scalar % v.z);
	}

	template<typename T>
	 inline constexpr vec<3, T> operator%(vec<1, T> const& scalar, vec<3, T> const& v)
	{
		return vec<3, T>(
			scalar.x % v.x,
			scalar.x % v.y,
			scalar.x % v.z);
	}

	template<typename T>
	 inline constexpr vec<3, T> operator%(vec<3, T> const& v1, vec<3, T> const& v2)
	{
		return vec<3, T>(
			v1.x % v2.x,
			v1.y % v2.y,
			v1.z % v2.z);
	}

	template<typename T>
	 inline constexpr vec<3, T> operator&(vec<3, T> const& v, T scalar)
	{
		return vec<3, T>(
			v.x & scalar,
			v.y & scalar,
			v.z & scalar);
	}

	template<typename T>
	 inline constexpr vec<3, T> operator&(vec<3, T> const& v, vec<1, T> const& scalar)
	{
		return vec<3, T>(
			v.x & scalar.x,
			v.y & scalar.x,
			v.z & scalar.x);
	}

	template<typename T>
	 inline constexpr vec<3, T> operator&(T scalar, vec<3, T> const& v)
	{
		return vec<3, T>(
			scalar & v.x,
			scalar & v.y,
			scalar & v.z);
	}

	template<typename T>
	 inline constexpr vec<3, T> operator&(vec<1, T> const& scalar, vec<3, T> const& v)
	{
		return vec<3, T>(
			scalar.x & v.x,
			scalar.x & v.y,
			scalar.x & v.z);
	}

	template<typename T>
	 inline constexpr vec<3, T> operator&(vec<3, T> const& v1, vec<3, T> const& v2)
	{
		return vec<3, T>(
			v1.x & v2.x,
			v1.y & v2.y,
			v1.z & v2.z);
	}

	template<typename T>
	 inline constexpr vec<3, T> operator|(vec<3, T> const& v, T scalar)
	{
		return vec<3, T>(
			v.x | scalar,
			v.y | scalar,
			v.z | scalar);
	}

	template<typename T>
	 inline constexpr vec<3, T> operator|(vec<3, T> const& v, vec<1, T> const& scalar)
	{
		return vec<3, T>(
			v.x | scalar.x,
			v.y | scalar.x,
			v.z | scalar.x);
	}

	template<typename T>
	 inline constexpr vec<3, T> operator|(T scalar, vec<3, T> const& v)
	{
		return vec<3, T>(
			scalar | v.x,
			scalar | v.y,
			scalar | v.z);
	}

	template<typename T>
	 inline constexpr vec<3, T> operator|(vec<1, T> const& scalar, vec<3, T> const& v)
	{
		return vec<3, T>(
			scalar.x | v.x,
			scalar.x | v.y,
			scalar.x | v.z);
	}

	template<typename T>
	 inline constexpr vec<3, T> operator|(vec<3, T> const& v1, vec<3, T> const& v2)
	{
		return vec<3, T>(
			v1.x | v2.x,
			v1.y | v2.y,
			v1.z | v2.z);
	}

	template<typename T>
	 inline constexpr vec<3, T> operator^(vec<3, T> const& v, T scalar)
	{
		return vec<3, T>(
			v.x ^ scalar,
			v.y ^ scalar,
			v.z ^ scalar);
	}

	template<typename T>
	 inline constexpr vec<3, T> operator^(vec<3, T> const& v, vec<1, T> const& scalar)
	{
		return vec<3, T>(
			v.x ^ scalar.x,
			v.y ^ scalar.x,
			v.z ^ scalar.x);
	}

	template<typename T>
	 inline constexpr vec<3, T> operator^(T scalar, vec<3, T> const& v)
	{
		return vec<3, T>(
			scalar ^ v.x,
			scalar ^ v.y,
			scalar ^ v.z);
	}

	template<typename T>
	 inline constexpr vec<3, T> operator^(vec<1, T> const& scalar, vec<3, T> const& v)
	{
		return vec<3, T>(
			scalar.x ^ v.x,
			scalar.x ^ v.y,
			scalar.x ^ v.z);
	}

	template<typename T>
	 inline constexpr vec<3, T> operator^(vec<3, T> const& v1, vec<3, T> const& v2)
	{
		return vec<3, T>(
			v1.x ^ v2.x,
			v1.y ^ v2.y,
			v1.z ^ v2.z);
	}

	template<typename T>
	 inline constexpr vec<3, T> operator<<(vec<3, T> const& v, T scalar)
	{
		return vec<3, T>(
			v.x << scalar,
			v.y << scalar,
			v.z << scalar);
	}

	template<typename T>
	 inline constexpr vec<3, T> operator<<(vec<3, T> const& v, vec<1, T> const& scalar)
	{
		return vec<3, T>(
			v.x << scalar.x,
			v.y << scalar.x,
			v.z << scalar.x);
	}

	template<typename T>
	 inline constexpr vec<3, T> operator<<(T scalar, vec<3, T> const& v)
	{
		return vec<3, T>(
			scalar << v.x,
			scalar << v.y,
			scalar << v.z);
	}

	template<typename T>
	 inline constexpr vec<3, T> operator<<(vec<1, T> const& scalar, vec<3, T> const& v)
	{
		return vec<3, T>(
			scalar.x << v.x,
			scalar.x << v.y,
			scalar.x << v.z);
	}

	template<typename T>
	 inline constexpr vec<3, T> operator<<(vec<3, T> const& v1, vec<3, T> const& v2)
	{
		return vec<3, T>(
			v1.x << v2.x,
			v1.y << v2.y,
			v1.z << v2.z);
	}

	template<typename T>
	 inline constexpr vec<3, T> operator>>(vec<3, T> const& v, T scalar)
	{
		return vec<3, T>(
			v.x >> scalar,
			v.y >> scalar,
			v.z >> scalar);
	}

	template<typename T>
	 inline constexpr vec<3, T> operator>>(vec<3, T> const& v, vec<1, T> const& scalar)
	{
		return vec<3, T>(
			v.x >> scalar.x,
			v.y >> scalar.x,
			v.z >> scalar.x);
	}

	template<typename T>
	 inline constexpr vec<3, T> operator>>(T scalar, vec<3, T> const& v)
	{
		return vec<3, T>(
			scalar >> v.x,
			scalar >> v.y,
			scalar >> v.z);
	}

	template<typename T>
	 inline constexpr vec<3, T> operator>>(vec<1, T> const& scalar, vec<3, T> const& v)
	{
		return vec<3, T>(
			scalar.x >> v.x,
			scalar.x >> v.y,
			scalar.x >> v.z);
	}

	template<typename T>
	 inline constexpr vec<3, T> operator>>(vec<3, T> const& v1, vec<3, T> const& v2)
	{
		return vec<3, T>(
			v1.x >> v2.x,
			v1.y >> v2.y,
			v1.z >> v2.z);
	}

	template<typename T>
	 inline constexpr vec<3, T> operator~(vec<3, T> const& v)
	{
		return vec<3, T>(
			~v.x,
			~v.y,
			~v.z);
	}

	

	template<typename T>
	 inline constexpr bool operator==(vec<3, T> const& v1, vec<3, T> const& v2)
	{
		return
			detail::compute_equal<T, std::numeric_limits<T>::is_iec559>::call(v1.x, v2.x) &&
			detail::compute_equal<T, std::numeric_limits<T>::is_iec559>::call(v1.y, v2.y) &&
			detail::compute_equal<T, std::numeric_limits<T>::is_iec559>::call(v1.z, v2.z);
	}

	template<typename T>
	 inline constexpr bool operator!=(vec<3, T> const& v1, vec<3, T> const& v2)
	{
		return !(v1 == v2);
	}

	 inline constexpr vec<3, bool> operator&&(vec<3, bool> const& v1, vec<3, bool> const& v2)
	{
		return vec<3, bool>(v1.x && v2.x, v1.y && v2.y, v1.z && v2.z);
	}

	 inline constexpr vec<3, bool> operator||(vec<3, bool> const& v1, vec<3, bool> const& v2)
	{
		return vec<3, bool>(v1.x || v2.x, v1.y || v2.y, v1.z || v2.z);
	}
}
#line 227 "C:\\Projects\\glm\\glm\\ext\\../detail/type_vec3.hpp"
#line 228 "C:\\Projects\\glm\\glm\\ext\\../detail/type_vec3.hpp"
#line 6 "C:\\Projects\\glm\\glm\\./ext/vector_bool3.hpp"

namespace glm
{
	
	

	
	
	
	typedef vec<3, bool>		bvec3;

	
}
#line 6 "C:\\Projects\\glm\\glm\\vec3.hpp"
#line 1 "C:\\Projects\\glm\\glm\\./ext/vector_float3.hpp"



#pragma once


namespace glm
{
	
	

	
	
	
	typedef vec<3, float>		vec3;

	
}
#line 7 "C:\\Projects\\glm\\glm\\vec3.hpp"
#line 1 "C:\\Projects\\glm\\glm\\./ext/vector_double3.hpp"



#pragma once


namespace glm
{
	
	

	
	
	
	typedef vec<3, double>		dvec3;

	
}
#line 8 "C:\\Projects\\glm\\glm\\vec3.hpp"
#line 1 "C:\\Projects\\glm\\glm\\./ext/vector_int3.hpp"



#pragma once


namespace glm
{
	
	

	
	
	
	typedef vec<3, int>		ivec3;

	
}
#line 9 "C:\\Projects\\glm\\glm\\vec3.hpp"
#line 1 "C:\\Projects\\glm\\glm\\./ext/vector_uint3.hpp"



#pragma once


namespace glm
{
	
	

	
	
	
	typedef vec<3, unsigned int>		uvec3;

	
}
#line 10 "C:\\Projects\\glm\\glm\\vec3.hpp"
#line 6 ".\\glm_impl.cpp"
#line 1 "C:\\Projects\\glm\\glm\\vec4.hpp"



#pragma once
#line 1 "C:\\Projects\\glm\\glm\\./ext/vector_bool4.hpp"



#pragma once
#line 1 "C:\\Projects\\glm\\glm\\ext\\../detail/type_vec4.hpp"



#pragma once



#line 9 "C:\\Projects\\glm\\glm\\ext\\../detail/type_vec4.hpp"

#line 11 "C:\\Projects\\glm\\glm\\ext\\../detail/type_vec4.hpp"


namespace glm
{
	template<typename T>
	struct vec<4, T>
	{
		

		typedef T value_type;
		typedef vec<4, T> type;
		typedef vec<4, bool> bool_type;

		













#line 39 "C:\\Projects\\glm\\glm\\ext\\../detail/type_vec4.hpp"



#line 43 "C:\\Projects\\glm\\glm\\ext\\../detail/type_vec4.hpp"




















#line 64 "C:\\Projects\\glm\\glm\\ext\\../detail/type_vec4.hpp"
			union { T x, r, s; };
			union { T y, g, t; };
			union { T z, b, p; };
			union { T w, a, q; };



#line 72 "C:\\Projects\\glm\\glm\\ext\\../detail/type_vec4.hpp"
#line 73 "C:\\Projects\\glm\\glm\\ext\\../detail/type_vec4.hpp"









#line 83 "C:\\Projects\\glm\\glm\\ext\\../detail/type_vec4.hpp"

		

		typedef length_t length_type;

		
		 static constexpr length_type length(){return 4;}

		 constexpr T & operator[](length_type i);
		 constexpr T const& operator[](length_type i) const;

		

		 constexpr vec() = default;
		 constexpr vec(vec<4, T> const& v) = default;

		

		 constexpr explicit vec(T scalar);
		 constexpr vec(T x, T y, T z, T w);

		

		
		template<typename A, typename B, typename C>
		 constexpr vec(vec<2, A> const& _xy, B _z, C _w);
		
		template<typename A, typename B, typename C>
		 constexpr vec(A _x, vec<2, B> const& _yz, C _w);
		
		template<typename A, typename B, typename C>
		 constexpr vec(A _x, B _y, vec<2, C> const& _zw);
		
		template<typename A, typename B>
		 constexpr vec(vec<3, A> const& _xyz, B _w);
		
		template<typename A, typename B>
		 constexpr vec(A _x, vec<3, B> const& _yzw);
		
		template<typename A, typename B>
		 constexpr vec(vec<2, A> const& _xy, vec<2, B> const& _zw);

		
		template<typename U>
		 constexpr  vec(vec<4, U> const& v);

		










































#line 173 "C:\\Projects\\glm\\glm\\ext\\../detail/type_vec4.hpp"

		

		 constexpr vec<4, T>& operator=(vec<4, T> const& v) = default;
	
		 constexpr vec<4, T>& operator+=(T scalar);
		
		 constexpr vec<4, T>& operator+=(vec const& v);
		
		 constexpr vec<4, T>& operator-=(T scalar);
		
		 constexpr vec<4, T>& operator-=(vec const& v);
		
		 constexpr vec<4, T>& operator*=(T scalar);
		
		 constexpr vec<4, T>& operator*=(vec const& v);
		
		 constexpr vec<4, T>& operator/=(T scalar);
		
		 constexpr vec<4, T>& operator/=(vec const& v);
	};

	

	template<typename T>
	 constexpr vec<4, T> operator+(vec<4, T> const& v);

	template<typename T>
	 constexpr vec<4, T> operator-(vec<4, T> const& v);

	

	template<typename T>
	 constexpr vec<4, T> operator+(vec<4, T> const& v, T const & scalar);

	template<typename T>
	 constexpr vec<4, T> operator+(T scalar, vec<4, T> const& v);

	template<typename T>
	 constexpr vec<4, T> operator+(vec<4, T> const& v1, vec<4, T> const& v2);

	template<typename T>
	 constexpr vec<4, T> operator-(vec<4, T> const& v, T const & scalar);

	template<typename T>
	 constexpr vec<4, T> operator-(T scalar, vec<4, T> const& v);

	template<typename T>
	 constexpr vec<4, T> operator-(vec<4, T> const& v1, vec<4, T> const& v2);

	template<typename T>
	 constexpr vec<4, T> operator*(vec<4, T> const& v, T const & scalar);

	template<typename T>
	 constexpr vec<4, T> operator*(T scalar, vec<4, T> const& v);

	template<typename T>
	 constexpr vec<4, T> operator*(vec<4, T> const& v1, vec<4, T> const& v2);

	template<typename T>
	 constexpr vec<4, T> operator/(vec<4, T> const& v, T const & scalar);

	template<typename T>
	 constexpr vec<4, T> operator/(T scalar, vec<4, T> const& v);

	template<typename T>
	 constexpr vec<4, T> operator/(vec<4, T> const& v1, vec<4, T> const& v2);

	

	template<typename T>
	 constexpr bool operator==(vec<4, T> const& v1, vec<4, T> const& v2);

	template<typename T>
	 constexpr bool operator!=(vec<4, T> const& v1, vec<4, T> const& v2);

	 constexpr vec<4, bool> operator&&(vec<4, bool> const& v1, vec<4, bool> const& v2);

	 constexpr vec<4, bool> operator||(vec<4, bool> const& v1, vec<4, bool> const& v2);
}


#line 1 "C:\\Projects\\glm\\glm\\detail\\type_vec4.inl"




namespace glm{
namespace detail
{
	template<typename T, bool Aligned>
	struct compute_vec4_add
	{
		 inline constexpr static vec<4, T> call(vec<4, T> const& a, vec<4, T> const& b)
		{
			return vec<4, T>(a.x + b.x, a.y + b.y, a.z + b.z, a.w + b.w);
		}
	};

	template<typename T, bool Aligned>
	struct compute_vec4_sub
	{
		 inline constexpr static vec<4, T> call(vec<4, T> const& a, vec<4, T> const& b)
		{
			return vec<4, T>(a.x - b.x, a.y - b.y, a.z - b.z, a.w - b.w);
		}
	};

	template<typename T, bool Aligned>
	struct compute_vec4_mul
	{
		 inline constexpr static vec<4, T> call(vec<4, T> const& a, vec<4, T> const& b)
		{
			return vec<4, T>(a.x * b.x, a.y * b.y, a.z * b.z, a.w * b.w);
		}
	};

	template<typename T, bool Aligned>
	struct compute_vec4_div
	{
		 inline constexpr static vec<4, T> call(vec<4, T> const& a, vec<4, T> const& b)
		{
			return vec<4, T>(a.x / b.x, a.y / b.y, a.z / b.z, a.w / b.w);
		}
	};

	template<typename T, bool Aligned>
	struct compute_vec4_mod
	{
		 inline constexpr static vec<4, T> call(vec<4, T> const& a, vec<4, T> const& b)
		{
			return vec<4, T>(a.x % b.x, a.y % b.y, a.z % b.z, a.w % b.w);
		}
	};

	template<typename T, int IsInt, std::size_t Size, bool Aligned>
	struct compute_vec4_and
	{
		 inline constexpr static vec<4, T> call(vec<4, T> const& a, vec<4, T> const& b)
		{
			return vec<4, T>(a.x & b.x, a.y & b.y, a.z & b.z, a.w & b.w);
		}
	};

	template<typename T, int IsInt, std::size_t Size, bool Aligned>
	struct compute_vec4_or
	{
		 inline constexpr static vec<4, T> call(vec<4, T> const& a, vec<4, T> const& b)
		{
			return vec<4, T>(a.x | b.x, a.y | b.y, a.z | b.z, a.w | b.w);
		}
	};

	template<typename T, int IsInt, std::size_t Size, bool Aligned>
	struct compute_vec4_xor
	{
		 inline constexpr static vec<4, T> call(vec<4, T> const& a, vec<4, T> const& b)
		{
			return vec<4, T>(a.x ^ b.x, a.y ^ b.y, a.z ^ b.z, a.w ^ b.w);
		}
	};

	template<typename T, int IsInt, std::size_t Size, bool Aligned>
	struct compute_vec4_shift_left
	{
		 inline constexpr static vec<4, T> call(vec<4, T> const& a, vec<4, T> const& b)
		{
			return vec<4, T>(a.x << b.x, a.y << b.y, a.z << b.z, a.w << b.w);
		}
	};

	template<typename T, int IsInt, std::size_t Size, bool Aligned>
	struct compute_vec4_shift_right
	{
		 inline constexpr static vec<4, T> call(vec<4, T> const& a, vec<4, T> const& b)
		{
			return vec<4, T>(a.x >> b.x, a.y >> b.y, a.z >> b.z, a.w >> b.w);
		}
	};

	template<typename T, int IsInt, std::size_t Size, bool Aligned>
	struct compute_vec4_equal
	{
		 inline constexpr static bool call(vec<4, T> const& v1, vec<4, T> const& v2)
		{
			return
				detail::compute_equal<T, std::numeric_limits<T>::is_iec559>::call(v1.x, v2.x) &&
				detail::compute_equal<T, std::numeric_limits<T>::is_iec559>::call(v1.y, v2.y) &&
				detail::compute_equal<T, std::numeric_limits<T>::is_iec559>::call(v1.z, v2.z) &&
				detail::compute_equal<T, std::numeric_limits<T>::is_iec559>::call(v1.w, v2.w);
		}
	};

	template<typename T, int IsInt, std::size_t Size, bool Aligned>
	struct compute_vec4_nequal
	{
		 inline constexpr static bool call(vec<4, T> const& v1, vec<4, T> const& v2)
		{
			return !compute_vec4_equal<T, detail::is_int<T>::value, sizeof(T) * 8, false>::call(v1, v2);
		}
	};

	template<typename T, int IsInt, std::size_t Size, bool Aligned>
	struct compute_vec4_bitwise_not
	{
		 inline constexpr static vec<4, T> call(vec<4, T> const& v)
		{
			return vec<4, T>(~v.x, ~v.y, ~v.z, ~v.w);
		}
	};
}

	













#line 145 "C:\\Projects\\glm\\glm\\detail\\type_vec4.inl"

	

	template<typename T>
	 inline constexpr vec<4, T>::vec(T scalar)
		: x(scalar), y(scalar), z(scalar), w(scalar)
	{}

	template <typename T>
	 inline constexpr vec<4, T>::vec(T _x, T _y, T _z, T _w)
		: x(_x), y(_y), z(_z), w(_w)
	{}

	

	template<typename T>
	template<typename A, typename B, typename C>
	 inline constexpr vec<4, T>::vec(vec<2, A> const& _xy, B _z, C _w)
		: x(static_cast<T>(_xy.x))
		, y(static_cast<T>(_xy.y))
		, z(static_cast<T>(_z))
		, w(static_cast<T>(_w))
	{}

	template<typename T>
	template<typename A, typename B, typename C>
	 inline constexpr vec<4, T>::vec(A _x, vec<2, B> const& _yz, C _w)
		: x(static_cast<T>(_x))
		, y(static_cast<T>(_yz.x))
		, z(static_cast<T>(_yz.y))
		, w(static_cast<T>(_w))
	{}

	template<typename T>
	template<typename A, typename B, typename C>
	 inline constexpr vec<4, T>::vec(A _x, B _y, vec<2, C> const& _zw)
		: x(static_cast<T>(_x))
		, y(static_cast<T>(_y))
		, z(static_cast<T>(_zw.x))
		, w(static_cast<T>(_zw.y))
	{}

	template<typename T>
	template<typename A, typename B>
	 inline constexpr vec<4, T>::vec(vec<3, A> const& _xyz, B _w)
		: x(static_cast<T>(_xyz.x))
		, y(static_cast<T>(_xyz.y))
		, z(static_cast<T>(_xyz.z))
		, w(static_cast<T>(_w))
	{}

	template<typename T>
	template<typename A, typename B>
	 inline constexpr vec<4, T>::vec(A _x, vec<3, B> const& _yzw)
		: x(static_cast<T>(_x))
		, y(static_cast<T>(_yzw.x))
		, z(static_cast<T>(_yzw.y))
		, w(static_cast<T>(_yzw.z))
	{}

	template<typename T>
	template<typename A, typename B>
	 inline constexpr vec<4, T>::vec(vec<2, A> const& _xy, vec<2, B> const& _zw)
		: x(static_cast<T>(_xy.x))
		, y(static_cast<T>(_xy.y))
		, z(static_cast<T>(_zw.x))
		, w(static_cast<T>(_zw.y))
	{}

	template<typename T>
	template<typename U>
	 inline constexpr vec<4, T>::vec(vec<4, U> const& v)
		: x(static_cast<T>(v.x))
		, y(static_cast<T>(v.y))
		, z(static_cast<T>(v.z))
		, w(static_cast<T>(v.w))
	{}

	

	template<typename T>
	 inline constexpr T& vec<4, T>::operator[](typename vec<4, T>::length_type i)
	{
		(void)( (!!(i >= 0 && i < this->length())) || (_wassert(L"i >= 0 && i < this->length()", L"C:\\Projects\\glm\\glm\\detail\\type_vec4.inl", (unsigned)(228)), 0) );
		switch(i)
		{
		default:
		case 0:
			return x;
		case 1:
			return y;
		case 2:
			return z;
		case 3:
			return w;
		}
	}

	template<typename T>
	 inline constexpr T const& vec<4, T>::operator[](typename vec<4, T>::length_type i) const
	{
		(void)( (!!(i >= 0 && i < this->length())) || (_wassert(L"i >= 0 && i < this->length()", L"C:\\Projects\\glm\\glm\\detail\\type_vec4.inl", (unsigned)(246)), 0) );
		switch(i)
		{
		default:
		case 0:
			return x;
		case 1:
			return y;
		case 2:
			return z;
		case 3:
			return w;
		}
	}

	











#line 274 "C:\\Projects\\glm\\glm\\detail\\type_vec4.inl"

	template<typename T>
	 inline constexpr vec<4, T> & vec<4, T>::operator+=(T scalar)
	{
		return (*this = detail::compute_vec4_add<T, false>::call(*this, vec<4, T>(scalar)));
	}

	template<typename T>
	 inline constexpr vec<4, T> & vec<4, T>::operator+=(vec<4, T> const& v)
	{
		return (*this = detail::compute_vec4_add<T, false>::call(*this, vec<4, T>(v)));
	}

	template<typename T>
	 inline constexpr vec<4, T> & vec<4, T>::operator-=(T scalar)
	{
		return (*this = detail::compute_vec4_sub<T, false>::call(*this, vec<4, T>(scalar)));
	}

	template<typename T>
	 inline constexpr vec<4, T> & vec<4, T>::operator-=(vec<4, T> const& v)
	{
		return (*this = detail::compute_vec4_sub<T, false>::call(*this, vec<4, T>(v)));
	}

	template<typename T>
	 inline constexpr vec<4, T> & vec<4, T>::operator*=(T scalar)
	{
		return (*this = detail::compute_vec4_mul<T, false>::call(*this, vec<4, T>(scalar)));
	}

	template<typename T>
	 inline constexpr vec<4, T> & vec<4, T>::operator*=(vec<4, T> const& v)
	{
		return (*this = detail::compute_vec4_mul<T, false>::call(*this, vec<4, T>(v)));
	}

	template<typename T>
	 inline constexpr vec<4, T> & vec<4, T>::operator/=(T scalar)
	{
		return (*this = detail::compute_vec4_div<T, false>::call(*this, vec<4, T>(scalar)));
	}

	
	template<typename T>
	 inline constexpr vec<4, T> & vec<4, T>::operator/=(vec<4, T> const& v)
	{
		return (*this = detail::compute_vec4_div<T, false>::call(*this, vec<4, T>(v)));
	}

	

	template<typename T>
	 inline constexpr vec<4, T> operator+(vec<4, T> const& v)
	{
		return v;
	}

	template<typename T>
	 inline constexpr vec<4, T> operator-(vec<4, T> const& v)
	{
		return vec<4, T>(0) -= v;
	}

	

	template<typename T>
	 inline constexpr vec<4, T> operator+(vec<4, T> const& v, T const & scalar)
	{
		return vec<4, T>(v) += scalar;
	}

	template<typename T>
	 inline constexpr vec<4, T> operator+(T scalar, vec<4, T> const& v)
	{
		return vec<4, T>(v) += scalar;
	}

	template<typename T>
	 inline constexpr vec<4, T> operator+(vec<4, T> const& v1, vec<4, T> const& v2)
	{
		return vec<4, T>(v1) += v2;
	}

	template<typename T>
	 inline constexpr vec<4, T> operator-(vec<4, T> const& v, T const & scalar)
	{
		return vec<4, T>(v) -= scalar;
	}

	template<typename T>
	 inline constexpr vec<4, T> operator-(T scalar, vec<4, T> const& v)
	{
		return vec<4, T>(scalar) -= v;
	}

	template<typename T>
	 inline constexpr vec<4, T> operator-(vec<4, T> const& v1, vec<4, T> const& v2)
	{
		return vec<4, T>(v1) -= v2;
	}

	template<typename T>
	 inline constexpr vec<4, T> operator*(vec<4, T> const& v, T const & scalar)
	{
		return vec<4, T>(v) *= scalar;
	}

	template<typename T>
	 inline constexpr vec<4, T> operator*(T scalar, vec<4, T> const& v)
	{
		return vec<4, T>(v) *= scalar;
	}

	template<typename T>
	 inline constexpr vec<4, T> operator*(vec<4, T> const& v1, vec<4, T> const& v2)
	{
		return vec<4, T>(v1) *= v2;
	}

	template<typename T>
	 inline constexpr vec<4, T> operator/(vec<4, T> const& v, T const & scalar)
	{
		return vec<4, T>(v) /= scalar;
	}

	template<typename T>
	 inline constexpr vec<4, T> operator/(T scalar, vec<4, T> const& v)
	{
		return vec<4, T>(scalar) /= v;
	}

	template<typename T>
	 inline constexpr vec<4, T> operator/(vec<4, T> const& v1, vec<4, T> const& v2)
	{
		return vec<4, T>(v1) /= v2;
	}

	

	template<typename T>
	 inline constexpr bool operator==(vec<4, T> const& v1, vec<4, T> const& v2)
	{
		return detail::compute_vec4_equal<T, detail::is_int<T>::value, sizeof(T) * 8, false>::call(v1, v2);
	}

	template<typename T>
	 inline constexpr bool operator!=(vec<4, T> const& v1, vec<4, T> const& v2)
	{
		return detail::compute_vec4_nequal<T, detail::is_int<T>::value, sizeof(T) * 8, false>::call(v1, v2);
	}

	 inline constexpr vec<4, bool> operator&&(vec<4, bool> const& v1, vec<4, bool> const& v2)
	{
		return vec<4, bool>(v1.x && v2.x, v1.y && v2.y, v1.z && v2.z, v1.w && v2.w);
	}

	 inline constexpr vec<4, bool> operator||(vec<4, bool> const& v1, vec<4, bool> const& v2)
	{
		return vec<4, bool>(v1.x || v2.x, v1.y || v2.y, v1.z || v2.z, v1.w || v2.w);
	}
}



#line 440 "C:\\Projects\\glm\\glm\\detail\\type_vec4.inl"
#line 256 "C:\\Projects\\glm\\glm\\ext\\../detail/type_vec4.hpp"
#line 257 "C:\\Projects\\glm\\glm\\ext\\../detail/type_vec4.hpp"
#line 6 "C:\\Projects\\glm\\glm\\./ext/vector_bool4.hpp"

namespace glm
{
	
	

	
	
	
	typedef vec<4, bool>		bvec4;

	
}
#line 6 "C:\\Projects\\glm\\glm\\vec4.hpp"
#line 1 "C:\\Projects\\glm\\glm\\./ext/vector_float4.hpp"



#pragma once


namespace glm
{
	
	

	
	
	
	typedef vec<4, float>		vec4;

	
}
#line 7 "C:\\Projects\\glm\\glm\\vec4.hpp"
#line 1 "C:\\Projects\\glm\\glm\\./ext/vector_double4.hpp"



#pragma once


namespace glm
{
	
	

	
	
	
	typedef vec<4, double>		dvec4;

	
}
#line 8 "C:\\Projects\\glm\\glm\\vec4.hpp"
#line 1 "C:\\Projects\\glm\\glm\\./ext/vector_int4.hpp"



#pragma once


namespace glm
{
	
	

	
	
	
	typedef vec<4, int>		ivec4;

	
}
#line 9 "C:\\Projects\\glm\\glm\\vec4.hpp"
#line 1 "C:\\Projects\\glm\\glm\\./ext/vector_uint4.hpp"



#pragma once


namespace glm
{
	
	

	
	
	
	typedef vec<4, unsigned int>		uvec4;

	
}
#line 10 "C:\\Projects\\glm\\glm\\vec4.hpp"


#line 7 ".\\glm_impl.cpp"
#line 1 "C:\\Projects\\glm\\glm\\mat3x3.hpp"



#pragma once
#line 1 "C:\\Projects\\glm\\glm\\./ext/matrix_double3x3.hpp"



#pragma once
#line 1 "C:\\Projects\\glm\\glm\\ext\\../detail/type_mat3x3.hpp"



#pragma once





namespace glm
{
	template<typename T>
	struct mat<3, 3, T>
	{
		typedef vec<3, T> col_type;
		typedef vec<3, T> row_type;
		typedef mat<3, 3, T> type;
		typedef mat<3, 3, T> transpose_type;
		typedef T value_type;

	private:
		col_type value[3];

	public:
		

		typedef length_t length_type;
		 static constexpr length_type length() { return 3; }

		 col_type & operator[](length_type i);
		 constexpr col_type const& operator[](length_type i) const;

		

		 constexpr mat() = default;
		 constexpr mat(mat<3, 3, T> const& m);

		 explicit constexpr mat(T scalar);
		 constexpr mat(
			T x0, T y0, T z0,
			T x1, T y1, T z1,
			T x2, T y2, T z2);
		 constexpr mat(
			col_type const& v0,
			col_type const& v1,
			col_type const& v2);

		

		template<
			typename X1, typename Y1, typename Z1,
			typename X2, typename Y2, typename Z2,
			typename X3, typename Y3, typename Z3>
		 constexpr mat(
			X1 x1, Y1 y1, Z1 z1,
			X2 x2, Y2 y2, Z2 z2,
			X3 x3, Y3 y3, Z3 z3);

		template<typename V1, typename V2, typename V3>
		 constexpr mat(
			vec<3, V1> const& v1,
			vec<3, V2> const& v2,
			vec<3, V3> const& v3);

		

		  constexpr mat(mat<2, 2, T> const& x);
		  constexpr mat(mat<4, 4, T> const& x);
		  constexpr mat(mat<2, 3, T> const& x);
		  constexpr mat(mat<3, 2, T> const& x);
		  constexpr mat(mat<2, 4, T> const& x);
		  constexpr mat(mat<4, 2, T> const& x);
		  constexpr mat(mat<3, 4, T> const& x);
		  constexpr mat(mat<4, 3, T> const& x);

		

		template<typename U>
		 mat<3, 3, T> & operator=(mat<3, 3, U> const& m);
		template<typename U>
		 mat<3, 3, T> & operator+=(U s);
		template<typename U>
		 mat<3, 3, T> & operator+=(mat<3, 3, U> const& m);
		template<typename U>
		 mat<3, 3, T> & operator-=(U s);
		template<typename U>
		 mat<3, 3, T> & operator-=(mat<3, 3, U> const& m);
		template<typename U>
		 mat<3, 3, T> & operator*=(U s);
		template<typename U>
		 mat<3, 3, T> & operator*=(mat<3, 3, U> const& m);
		template<typename U>
		 mat<3, 3, T> & operator/=(U s);
		template<typename U>
		 mat<3, 3, T> & operator/=(mat<3, 3, U> const& m);
	};

	

	template<typename T>
	 mat<3, 3, T> operator+(mat<3, 3, T> const& m);

	template<typename T>
	 mat<3, 3, T> operator-(mat<3, 3, T> const& m);

	

	template<typename T>
	 mat<3, 3, T> operator+(mat<3, 3, T> const& m, T scalar);

	template<typename T>
	 mat<3, 3, T> operator+(T scalar, mat<3, 3, T> const& m);

	template<typename T>
	 mat<3, 3, T> operator+(mat<3, 3, T> const& m1, mat<3, 3, T> const& m2);

	template<typename T>
	 mat<3, 3, T> operator-(mat<3, 3, T> const& m, T scalar);

	template<typename T>
	 mat<3, 3, T> operator-(T scalar, mat<3, 3, T> const& m);

	template<typename T>
	 mat<3, 3, T> operator-(mat<3, 3, T> const& m1, mat<3, 3, T> const& m2);

	template<typename T>
	 mat<3, 3, T> operator*(mat<3, 3, T> const& m, T scalar);

	template<typename T>
	 mat<3, 3, T> operator*(T scalar, mat<3, 3, T> const& m);

	template<typename T>
	 typename mat<3, 3, T>::col_type operator*(mat<3, 3, T> const& m, typename mat<3, 3, T>::row_type const& v);

	template<typename T>
	 typename mat<3, 3, T>::row_type operator*(typename mat<3, 3, T>::col_type const& v, mat<3, 3, T> const& m);

	template<typename T>
	 mat<3, 3, T> operator*(mat<3, 3, T> const& m1, mat<3, 3, T> const& m2);

	template<typename T>
	 mat<2, 3, T> operator*(mat<3, 3, T> const& m1, mat<2, 3, T> const& m2);

	template<typename T>
	 mat<4, 3, T> operator*(mat<3, 3, T> const& m1, mat<4, 3, T> const& m2);

	template<typename T>
	 mat<3, 3, T> operator/(mat<3, 3, T> const& m, T scalar);

	template<typename T>
	 mat<3, 3, T> operator/(T scalar, mat<3, 3, T> const& m);

	template<typename T>
	 typename mat<3, 3, T>::col_type operator/(mat<3, 3, T> const& m, typename mat<3, 3, T>::row_type const& v);

	template<typename T>
	 typename mat<3, 3, T>::row_type operator/(typename mat<3, 3, T>::col_type const& v, mat<3, 3, T> const& m);

	template<typename T>
	 mat<3, 3, T> operator/(mat<3, 3, T> const& m1, mat<3, 3, T> const& m2);

	

	template<typename T>
	 constexpr bool operator==(mat<3, 3, T> const& m1, mat<3, 3, T> const& m2);

	template<typename T>
	 bool operator!=(mat<3, 3, T> const& m1, mat<3, 3, T> const& m2);
}


#line 1 "C:\\Projects\\glm\\glm\\detail\\type_mat3x3.inl"
#line 1 "C:\\Projects\\glm\\glm\\detail\\../matrix.hpp"












#pragma once






#line 1 "C:\\Projects\\glm\\glm\\mat2x2.hpp"



#pragma once
#line 1 "C:\\Projects\\glm\\glm\\./ext/matrix_double2x2.hpp"



#pragma once
#line 1 "C:\\Projects\\glm\\glm\\ext\\../detail/type_mat2x2.hpp"



#pragma once





namespace glm
{
	template<typename T>
	struct mat<2, 2, T>
	{
		typedef vec<2, T> col_type;
		typedef vec<2, T> row_type;
		typedef mat<2, 2, T> type;
		typedef mat<2, 2, T> transpose_type;
		typedef T value_type;

	private:
		col_type value[2];

	public:
		

		typedef length_t length_type;
		 static constexpr length_type length() { return 2; }

		 col_type & operator[](length_type i);
		 constexpr col_type const& operator[](length_type i) const;

		

		 constexpr mat() = default;
		 constexpr mat(mat<2, 2, T> const& m);

		 explicit constexpr mat(T scalar);
		 constexpr mat(
			T const& x1, T const& y1,
			T const& x2, T const& y2);
		 constexpr mat(
			col_type const& v1,
			col_type const& v2);

		

		template<typename U, typename V, typename M, typename N>
		 constexpr mat(
			U const& x1, V const& y1,
			M const& x2, N const& y2);

		template<typename U, typename V>
		 constexpr mat(
			vec<2, U> const& v1,
			vec<2, V> const& v2);

		

		  constexpr mat(mat<3, 3, T> const& x);
		  constexpr mat(mat<4, 4, T> const& x);
		  constexpr mat(mat<2, 3, T> const& x);
		  constexpr mat(mat<3, 2, T> const& x);
		  constexpr mat(mat<2, 4, T> const& x);
		  constexpr mat(mat<4, 2, T> const& x);
		  constexpr mat(mat<3, 4, T> const& x);
		  constexpr mat(mat<4, 3, T> const& x);

		

		
		 mat<2, 2, T> & operator=(mat const& m);
		 mat<2, 2, T> & operator+=(T s);
		 mat<2, 2, T> & operator+=(mat const& m);
		 mat<2, 2, T> & operator-=(T s);
		 mat<2, 2, T> & operator-=(mat const& m);
		 mat<2, 2, T> & operator*=(T s);
		 mat<2, 2, T> & operator*=(mat const& m);
		 mat<2, 2, T> & operator/=(T s);
		 mat<2, 2, T> & operator/=(mat const& m);
	};

	

	template<typename T>
	 mat<2, 2, T> operator+(mat<2, 2, T> const& m);

	template<typename T>
	 mat<2, 2, T> operator-(mat<2, 2, T> const& m);

	

	template<typename T>
	 mat<2, 2, T> operator+(mat<2, 2, T> const& m, T scalar);

	template<typename T>
	 mat<2, 2, T> operator+(T scalar, mat<2, 2, T> const& m);

	template<typename T>
	 mat<2, 2, T> operator+(mat<2, 2, T> const& m1, mat<2, 2, T> const& m2);

	template<typename T>
	 mat<2, 2, T> operator-(mat<2, 2, T> const& m, T scalar);

	template<typename T>
	 mat<2, 2, T> operator-(T scalar, mat<2, 2, T> const& m);

	template<typename T>
	 mat<2, 2, T> operator-(mat<2, 2, T> const& m1, mat<2, 2, T> const& m2);

	template<typename T>
	 mat<2, 2, T> operator*(mat<2, 2, T> const& m, T scalar);

	template<typename T>
	 mat<2, 2, T> operator*(T scalar, mat<2, 2, T> const& m);

	template<typename T>
	 typename mat<2, 2, T>::col_type operator*(mat<2, 2, T> const& m, typename mat<2, 2, T>::row_type const& v);

	template<typename T>
	 typename mat<2, 2, T>::row_type operator*(typename mat<2, 2, T>::col_type const& v, mat<2, 2, T> const& m);

	template<typename T>
	 mat<2, 2, T> operator*(mat<2, 2, T> const& m1, mat<2, 2, T> const& m2);

	template<typename T>
	 mat<3, 2, T> operator*(mat<2, 2, T> const& m1, mat<3, 2, T> const& m2);

	template<typename T>
	 mat<4, 2, T> operator*(mat<2, 2, T> const& m1, mat<4, 2, T> const& m2);

	template<typename T>
	 mat<2, 2, T> operator/(mat<2, 2, T> const& m, T scalar);

	template<typename T>
	 mat<2, 2, T> operator/(T scalar, mat<2, 2, T> const& m);

	template<typename T>
	 typename mat<2, 2, T>::col_type operator/(mat<2, 2, T> const& m, typename mat<2, 2, T>::row_type const& v);

	template<typename T>
	 typename mat<2, 2, T>::row_type operator/(typename mat<2, 2, T>::col_type const& v, mat<2, 2, T> const& m);

	template<typename T>
	 mat<2, 2, T> operator/(mat<2, 2, T> const& m1, mat<2, 2, T> const& m2);

	

	template<typename T>
	 bool operator==(mat<2, 2, T> const& m1, mat<2, 2, T> const& m2);

	template<typename T>
	 bool operator!=(mat<2, 2, T> const& m1, mat<2, 2, T> const& m2);
} 


#line 1 "C:\\Projects\\glm\\glm\\detail\\type_mat2x2.inl"


namespace glm
{
	













#line 20 "C:\\Projects\\glm\\glm\\detail\\type_mat2x2.inl"

	template<typename T>
	 inline constexpr mat<2, 2, T>::mat(mat<2, 2, T> const& m)

			: value{m[0], m[1]}
#line 26 "C:\\Projects\\glm\\glm\\detail\\type_mat2x2.inl"
	{



#line 31 "C:\\Projects\\glm\\glm\\detail\\type_mat2x2.inl"
	}

	template<typename T>
	 inline constexpr mat<2, 2, T>::mat(T scalar)

			: value{col_type(scalar, 0), col_type(0, scalar)}
#line 38 "C:\\Projects\\glm\\glm\\detail\\type_mat2x2.inl"
	{



#line 43 "C:\\Projects\\glm\\glm\\detail\\type_mat2x2.inl"
	}

	template<typename T>
	 inline constexpr mat<2, 2, T>::mat
	(
		T const& x0, T const& y0,
		T const& x1, T const& y1
	)

			: value{col_type(x0, y0), col_type(x1, y1)}
#line 54 "C:\\Projects\\glm\\glm\\detail\\type_mat2x2.inl"
	{



#line 59 "C:\\Projects\\glm\\glm\\detail\\type_mat2x2.inl"
	}

	template<typename T>
	 inline constexpr mat<2, 2, T>::mat(col_type const& v0, col_type const& v1)

			: value{v0, v1}
#line 66 "C:\\Projects\\glm\\glm\\detail\\type_mat2x2.inl"
	{



#line 71 "C:\\Projects\\glm\\glm\\detail\\type_mat2x2.inl"
	}

	

	template<typename T>
	template<typename V1, typename V2>
	 inline constexpr mat<2, 2, T>::mat(vec<2, V1> const& v1, vec<2, V2> const& v2)

			: value{col_type(v1), col_type(v2)}
#line 81 "C:\\Projects\\glm\\glm\\detail\\type_mat2x2.inl"
	{



#line 86 "C:\\Projects\\glm\\glm\\detail\\type_mat2x2.inl"
	}

	template<typename T>
	template<typename X1, typename Y1, typename X2, typename Y2>
	 inline constexpr mat<2, 2, T>::mat
	(
		X1 const& x1, Y1 const& y1,
		X2 const& x2, Y2 const& y2
	)

		: value{ col_type(static_cast<T>(x1), value_type(y1)), col_type(static_cast<T>(x2), value_type(y2)) }
#line 98 "C:\\Projects\\glm\\glm\\detail\\type_mat2x2.inl"
	{



#line 103 "C:\\Projects\\glm\\glm\\detail\\type_mat2x2.inl"
	}

	

	template<typename T>
	 inline constexpr mat<2, 2, T>::mat(mat<3, 3, T> const& m)

			: value{col_type(m[0]), col_type(m[1])}
#line 112 "C:\\Projects\\glm\\glm\\detail\\type_mat2x2.inl"
	{



#line 117 "C:\\Projects\\glm\\glm\\detail\\type_mat2x2.inl"
	}

	template<typename T>
	 inline constexpr mat<2, 2, T>::mat(mat<4, 4, T> const& m)

			: value{col_type(m[0]), col_type(m[1])}
#line 124 "C:\\Projects\\glm\\glm\\detail\\type_mat2x2.inl"
	{



#line 129 "C:\\Projects\\glm\\glm\\detail\\type_mat2x2.inl"
	}

	template<typename T>
	 inline constexpr mat<2, 2, T>::mat(mat<2, 3, T> const& m)

			: value{col_type(m[0]), col_type(m[1])}
#line 136 "C:\\Projects\\glm\\glm\\detail\\type_mat2x2.inl"
	{



#line 141 "C:\\Projects\\glm\\glm\\detail\\type_mat2x2.inl"
	}

	template<typename T>
	 inline constexpr mat<2, 2, T>::mat(mat<3, 2, T> const& m)

			: value{col_type(m[0]), col_type(m[1])}
#line 148 "C:\\Projects\\glm\\glm\\detail\\type_mat2x2.inl"
	{



#line 153 "C:\\Projects\\glm\\glm\\detail\\type_mat2x2.inl"
	}

	template<typename T>
	 inline constexpr mat<2, 2, T>::mat(mat<2, 4, T> const& m)

			: value{col_type(m[0]), col_type(m[1])}
#line 160 "C:\\Projects\\glm\\glm\\detail\\type_mat2x2.inl"
	{



#line 165 "C:\\Projects\\glm\\glm\\detail\\type_mat2x2.inl"
	}

	template<typename T>
	 inline constexpr mat<2, 2, T>::mat(mat<4, 2, T> const& m)

			: value{col_type(m[0]), col_type(m[1])}
#line 172 "C:\\Projects\\glm\\glm\\detail\\type_mat2x2.inl"
	{



#line 177 "C:\\Projects\\glm\\glm\\detail\\type_mat2x2.inl"
	}

	template<typename T>
	 inline constexpr mat<2, 2, T>::mat(mat<3, 4, T> const& m)

			: value{col_type(m[0]), col_type(m[1])}
#line 184 "C:\\Projects\\glm\\glm\\detail\\type_mat2x2.inl"
	{



#line 189 "C:\\Projects\\glm\\glm\\detail\\type_mat2x2.inl"
	}

	template<typename T>
	 inline constexpr mat<2, 2, T>::mat(mat<4, 3, T> const& m)

			: value{col_type(m[0]), col_type(m[1])}
#line 196 "C:\\Projects\\glm\\glm\\detail\\type_mat2x2.inl"
	{



#line 201 "C:\\Projects\\glm\\glm\\detail\\type_mat2x2.inl"
	}

	

	template<typename T>
	 inline typename mat<2, 2, T>::col_type& mat<2, 2, T>::operator[](typename mat<2, 2, T>::length_type i)
	{
		(void)( (!!(i < this->length())) || (_wassert(L"i < this->length()", L"C:\\Projects\\glm\\glm\\detail\\type_mat2x2.inl", (unsigned)(208)), 0) );
		return this->value[i];
	}

	template<typename T>
	 inline constexpr typename mat<2, 2, T>::col_type const& mat<2, 2, T>::operator[](typename mat<2, 2, T>::length_type i) const
	{
		(void)( (!!(i < this->length())) || (_wassert(L"i < this->length()", L"C:\\Projects\\glm\\glm\\detail\\type_mat2x2.inl", (unsigned)(215)), 0) );
		return this->value[i];
	}

	

	template<typename T>
	
	 inline mat<2, 2, T>& mat<2, 2, T>::operator=(mat<2, 2, T> const& m)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
		return *this;
	}

	template<typename T>
	
	 inline mat<2, 2, T>& mat<2, 2, T>::operator+=(T scalar)
	{
		this->value[0] += scalar;
		this->value[1] += scalar;
		return *this;
	}

	template<typename T>
	
	 inline mat<2, 2, T>& mat<2, 2, T>::operator+=(mat<2, 2, T> const& m)
	{
		this->value[0] += m[0];
		this->value[1] += m[1];
		return *this;
	}

	template<typename T>
	
	 inline mat<2, 2, T>& mat<2, 2, T>::operator-=(T scalar)
	{
		this->value[0] -= scalar;
		this->value[1] -= scalar;
		return *this;
	}

	template<typename T>
	
	 inline mat<2, 2, T>& mat<2, 2, T>::operator-=(mat<2, 2, T> const& m)
	{
		this->value[0] -= m[0];
		this->value[1] -= m[1];
		return *this;
	}

	template<typename T>
	
	 inline mat<2, 2, T>& mat<2, 2, T>::operator*=(T scalar)
	{
		this->value[0] *= scalar;
		this->value[1] *= scalar;
		return *this;
	}

	template<typename T>
	
	 inline mat<2, 2, T>& mat<2, 2, T>::operator*=(mat<2, 2, T> const& m)
	{
		return (*this = *this * m);
	}

	template<typename T>
	
	 inline mat<2, 2, T>& mat<2, 2, T>::operator/=(T scalar)
	{
		this->value[0] /= scalar;
		this->value[1] /= scalar;
		return *this;
	}

	template<typename T>
	 inline mat<2, 2, T>& mat<2, 2, T>::operator/=(mat<2, 2, T> const& m)
	{
		return *this *= inverse(m);
	}

	

	template<typename T>
	 inline mat<2, 2, T> operator+(mat<2, 2, T> const& m)
	{
		return m;
	}

	template<typename T>
	 inline mat<2, 2, T> operator-(mat<2, 2, T> const& m)
	{
		return mat<2, 2, T>(
			-m[0],
			-m[1]);
	}

	

	template<typename T>
	 inline mat<2, 2, T> operator+(mat<2, 2, T> const& m, T scalar)
	{
		return mat<2, 2, T>(
			m[0] + scalar,
			m[1] + scalar);
	}

	template<typename T>
	 inline mat<2, 2, T> operator+(T scalar, mat<2, 2, T> const& m)
	{
		return mat<2, 2, T>(
			m[0] + scalar,
			m[1] + scalar);
	}

	template<typename T>
	 inline mat<2, 2, T> operator+(mat<2, 2, T> const& m1, mat<2, 2, T> const& m2)
	{
		return mat<2, 2, T>(
			m1[0] + m2[0],
			m1[1] + m2[1]);
	}

	template<typename T>
	 inline mat<2, 2, T> operator-(mat<2, 2, T> const& m, T scalar)
	{
		return mat<2, 2, T>(
			m[0] - scalar,
			m[1] - scalar);
	}

	template<typename T>
	 inline mat<2, 2, T> operator-(T scalar, mat<2, 2, T> const& m)
	{
		return mat<2, 2, T>(
			scalar - m[0],
			scalar - m[1]);
	}

	template<typename T>
	 inline mat<2, 2, T> operator-(mat<2, 2, T> const& m1, mat<2, 2, T> const& m2)
	{
		return mat<2, 2, T>(
			m1[0] - m2[0],
			m1[1] - m2[1]);
	}

	template<typename T>
	 inline mat<2, 2, T> operator*(mat<2, 2, T> const& m, T scalar)
	{
		return mat<2, 2, T>(
			m[0] * scalar,
			m[1] * scalar);
	}

	template<typename T>
	 inline mat<2, 2, T> operator*(T scalar, mat<2, 2, T> const& m)
	{
		return mat<2, 2, T>(
			m[0] * scalar,
			m[1] * scalar);
	}

	template<typename T>
	 inline typename mat<2, 2, T>::col_type operator*
	(
		mat<2, 2, T> const& m,
		typename mat<2, 2, T>::row_type const& v
	)
	{
		return vec<2, T>(
			m[0][0] * v.x + m[1][0] * v.y,
			m[0][1] * v.x + m[1][1] * v.y);
	}

	template<typename T>
	 inline typename mat<2, 2, T>::row_type operator*
	(
		typename mat<2, 2, T>::col_type const& v,
		mat<2, 2, T> const& m
	)
	{
		return vec<2, T>(
			v.x * m[0][0] + v.y * m[0][1],
			v.x * m[1][0] + v.y * m[1][1]);
	}

	template<typename T>
	 inline mat<2, 2, T> operator*(mat<2, 2, T> const& m1, mat<2, 2, T> const& m2)
	{
		return mat<2, 2, T>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1]);
	}

	template<typename T>
	 inline mat<3, 2, T> operator*(mat<2, 2, T> const& m1, mat<3, 2, T> const& m2)
	{
		return mat<3, 2, T>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1],
			m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1],
			m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1]);
	}

	template<typename T>
	 inline mat<4, 2, T> operator*(mat<2, 2, T> const& m1, mat<4, 2, T> const& m2)
	{
		return mat<4, 2, T>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1],
			m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1],
			m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1],
			m1[0][0] * m2[3][0] + m1[1][0] * m2[3][1],
			m1[0][1] * m2[3][0] + m1[1][1] * m2[3][1]);
	}

	template<typename T>
	 inline mat<2, 2, T> operator/(mat<2, 2, T> const& m, T scalar)
	{
		return mat<2, 2, T>(
			m[0] / scalar,
			m[1] / scalar);
	}

	template<typename T>
	 inline mat<2, 2, T> operator/(T scalar, mat<2, 2, T> const& m)
	{
		return mat<2, 2, T>(
			scalar / m[0],
			scalar / m[1]);
	}

	template<typename T>
	 inline typename mat<2, 2, T>::col_type operator/(mat<2, 2, T> const& m, typename mat<2, 2, T>::row_type const& v)
	{
		return inverse(m) * v;
	}

	template<typename T>
	 inline typename mat<2, 2, T>::row_type operator/(typename mat<2, 2, T>::col_type const& v, mat<2, 2, T> const& m)
	{
		return v *  inverse(m);
	}

	template<typename T>
	 inline mat<2, 2, T> operator/(mat<2, 2, T> const& m1, mat<2, 2, T> const& m2)
	{
		mat<2, 2, T> m1_copy(m1);
		return m1_copy /= m2;
	}

	

	template<typename T>
	 inline bool operator==(mat<2, 2, T> const& m1, mat<2, 2, T> const& m2)
	{
		return (m1[0] == m2[0]) && (m1[1] == m2[1]);
	}

	template<typename T>
	 inline bool operator!=(mat<2, 2, T> const& m1, mat<2, 2, T> const& m2)
	{
		return (m1[0] != m2[0]) || (m1[1] != m2[1]);
	}
} 
#line 158 "C:\\Projects\\glm\\glm\\ext\\../detail/type_mat2x2.hpp"
#line 159 "C:\\Projects\\glm\\glm\\ext\\../detail/type_mat2x2.hpp"
#line 6 "C:\\Projects\\glm\\glm\\./ext/matrix_double2x2.hpp"

namespace glm
{
	
	

	
	
	
	typedef mat<2, 2, double>		dmat2x2;

	
	
	
	typedef mat<2, 2, double>		dmat2;

	
}
#line 6 "C:\\Projects\\glm\\glm\\mat2x2.hpp"
#line 1 "C:\\Projects\\glm\\glm\\./ext/matrix_float2x2.hpp"



#pragma once


namespace glm
{
	
	

	
	
	
	typedef mat<2, 2, float>		mat2x2;

	
	
	
	typedef mat<2, 2, float>		mat2;

	
}
#line 7 "C:\\Projects\\glm\\glm\\mat2x2.hpp"

#line 21 "C:\\Projects\\glm\\glm\\detail\\../matrix.hpp"
#line 1 "C:\\Projects\\glm\\glm\\mat2x3.hpp"



#pragma once
#line 1 "C:\\Projects\\glm\\glm\\./ext/matrix_double2x3.hpp"



#pragma once
#line 1 "C:\\Projects\\glm\\glm\\ext\\../detail/type_mat2x3.hpp"



#pragma once






namespace glm
{
	template<typename T>
	struct mat<2, 3, T>
	{
		typedef vec<3, T> col_type;
		typedef vec<2, T> row_type;
		typedef mat<2, 3, T> type;
		typedef mat<3, 2, T> transpose_type;
		typedef T value_type;

	private:
		col_type value[2];

	public:
		

		typedef length_t length_type;
		 static constexpr length_type length() { return 2; }

		 col_type & operator[](length_type i);
		 constexpr col_type const& operator[](length_type i) const;

		

		 constexpr mat() = default;
		 constexpr mat(mat<2, 3, T> const& m);

		 explicit constexpr mat(T scalar);
		 constexpr mat(
			T x0, T y0, T z0,
			T x1, T y1, T z1);
		 constexpr mat(
			col_type const& v0,
			col_type const& v1);

		

		template<typename X1, typename Y1, typename Z1, typename X2, typename Y2, typename Z2>
		 constexpr mat(
			X1 x1, Y1 y1, Z1 z1,
			X2 x2, Y2 y2, Z2 z2);

		template<typename U, typename V>
		 constexpr mat(
			vec<3, U> const& v1,
			vec<3, V> const& v2);

		

		  constexpr mat(mat<2, 2, T> const& x);
		  constexpr mat(mat<3, 3, T> const& x);
		  constexpr mat(mat<4, 4, T> const& x);
		  constexpr mat(mat<2, 4, T> const& x);
		  constexpr mat(mat<3, 2, T> const& x);
		  constexpr mat(mat<3, 4, T> const& x);
		  constexpr mat(mat<4, 2, T> const& x);
		  constexpr mat(mat<4, 3, T> const& x);

		

		template<typename U>
		 mat<2, 3, T> & operator=(mat<2, 3, U> const& m);
		template<typename U>
		 mat<2, 3, T> & operator+=(U s);
		template<typename U>
		 mat<2, 3, T> & operator+=(mat<2, 3, U> const& m);
		template<typename U>
		 mat<2, 3, T> & operator-=(U s);
		template<typename U>
		 mat<2, 3, T> & operator-=(mat<2, 3, U> const& m);
		template<typename U>
		 mat<2, 3, T> & operator*=(U s);
		template<typename U>
		 mat<2, 3, T> & operator/=(U s);
	};

	

	template<typename T>
	 mat<2, 3, T> operator+(mat<2, 3, T> const& m);

	template<typename T>
	 mat<2, 3, T> operator-(mat<2, 3, T> const& m);

	

	template<typename T>
	 mat<2, 3, T> operator+(mat<2, 3, T> const& m, T scalar);

	template<typename T>
	 mat<2, 3, T> operator+(mat<2, 3, T> const& m1, mat<2, 3, T> const& m2);

	template<typename T>
	 mat<2, 3, T> operator-(mat<2, 3, T> const& m, T scalar);

	template<typename T>
	 mat<2, 3, T> operator-(mat<2, 3, T> const& m1, mat<2, 3, T> const& m2);

	template<typename T>
	 mat<2, 3, T> operator*(mat<2, 3, T> const& m, T scalar);

	template<typename T>
	 mat<2, 3, T> operator*(T scalar, mat<2, 3, T> const& m);

	template<typename T>
	 typename mat<2, 3, T>::col_type operator*(mat<2, 3, T> const& m, typename mat<2, 3, T>::row_type const& v);

	template<typename T>
	 typename mat<2, 3, T>::row_type operator*(typename mat<2, 3, T>::col_type const& v, mat<2, 3, T> const& m);

	template<typename T>
	 mat<2, 3, T> operator*(mat<2, 3, T> const& m1, mat<2, 2, T> const& m2);

	template<typename T>
	 mat<3, 3, T> operator*(mat<2, 3, T> const& m1, mat<3, 2, T> const& m2);

	template<typename T>
	 mat<4, 3, T> operator*(mat<2, 3, T> const& m1, mat<4, 2, T> const& m2);

	template<typename T>
	 mat<2, 3, T> operator/(mat<2, 3, T> const& m, T scalar);

	template<typename T>
	 mat<2, 3, T> operator/(T scalar, mat<2, 3, T> const& m);

	

	template<typename T>
	 bool operator==(mat<2, 3, T> const& m1, mat<2, 3, T> const& m2);

	template<typename T>
	 bool operator!=(mat<2, 3, T> const& m1, mat<2, 3, T> const& m2);
}


#line 1 "C:\\Projects\\glm\\glm\\detail\\type_mat2x3.inl"
namespace glm
{
	













#line 18 "C:\\Projects\\glm\\glm\\detail\\type_mat2x3.inl"

	template<typename T>
	 inline constexpr mat<2, 3, T>::mat(mat<2, 3, T> const& m)

			: value{m.value[0], m.value[1]}
#line 24 "C:\\Projects\\glm\\glm\\detail\\type_mat2x3.inl"
	{



#line 29 "C:\\Projects\\glm\\glm\\detail\\type_mat2x3.inl"
	}

	template<typename T>
	 inline constexpr mat<2, 3, T>::mat(T scalar)

			: value{col_type(scalar, 0, 0), col_type(0, scalar, 0)}
#line 36 "C:\\Projects\\glm\\glm\\detail\\type_mat2x3.inl"
	{



#line 41 "C:\\Projects\\glm\\glm\\detail\\type_mat2x3.inl"
	}

	template<typename T>
	 inline constexpr mat<2, 3, T>::mat
	(
		T x0, T y0, T z0,
		T x1, T y1, T z1
	)

			: value{col_type(x0, y0, z0), col_type(x1, y1, z1)}
#line 52 "C:\\Projects\\glm\\glm\\detail\\type_mat2x3.inl"
	{



#line 57 "C:\\Projects\\glm\\glm\\detail\\type_mat2x3.inl"
	}

	template<typename T>
	 inline constexpr mat<2, 3, T>::mat(col_type const& v0, col_type const& v1)

			: value{col_type(v0), col_type(v1)}
#line 64 "C:\\Projects\\glm\\glm\\detail\\type_mat2x3.inl"
	{



#line 69 "C:\\Projects\\glm\\glm\\detail\\type_mat2x3.inl"
	}

	

	template<typename T>
	template<
		typename X1, typename Y1, typename Z1,
		typename X2, typename Y2, typename Z2>
	 inline constexpr mat<2, 3, T>::mat
	(
		X1 x1, Y1 y1, Z1 z1,
		X2 x2, Y2 y2, Z2 z2
	)

			: value{col_type(x1, y1, z1), col_type(x2, y2, z2)}
#line 85 "C:\\Projects\\glm\\glm\\detail\\type_mat2x3.inl"
	{



#line 90 "C:\\Projects\\glm\\glm\\detail\\type_mat2x3.inl"
	}

	template<typename T>
	template<typename V1, typename V2>
	 inline constexpr mat<2, 3, T>::mat(vec<3, V1> const& v1, vec<3, V2> const& v2)

			: value{col_type(v1), col_type(v2)}
#line 98 "C:\\Projects\\glm\\glm\\detail\\type_mat2x3.inl"
	{



#line 103 "C:\\Projects\\glm\\glm\\detail\\type_mat2x3.inl"
	}

	

	template<typename T>
	 inline constexpr mat<2, 3, T>::mat(mat<2, 2, T> const& m)

			: value{col_type(m[0], 0), col_type(m[1], 0)}
#line 112 "C:\\Projects\\glm\\glm\\detail\\type_mat2x3.inl"
	{



#line 117 "C:\\Projects\\glm\\glm\\detail\\type_mat2x3.inl"
	}

	template<typename T>
	 inline constexpr  mat<2, 3, T>::mat(mat<3, 3, T> const& m)

			: value{col_type(m[0]), col_type(m[1])}
#line 124 "C:\\Projects\\glm\\glm\\detail\\type_mat2x3.inl"
	{



#line 129 "C:\\Projects\\glm\\glm\\detail\\type_mat2x3.inl"
	}

	template<typename T>
	 inline constexpr mat<2, 3, T>::mat(mat<4, 4, T> const& m)

		: value{col_type(m[0]), col_type(m[1])}
#line 136 "C:\\Projects\\glm\\glm\\detail\\type_mat2x3.inl"
	{



#line 141 "C:\\Projects\\glm\\glm\\detail\\type_mat2x3.inl"
	}

	template<typename T>
	 inline constexpr mat<2, 3, T>::mat(mat<2, 4, T> const& m)

			: value{col_type(m[0]), col_type(m[1])}
#line 148 "C:\\Projects\\glm\\glm\\detail\\type_mat2x3.inl"
	{



#line 153 "C:\\Projects\\glm\\glm\\detail\\type_mat2x3.inl"
	}

	template<typename T>
	 inline constexpr mat<2, 3, T>::mat(mat<3, 2, T> const& m)

			: value{col_type(m[0], 0), col_type(m[1], 0)}
#line 160 "C:\\Projects\\glm\\glm\\detail\\type_mat2x3.inl"
	{



#line 165 "C:\\Projects\\glm\\glm\\detail\\type_mat2x3.inl"
	}

	template<typename T>
	 inline constexpr mat<2, 3, T>::mat(mat<3, 4, T> const& m)

			: value{col_type(m[0]), col_type(m[1])}
#line 172 "C:\\Projects\\glm\\glm\\detail\\type_mat2x3.inl"
	{



#line 177 "C:\\Projects\\glm\\glm\\detail\\type_mat2x3.inl"
	}

	template<typename T>
	 inline constexpr mat<2, 3, T>::mat(mat<4, 2, T> const& m)

			: value{col_type(m[0], 0), col_type(m[1], 0)}
#line 184 "C:\\Projects\\glm\\glm\\detail\\type_mat2x3.inl"
	{



#line 189 "C:\\Projects\\glm\\glm\\detail\\type_mat2x3.inl"
	}

	template<typename T>
	 inline constexpr mat<2, 3, T>::mat(mat<4, 3, T> const& m)

			: value{col_type(m[0]), col_type(m[1])}
#line 196 "C:\\Projects\\glm\\glm\\detail\\type_mat2x3.inl"
	{



#line 201 "C:\\Projects\\glm\\glm\\detail\\type_mat2x3.inl"
	}

	

	template<typename T>
	 inline typename mat<2, 3, T>::col_type & mat<2, 3, T>::operator[](typename mat<2, 3, T>::length_type i)
	{
		(void)( (!!(i < this->length())) || (_wassert(L"i < this->length()", L"C:\\Projects\\glm\\glm\\detail\\type_mat2x3.inl", (unsigned)(208)), 0) );
		return this->value[i];
	}

	template<typename T>
	 inline constexpr typename mat<2, 3, T>::col_type const& mat<2, 3, T>::operator[](typename mat<2, 3, T>::length_type i) const
	{
		(void)( (!!(i < this->length())) || (_wassert(L"i < this->length()", L"C:\\Projects\\glm\\glm\\detail\\type_mat2x3.inl", (unsigned)(215)), 0) );
		return this->value[i];
	}

	

	template<typename T>
	template<typename U>
	 inline mat<2, 3, T>& mat<2, 3, T>::operator=(mat<2, 3, U> const& m)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
		return *this;
	}

	template<typename T>
	template<typename U>
	 inline mat<2, 3, T> & mat<2, 3, T>::operator+=(U s)
	{
		this->value[0] += s;
		this->value[1] += s;
		return *this;
	}

	template<typename T>
	template<typename U>
	 inline mat<2, 3, T>& mat<2, 3, T>::operator+=(mat<2, 3, U> const& m)
	{
		this->value[0] += m[0];
		this->value[1] += m[1];
		return *this;
	}

	template<typename T>
	template<typename U>
	 inline mat<2, 3, T>& mat<2, 3, T>::operator-=(U s)
	{
		this->value[0] -= s;
		this->value[1] -= s;
		return *this;
	}

	template<typename T>
	template<typename U>
	 inline mat<2, 3, T>& mat<2, 3, T>::operator-=(mat<2, 3, U> const& m)
	{
		this->value[0] -= m[0];
		this->value[1] -= m[1];
		return *this;
	}

	template<typename T>
	template<typename U>
	 inline mat<2, 3, T>& mat<2, 3, T>::operator*=(U s)
	{
		this->value[0] *= s;
		this->value[1] *= s;
		return *this;
	}

	template<typename T>
	template<typename U>
	 inline mat<2, 3, T> & mat<2, 3, T>::operator/=(U s)
	{
		this->value[0] /= s;
		this->value[1] /= s;
		return *this;
	}

	

	template<typename T>
	 inline mat<2, 3, T> operator+(mat<2, 3, T> const& m)
	{
		return m;
	}

	template<typename T>
	 inline mat<2, 3, T> operator-(mat<2, 3, T> const& m)
	{
		return mat<2, 3, T>(
			-m[0],
			-m[1]);
	}

	

	template<typename T>
	 inline mat<2, 3, T> operator+(mat<2, 3, T> const& m, T scalar)
	{
		return mat<2, 3, T>(
			m[0] + scalar,
			m[1] + scalar);
	}

	template<typename T>
	 inline mat<2, 3, T> operator+(mat<2, 3, T> const& m1, mat<2, 3, T> const& m2)
	{
		return mat<2, 3, T>(
			m1[0] + m2[0],
			m1[1] + m2[1]);
	}

	template<typename T>
	 inline mat<2, 3, T> operator-(mat<2, 3, T> const& m, T scalar)
	{
		return mat<2, 3, T>(
			m[0] - scalar,
			m[1] - scalar);
	}

	template<typename T>
	 inline mat<2, 3, T> operator-(mat<2, 3, T> const& m1, mat<2, 3, T> const& m2)
	{
		return mat<2, 3, T>(
			m1[0] - m2[0],
			m1[1] - m2[1]);
	}

	template<typename T>
	 inline mat<2, 3, T> operator*(mat<2, 3, T> const& m, T scalar)
	{
		return mat<2, 3, T>(
			m[0] * scalar,
			m[1] * scalar);
	}

	template<typename T>
	 inline mat<2, 3, T> operator*(T scalar, mat<2, 3, T> const& m)
	{
		return mat<2, 3, T>(
			m[0] * scalar,
			m[1] * scalar);
	}

	template<typename T>
	 inline typename mat<2, 3, T>::col_type operator*
	(
		mat<2, 3, T> const& m,
		typename mat<2, 3, T>::row_type const& v)
	{
		return typename mat<2, 3, T>::col_type(
			m[0][0] * v.x + m[1][0] * v.y,
			m[0][1] * v.x + m[1][1] * v.y,
			m[0][2] * v.x + m[1][2] * v.y);
	}

	template<typename T>
	 inline typename mat<2, 3, T>::row_type operator*
	(
		typename mat<2, 3, T>::col_type const& v,
		mat<2, 3, T> const& m)
	{
		return typename mat<2, 3, T>::row_type(
			v.x * m[0][0] + v.y * m[0][1] + v.z * m[0][2],
			v.x * m[1][0] + v.y * m[1][1] + v.z * m[1][2]);
	}

	template<typename T>
	 inline mat<2, 3, T> operator*(mat<2, 3, T> const& m1, mat<2, 2, T> const& m2)
	{
		return mat<2, 3, T>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
			m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1],
			m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1]);
	}

	template<typename T>
	 inline mat<3, 3, T> operator*(mat<2, 3, T> const& m1, mat<3, 2, T> const& m2)
	{
		T SrcA00 = m1[0][0];
		T SrcA01 = m1[0][1];
		T SrcA02 = m1[0][2];
		T SrcA10 = m1[1][0];
		T SrcA11 = m1[1][1];
		T SrcA12 = m1[1][2];

		T SrcB00 = m2[0][0];
		T SrcB01 = m2[0][1];
		T SrcB10 = m2[1][0];
		T SrcB11 = m2[1][1];
		T SrcB20 = m2[2][0];
		T SrcB21 = m2[2][1];

		mat<3, 3, T> Result;
		Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01;
		Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01;
		Result[0][2] = SrcA02 * SrcB00 + SrcA12 * SrcB01;
		Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11;
		Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11;
		Result[1][2] = SrcA02 * SrcB10 + SrcA12 * SrcB11;
		Result[2][0] = SrcA00 * SrcB20 + SrcA10 * SrcB21;
		Result[2][1] = SrcA01 * SrcB20 + SrcA11 * SrcB21;
		Result[2][2] = SrcA02 * SrcB20 + SrcA12 * SrcB21;
		return Result;
	}

	template<typename T>
	 inline mat<4, 3, T> operator*(mat<2, 3, T> const& m1, mat<4, 2, T> const& m2)
	{
		return mat<4, 3, T>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
			m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1],
			m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1],
			m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1],
			m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1],
			m1[0][2] * m2[2][0] + m1[1][2] * m2[2][1],
			m1[0][0] * m2[3][0] + m1[1][0] * m2[3][1],
			m1[0][1] * m2[3][0] + m1[1][1] * m2[3][1],
			m1[0][2] * m2[3][0] + m1[1][2] * m2[3][1]);
	}

	template<typename T>
	 inline mat<2, 3, T> operator/(mat<2, 3, T> const& m, T scalar)
	{
		return mat<2, 3, T>(
			m[0] / scalar,
			m[1] / scalar);
	}

	template<typename T>
	 inline mat<2, 3, T> operator/(T scalar, mat<2, 3, T> const& m)
	{
		return mat<2, 3, T>(
			scalar / m[0],
			scalar / m[1]);
	}

	

	template<typename T>
	 inline bool operator==(mat<2, 3, T> const& m1, mat<2, 3, T> const& m2)
	{
		return (m1[0] == m2[0]) && (m1[1] == m2[1]);
	}

	template<typename T>
	 inline bool operator!=(mat<2, 3, T> const& m1, mat<2, 3, T> const& m2)
	{
		return (m1[0] != m2[0]) || (m1[1] != m2[1]);
	}
} 
#line 148 "C:\\Projects\\glm\\glm\\ext\\../detail/type_mat2x3.hpp"
#line 149 "C:\\Projects\\glm\\glm\\ext\\../detail/type_mat2x3.hpp"
#line 6 "C:\\Projects\\glm\\glm\\./ext/matrix_double2x3.hpp"

namespace glm
{
	
	

	
	
	
	typedef mat<2, 3, double>		dmat2x3;

	
}
#line 6 "C:\\Projects\\glm\\glm\\mat2x3.hpp"
#line 1 "C:\\Projects\\glm\\glm\\./ext/matrix_float2x3.hpp"



#pragma once


namespace glm
{
	
	

	
	
	
	typedef mat<2, 3, float>		mat2x3;

	
}
#line 7 "C:\\Projects\\glm\\glm\\mat2x3.hpp"

#line 22 "C:\\Projects\\glm\\glm\\detail\\../matrix.hpp"
#line 1 "C:\\Projects\\glm\\glm\\mat2x4.hpp"



#pragma once
#line 1 "C:\\Projects\\glm\\glm\\./ext/matrix_double2x4.hpp"



#pragma once
#line 1 "C:\\Projects\\glm\\glm\\ext\\../detail/type_mat2x4.hpp"



#pragma once






namespace glm
{
	template<typename T>
	struct mat<2, 4, T>
	{
		typedef vec<4, T> col_type;
		typedef vec<2, T> row_type;
		typedef mat<2, 4, T> type;
		typedef mat<4, 2, T> transpose_type;
		typedef T value_type;

	private:
		col_type value[2];

	public:
		

		typedef length_t length_type;
		 static constexpr length_type length() { return 2; }

		 col_type & operator[](length_type i);
		 constexpr col_type const& operator[](length_type i) const;

		

		 constexpr mat() = default;
		 constexpr mat(mat<2, 4, T> const& m);

		 explicit constexpr mat(T scalar);
		 constexpr mat(
			T x0, T y0, T z0, T w0,
			T x1, T y1, T z1, T w1);
		 constexpr mat(
			col_type const& v0,
			col_type const& v1);

		

		template<
			typename X1, typename Y1, typename Z1, typename W1,
			typename X2, typename Y2, typename Z2, typename W2>
		 constexpr mat(
			X1 x1, Y1 y1, Z1 z1, W1 w1,
			X2 x2, Y2 y2, Z2 z2, W2 w2);

		template<typename U, typename V>
		 constexpr mat(
			vec<4, U> const& v1,
			vec<4, V> const& v2);

		

		  constexpr mat(mat<2, 2, T> const& x);
		  constexpr mat(mat<3, 3, T> const& x);
		  constexpr mat(mat<4, 4, T> const& x);
		  constexpr mat(mat<2, 3, T> const& x);
		  constexpr mat(mat<3, 2, T> const& x);
		  constexpr mat(mat<3, 4, T> const& x);
		  constexpr mat(mat<4, 2, T> const& x);
		  constexpr mat(mat<4, 3, T> const& x);

		

		template<typename U>
		 mat<2, 4, T> & operator=(mat<2, 4, U> const& m);
		template<typename U>
		 mat<2, 4, T> & operator+=(U s);
		template<typename U>
		 mat<2, 4, T> & operator+=(mat<2, 4, U> const& m);
		template<typename U>
		 mat<2, 4, T> & operator-=(U s);
		template<typename U>
		 mat<2, 4, T> & operator-=(mat<2, 4, U> const& m);
		template<typename U>
		 mat<2, 4, T> & operator*=(U s);
		template<typename U>
		 mat<2, 4, T> & operator/=(U s);
	};

	

	template<typename T>
	 mat<2, 4, T> operator+(mat<2, 4, T> const& m);

	template<typename T>
	 mat<2, 4, T> operator-(mat<2, 4, T> const& m);

	

	template<typename T>
	 mat<2, 4, T> operator+(mat<2, 4, T> const& m, T scalar);

	template<typename T>
	 mat<2, 4, T> operator+(mat<2, 4, T> const& m1, mat<2, 4, T> const& m2);

	template<typename T>
	 mat<2, 4, T> operator-(mat<2, 4, T> const& m, T scalar);

	template<typename T>
	 mat<2, 4, T> operator-(mat<2, 4, T> const& m1, mat<2, 4, T> const& m2);

	template<typename T>
	 mat<2, 4, T> operator*(mat<2, 4, T> const& m, T scalar);

	template<typename T>
	 mat<2, 4, T> operator*(T scalar, mat<2, 4, T> const& m);

	template<typename T>
	 typename mat<2, 4, T>::col_type operator*(mat<2, 4, T> const& m, typename mat<2, 4, T>::row_type const& v);

	template<typename T>
	 typename mat<2, 4, T>::row_type operator*(typename mat<2, 4, T>::col_type const& v, mat<2, 4, T> const& m);

	template<typename T>
	 mat<4, 4, T> operator*(mat<2, 4, T> const& m1, mat<4, 2, T> const& m2);

	template<typename T>
	 mat<2, 4, T> operator*(mat<2, 4, T> const& m1, mat<2, 2, T> const& m2);

	template<typename T>
	 mat<3, 4, T> operator*(mat<2, 4, T> const& m1, mat<3, 2, T> const& m2);

	template<typename T>
	 mat<2, 4, T> operator/(mat<2, 4, T> const& m, T scalar);

	template<typename T>
	 mat<2, 4, T> operator/(T scalar, mat<2, 4, T> const& m);

	

	template<typename T>
	 bool operator==(mat<2, 4, T> const& m1, mat<2, 4, T> const& m2);

	template<typename T>
	 bool operator!=(mat<2, 4, T> const& m1, mat<2, 4, T> const& m2);
}


#line 1 "C:\\Projects\\glm\\glm\\detail\\type_mat2x4.inl"
namespace glm
{
	













#line 18 "C:\\Projects\\glm\\glm\\detail\\type_mat2x4.inl"

	template<typename T>
	 inline constexpr mat<2, 4, T>::mat(mat<2, 4, T> const& m)

			: value{m[0], m[1]}
#line 24 "C:\\Projects\\glm\\glm\\detail\\type_mat2x4.inl"
	{



#line 29 "C:\\Projects\\glm\\glm\\detail\\type_mat2x4.inl"
	}

	template<typename T>
	 inline constexpr mat<2, 4, T>::mat(T s)

			: value{col_type(s, 0, 0, 0), col_type(0, s, 0, 0)}
#line 36 "C:\\Projects\\glm\\glm\\detail\\type_mat2x4.inl"
	{



#line 41 "C:\\Projects\\glm\\glm\\detail\\type_mat2x4.inl"
	}

	template<typename T>
	 inline constexpr mat<2, 4, T>::mat
	(
		T x0, T y0, T z0, T w0,
		T x1, T y1, T z1, T w1
	)

			: value{col_type(x0, y0, z0, w0), col_type(x1, y1, z1, w1)}
#line 52 "C:\\Projects\\glm\\glm\\detail\\type_mat2x4.inl"
	{



#line 57 "C:\\Projects\\glm\\glm\\detail\\type_mat2x4.inl"
	}

	template<typename T>
	 inline constexpr mat<2, 4, T>::mat(col_type const& v0, col_type const& v1)

			: value{col_type(v0), col_type(v1)}
#line 64 "C:\\Projects\\glm\\glm\\detail\\type_mat2x4.inl"
	{



#line 69 "C:\\Projects\\glm\\glm\\detail\\type_mat2x4.inl"
	}

	

	template<typename T>
	template<
		typename X1, typename Y1, typename Z1, typename W1,
		typename X2, typename Y2, typename Z2, typename W2>
	 inline constexpr mat<2, 4, T>::mat
	(
		X1 x1, Y1 y1, Z1 z1, W1 w1,
		X2 x2, Y2 y2, Z2 z2, W2 w2
	)

			: value{
				col_type(x1, y1, z1, w1),
				col_type(x2, y2, z2, w2)}
#line 87 "C:\\Projects\\glm\\glm\\detail\\type_mat2x4.inl"
	{



#line 92 "C:\\Projects\\glm\\glm\\detail\\type_mat2x4.inl"
	}

	template<typename T>
	template<typename V1, typename V2>
	 inline constexpr mat<2, 4, T>::mat(vec<4, V1> const& v1, vec<4, V2> const& v2)

			: value{col_type(v1), col_type(v2)}
#line 100 "C:\\Projects\\glm\\glm\\detail\\type_mat2x4.inl"
	{



#line 105 "C:\\Projects\\glm\\glm\\detail\\type_mat2x4.inl"
	}

	

	template<typename T>
	 inline constexpr mat<2, 4, T>::mat(mat<2, 2, T> const& m)

			: value{col_type(m[0], 0, 0), col_type(m[1], 0, 0)}
#line 114 "C:\\Projects\\glm\\glm\\detail\\type_mat2x4.inl"
	{



#line 119 "C:\\Projects\\glm\\glm\\detail\\type_mat2x4.inl"
	}

	template<typename T>
	 inline constexpr mat<2, 4, T>::mat(mat<3, 3, T> const& m)

			: value{col_type(m[0], 0), col_type(m[1], 0)}
#line 126 "C:\\Projects\\glm\\glm\\detail\\type_mat2x4.inl"
	{



#line 131 "C:\\Projects\\glm\\glm\\detail\\type_mat2x4.inl"
	}

	template<typename T>
	 inline constexpr mat<2, 4, T>::mat(mat<4, 4, T> const& m)

			: value{col_type(m[0]), col_type(m[1])}
#line 138 "C:\\Projects\\glm\\glm\\detail\\type_mat2x4.inl"
	{



#line 143 "C:\\Projects\\glm\\glm\\detail\\type_mat2x4.inl"
	}

	template<typename T>
	 inline constexpr mat<2, 4, T>::mat(mat<2, 3, T> const& m)

			: value{col_type(m[0], 0), col_type(m[1], 0)}
#line 150 "C:\\Projects\\glm\\glm\\detail\\type_mat2x4.inl"
	{



#line 155 "C:\\Projects\\glm\\glm\\detail\\type_mat2x4.inl"
	}

	template<typename T>
	 inline constexpr mat<2, 4, T>::mat(mat<3, 2, T> const& m)

			: value{col_type(m[0], 0, 0), col_type(m[1], 0, 0)}
#line 162 "C:\\Projects\\glm\\glm\\detail\\type_mat2x4.inl"
	{



#line 167 "C:\\Projects\\glm\\glm\\detail\\type_mat2x4.inl"
	}

	template<typename T>
	 inline constexpr mat<2, 4, T>::mat(mat<3, 4, T> const& m)

			: value{col_type(m[0]), col_type(m[1])}
#line 174 "C:\\Projects\\glm\\glm\\detail\\type_mat2x4.inl"
	{



#line 179 "C:\\Projects\\glm\\glm\\detail\\type_mat2x4.inl"
	}

	template<typename T>
	 inline constexpr mat<2, 4, T>::mat(mat<4, 2, T> const& m)

			: value{col_type(m[0], 0, 0), col_type(m[1], 0, 0)}
#line 186 "C:\\Projects\\glm\\glm\\detail\\type_mat2x4.inl"
	{



#line 191 "C:\\Projects\\glm\\glm\\detail\\type_mat2x4.inl"
	}

	template<typename T>
	 inline constexpr mat<2, 4, T>::mat(mat<4, 3, T> const& m)

			: value{col_type(m[0], 0), col_type(m[1], 0)}
#line 198 "C:\\Projects\\glm\\glm\\detail\\type_mat2x4.inl"
	{



#line 203 "C:\\Projects\\glm\\glm\\detail\\type_mat2x4.inl"
	}

	

	template<typename T>
	 inline typename mat<2, 4, T>::col_type & mat<2, 4, T>::operator[](typename mat<2, 4, T>::length_type i)
	{
		(void)( (!!(i < this->length())) || (_wassert(L"i < this->length()", L"C:\\Projects\\glm\\glm\\detail\\type_mat2x4.inl", (unsigned)(210)), 0) );
		return this->value[i];
	}

	template<typename T>
	 inline constexpr typename mat<2, 4, T>::col_type const& mat<2, 4, T>::operator[](typename mat<2, 4, T>::length_type i) const
	{
		(void)( (!!(i < this->length())) || (_wassert(L"i < this->length()", L"C:\\Projects\\glm\\glm\\detail\\type_mat2x4.inl", (unsigned)(217)), 0) );
		return this->value[i];
	}

	

	template<typename T>
	template<typename U>
	 inline mat<2, 4, T>& mat<2, 4, T>::operator=(mat<2, 4, U> const& m)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
		return *this;
	}

	template<typename T>
	template<typename U>
	 inline mat<2, 4, T>& mat<2, 4, T>::operator+=(U s)
	{
		this->value[0] += s;
		this->value[1] += s;
		return *this;
	}

	template<typename T>
	template<typename U>
	 inline mat<2, 4, T>& mat<2, 4, T>::operator+=(mat<2, 4, U> const& m)
	{
		this->value[0] += m[0];
		this->value[1] += m[1];
		return *this;
	}

	template<typename T>
	template<typename U>
	 inline mat<2, 4, T>& mat<2, 4, T>::operator-=(U s)
	{
		this->value[0] -= s;
		this->value[1] -= s;
		return *this;
	}

	template<typename T>
	template<typename U>
	 inline mat<2, 4, T>& mat<2, 4, T>::operator-=(mat<2, 4, U> const& m)
	{
		this->value[0] -= m[0];
		this->value[1] -= m[1];
		return *this;
	}

	template<typename T>
	template<typename U>
	 inline mat<2, 4, T>& mat<2, 4, T>::operator*=(U s)
	{
		this->value[0] *= s;
		this->value[1] *= s;
		return *this;
	}

	template<typename T>
	template<typename U>
	 inline mat<2, 4, T> & mat<2, 4, T>::operator/=(U s)
	{
		this->value[0] /= s;
		this->value[1] /= s;
		return *this;
	}

	

	template<typename T>
	 inline mat<2, 4, T> operator+(mat<2, 4, T> const& m)
	{
		return m;
	}

	template<typename T>
	 inline mat<2, 4, T> operator-(mat<2, 4, T> const& m)
	{
		return mat<2, 4, T>(
			-m[0],
			-m[1]);
	}

	

	template<typename T>
	 inline mat<2, 4, T> operator+(mat<2, 4, T> const& m, T scalar)
	{
		return mat<2, 4, T>(
			m[0] + scalar,
			m[1] + scalar);
	}

	template<typename T>
	 inline mat<2, 4, T> operator+(mat<2, 4, T> const& m1, mat<2, 4, T> const& m2)
	{
		return mat<2, 4, T>(
			m1[0] + m2[0],
			m1[1] + m2[1]);
	}

	template<typename T>
	 inline mat<2, 4, T> operator-(mat<2, 4, T> const& m, T scalar)
	{
		return mat<2, 4, T>(
			m[0] - scalar,
			m[1] - scalar);
	}

	template<typename T>
	 inline mat<2, 4, T> operator-(mat<2, 4, T> const& m1, mat<2, 4, T> const& m2)
	{
		return mat<2, 4, T>(
			m1[0] - m2[0],
			m1[1] - m2[1]);
	}

	template<typename T>
	 inline mat<2, 4, T> operator*(mat<2, 4, T> const& m, T scalar)
	{
		return mat<2, 4, T>(
			m[0] * scalar,
			m[1] * scalar);
	}

	template<typename T>
	 inline mat<2, 4, T> operator*(T scalar, mat<2, 4, T> const& m)
	{
		return mat<2, 4, T>(
			m[0] * scalar,
			m[1] * scalar);
	}

	template<typename T>
	 inline typename mat<2, 4, T>::col_type operator*(mat<2, 4, T> const& m, typename mat<2, 4, T>::row_type const& v)
	{
		return typename mat<2, 4, T>::col_type(
			m[0][0] * v.x + m[1][0] * v.y,
			m[0][1] * v.x + m[1][1] * v.y,
			m[0][2] * v.x + m[1][2] * v.y,
			m[0][3] * v.x + m[1][3] * v.y);
	}

	template<typename T>
	 inline typename mat<2, 4, T>::row_type operator*(typename mat<2, 4, T>::col_type const& v, mat<2, 4, T> const& m)
	{
		return typename mat<2, 4, T>::row_type(
			v.x * m[0][0] + v.y * m[0][1] + v.z * m[0][2] + v.w * m[0][3],
			v.x * m[1][0] + v.y * m[1][1] + v.z * m[1][2] + v.w * m[1][3]);
	}

	template<typename T>
	 inline mat<4, 4, T> operator*(mat<2, 4, T> const& m1, mat<4, 2, T> const& m2)
	{
		T SrcA00 = m1[0][0];
		T SrcA01 = m1[0][1];
		T SrcA02 = m1[0][2];
		T SrcA03 = m1[0][3];
		T SrcA10 = m1[1][0];
		T SrcA11 = m1[1][1];
		T SrcA12 = m1[1][2];
		T SrcA13 = m1[1][3];

		T SrcB00 = m2[0][0];
		T SrcB01 = m2[0][1];
		T SrcB10 = m2[1][0];
		T SrcB11 = m2[1][1];
		T SrcB20 = m2[2][0];
		T SrcB21 = m2[2][1];
		T SrcB30 = m2[3][0];
		T SrcB31 = m2[3][1];

		mat<4, 4, T> Result;
		Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01;
		Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01;
		Result[0][2] = SrcA02 * SrcB00 + SrcA12 * SrcB01;
		Result[0][3] = SrcA03 * SrcB00 + SrcA13 * SrcB01;
		Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11;
		Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11;
		Result[1][2] = SrcA02 * SrcB10 + SrcA12 * SrcB11;
		Result[1][3] = SrcA03 * SrcB10 + SrcA13 * SrcB11;
		Result[2][0] = SrcA00 * SrcB20 + SrcA10 * SrcB21;
		Result[2][1] = SrcA01 * SrcB20 + SrcA11 * SrcB21;
		Result[2][2] = SrcA02 * SrcB20 + SrcA12 * SrcB21;
		Result[2][3] = SrcA03 * SrcB20 + SrcA13 * SrcB21;
		Result[3][0] = SrcA00 * SrcB30 + SrcA10 * SrcB31;
		Result[3][1] = SrcA01 * SrcB30 + SrcA11 * SrcB31;
		Result[3][2] = SrcA02 * SrcB30 + SrcA12 * SrcB31;
		Result[3][3] = SrcA03 * SrcB30 + SrcA13 * SrcB31;
		return Result;
	}

	template<typename T>
	 inline mat<2, 4, T> operator*(mat<2, 4, T> const& m1, mat<2, 2, T> const& m2)
	{
		return mat<2, 4, T>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
			m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1],
			m1[0][3] * m2[0][0] + m1[1][3] * m2[0][1],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1],
			m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1],
			m1[0][3] * m2[1][0] + m1[1][3] * m2[1][1]);
	}

	template<typename T>
	 inline mat<3, 4, T> operator*(mat<2, 4, T> const& m1, mat<3, 2, T> const& m2)
	{
		return mat<3, 4, T>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
			m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1],
			m1[0][3] * m2[0][0] + m1[1][3] * m2[0][1],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1],
			m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1],
			m1[0][3] * m2[1][0] + m1[1][3] * m2[1][1],
			m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1],
			m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1],
			m1[0][2] * m2[2][0] + m1[1][2] * m2[2][1],
			m1[0][3] * m2[2][0] + m1[1][3] * m2[2][1]);
	}

	template<typename T>
	 inline mat<2, 4, T> operator/(mat<2, 4, T> const& m, T scalar)
	{
		return mat<2, 4, T>(
			m[0] / scalar,
			m[1] / scalar);
	}

	template<typename T>
	 inline mat<2, 4, T> operator/(T scalar, mat<2, 4, T> const& m)
	{
		return mat<2, 4, T>(
			scalar / m[0],
			scalar / m[1]);
	}

	

	template<typename T>
	 inline bool operator==(mat<2, 4, T> const& m1, mat<2, 4, T> const& m2)
	{
		return (m1[0] == m2[0]) && (m1[1] == m2[1]);
	}

	template<typename T>
	 inline bool operator!=(mat<2, 4, T> const& m1, mat<2, 4, T> const& m2)
	{
		return (m1[0] != m2[0]) || (m1[1] != m2[1]);
	}
} 
#line 150 "C:\\Projects\\glm\\glm\\ext\\../detail/type_mat2x4.hpp"
#line 151 "C:\\Projects\\glm\\glm\\ext\\../detail/type_mat2x4.hpp"
#line 6 "C:\\Projects\\glm\\glm\\./ext/matrix_double2x4.hpp"

namespace glm
{
	
	

	
	
	
	typedef mat<2, 4, double>		dmat2x4;

	
}
#line 6 "C:\\Projects\\glm\\glm\\mat2x4.hpp"
#line 1 "C:\\Projects\\glm\\glm\\./ext/matrix_float2x4.hpp"



#pragma once


namespace glm
{
	
	

	
	
	
	typedef mat<2, 4, float>		mat2x4;

	
}
#line 7 "C:\\Projects\\glm\\glm\\mat2x4.hpp"

#line 23 "C:\\Projects\\glm\\glm\\detail\\../matrix.hpp"
#line 1 "C:\\Projects\\glm\\glm\\mat3x2.hpp"



#pragma once
#line 1 "C:\\Projects\\glm\\glm\\./ext/matrix_double3x2.hpp"



#pragma once
#line 1 "C:\\Projects\\glm\\glm\\ext\\../detail/type_mat3x2.hpp"



#pragma once






namespace glm
{
	template<typename T>
	struct mat<3, 2, T>
	{
		typedef vec<2, T> col_type;
		typedef vec<3, T> row_type;
		typedef mat<3, 2, T> type;
		typedef mat<2, 3, T> transpose_type;
		typedef T value_type;

	private:
		col_type value[3];

	public:
		

		typedef length_t length_type;
		 static constexpr length_type length() { return 3; }

		 col_type & operator[](length_type i);
		 constexpr col_type const& operator[](length_type i) const;

		

		 constexpr mat() = default;
		 constexpr mat(mat<3, 2, T> const& m);

		 explicit constexpr mat(T scalar);
		 constexpr mat(
			T x0, T y0,
			T x1, T y1,
			T x2, T y2);
		 constexpr mat(
			col_type const& v0,
			col_type const& v1,
			col_type const& v2);

		

		template<
			typename X1, typename Y1,
			typename X2, typename Y2,
			typename X3, typename Y3>
		 constexpr mat(
			X1 x1, Y1 y1,
			X2 x2, Y2 y2,
			X3 x3, Y3 y3);

		template<typename V1, typename V2, typename V3>
		 constexpr mat(
			vec<2, V1> const& v1,
			vec<2, V2> const& v2,
			vec<2, V3> const& v3);

		

		template<typename U>
		  constexpr mat(mat<3, 2, U> const& m);

		  constexpr mat(mat<2, 2, T> const& x);
		  constexpr mat(mat<3, 3, T> const& x);
		  constexpr mat(mat<4, 4, T> const& x);
		  constexpr mat(mat<2, 3, T> const& x);
		  constexpr mat(mat<2, 4, T> const& x);
		  constexpr mat(mat<3, 4, T> const& x);
		  constexpr mat(mat<4, 2, T> const& x);
		  constexpr mat(mat<4, 3, T> const& x);

		

		template<typename U>
		 mat<3, 2, T> & operator=(mat<3, 2, U> const& m);
		template<typename U>
		 mat<3, 2, T> & operator+=(U s);
		template<typename U>
		 mat<3, 2, T> & operator+=(mat<3, 2, U> const& m);
		template<typename U>
		 mat<3, 2, T> & operator-=(U s);
		template<typename U>
		 mat<3, 2, T> & operator-=(mat<3, 2, U> const& m);
		template<typename U>
		 mat<3, 2, T> & operator*=(U s);
		template<typename U>
		 mat<3, 2, T> & operator/=(U s);
	};

	

	template<typename T>
	 mat<3, 2, T> operator+(mat<3, 2, T> const& m);

	template<typename T>
	 mat<3, 2, T> operator-(mat<3, 2, T> const& m);

	

	template<typename T>
	 mat<3, 2, T> operator+(mat<3, 2, T> const& m, T scalar);

	template<typename T>
	 mat<3, 2, T> operator+(mat<3, 2, T> const& m1, mat<3, 2, T> const& m2);

	template<typename T>
	 mat<3, 2, T> operator-(mat<3, 2, T> const& m, T scalar);

	template<typename T>
	 mat<3, 2, T> operator-(mat<3, 2, T> const& m1, mat<3, 2, T> const& m2);

	template<typename T>
	 mat<3, 2, T> operator*(mat<3, 2, T> const& m, T scalar);

	template<typename T>
	 mat<3, 2, T> operator*(T scalar, mat<3, 2, T> const& m);

	template<typename T>
	 typename mat<3, 2, T>::col_type operator*(mat<3, 2, T> const& m, typename mat<3, 2, T>::row_type const& v);

	template<typename T>
	 typename mat<3, 2, T>::row_type operator*(typename mat<3, 2, T>::col_type const& v, mat<3, 2, T> const& m);

	template<typename T>
	 mat<2, 2, T> operator*(mat<3, 2, T> const& m1, mat<2, 3, T> const& m2);

	template<typename T>
	 mat<3, 2, T> operator*(mat<3, 2, T> const& m1, mat<3, 3, T> const& m2);

	template<typename T>
	 mat<4, 2, T> operator*(mat<3, 2, T> const& m1, mat<4, 3, T> const& m2);

	template<typename T>
	 mat<3, 2, T> operator/(mat<3, 2, T> const& m, T scalar);

	template<typename T>
	 mat<3, 2, T> operator/(T scalar, mat<3, 2, T> const& m);

	

	template<typename T>
	 bool operator==(mat<3, 2, T> const& m1, mat<3, 2, T> const& m2);

	template<typename T>
	 bool operator!=(mat<3, 2, T> const& m1, mat<3, 2, T> const& m2);

}


#line 1 "C:\\Projects\\glm\\glm\\detail\\type_mat3x2.inl"
namespace glm
{
	














#line 19 "C:\\Projects\\glm\\glm\\detail\\type_mat3x2.inl"

	template<typename T>
	 inline constexpr mat<3, 2, T>::mat(mat<3, 2, T> const& m)

			: value{col_type(m[0]), col_type(m[1]), col_type(m[2])}
#line 25 "C:\\Projects\\glm\\glm\\detail\\type_mat3x2.inl"
	{




#line 31 "C:\\Projects\\glm\\glm\\detail\\type_mat3x2.inl"
	}

	template<typename T>
	 inline constexpr mat<3, 2, T>::mat(T s)

			: value{col_type(s, 0), col_type(0, s), col_type(0, 0)}
#line 38 "C:\\Projects\\glm\\glm\\detail\\type_mat3x2.inl"
	{




#line 44 "C:\\Projects\\glm\\glm\\detail\\type_mat3x2.inl"
	}

	template<typename T>
	 inline constexpr mat<3, 2, T>::mat
	(
		T x0, T y0,
		T x1, T y1,
		T x2, T y2
	)

			: value{col_type(x0, y0), col_type(x1, y1), col_type(x2, y2)}
#line 56 "C:\\Projects\\glm\\glm\\detail\\type_mat3x2.inl"
	{




#line 62 "C:\\Projects\\glm\\glm\\detail\\type_mat3x2.inl"
	}

	template<typename T>
	 inline constexpr mat<3, 2, T>::mat(col_type const& v0, col_type const& v1, col_type const& v2)

			: value{col_type(v0), col_type(v1), col_type(v2)}
#line 69 "C:\\Projects\\glm\\glm\\detail\\type_mat3x2.inl"
	{




#line 75 "C:\\Projects\\glm\\glm\\detail\\type_mat3x2.inl"
	}

	

	template<typename T>
	template<
		typename X0, typename Y0,
		typename X1, typename Y1,
		typename X2, typename Y2>
	 inline constexpr mat<3, 2, T>::mat
	(
		X0 x0, Y0 y0,
		X1 x1, Y1 y1,
		X2 x2, Y2 y2
	)

			: value{col_type(x0, y0), col_type(x1, y1), col_type(x2, y2)}
#line 93 "C:\\Projects\\glm\\glm\\detail\\type_mat3x2.inl"
	{




#line 99 "C:\\Projects\\glm\\glm\\detail\\type_mat3x2.inl"
	}

	template<typename T>
	template<typename V0, typename V1, typename V2>
	 inline constexpr mat<3, 2, T>::mat(vec<2, V0> const& v0, vec<2, V1> const& v1, vec<2, V2> const& v2)

			: value{col_type(v0), col_type(v1), col_type(v2)}
#line 107 "C:\\Projects\\glm\\glm\\detail\\type_mat3x2.inl"
	{




#line 113 "C:\\Projects\\glm\\glm\\detail\\type_mat3x2.inl"
	}

	

	template<typename T>
	 inline constexpr mat<3, 2, T>::mat(mat<2, 2, T> const& m)

			: value{col_type(m[0]), col_type(m[1]), col_type(0)}
#line 122 "C:\\Projects\\glm\\glm\\detail\\type_mat3x2.inl"
	{




#line 128 "C:\\Projects\\glm\\glm\\detail\\type_mat3x2.inl"
	}

	template<typename T>
	 inline constexpr mat<3, 2, T>::mat(mat<3, 3, T> const& m)

			: value{col_type(m[0]), col_type(m[1]), col_type(m[2])}
#line 135 "C:\\Projects\\glm\\glm\\detail\\type_mat3x2.inl"
	{




#line 141 "C:\\Projects\\glm\\glm\\detail\\type_mat3x2.inl"
	}

	template<typename T>
	 inline constexpr mat<3, 2, T>::mat(mat<4, 4, T> const& m)

			: value{col_type(m[0]), col_type(m[1]), col_type(m[2])}
#line 148 "C:\\Projects\\glm\\glm\\detail\\type_mat3x2.inl"
	{




#line 154 "C:\\Projects\\glm\\glm\\detail\\type_mat3x2.inl"
	}

	template<typename T>
	 inline constexpr mat<3, 2, T>::mat(mat<2, 3, T> const& m)

			: value{col_type(m[0]), col_type(m[1]), col_type(0)}
#line 161 "C:\\Projects\\glm\\glm\\detail\\type_mat3x2.inl"
	{




#line 167 "C:\\Projects\\glm\\glm\\detail\\type_mat3x2.inl"
	}

	template<typename T>
	 inline constexpr mat<3, 2, T>::mat(mat<2, 4, T> const& m)

			: value{col_type(m[0]), col_type(m[1]), col_type(0)}
#line 174 "C:\\Projects\\glm\\glm\\detail\\type_mat3x2.inl"
	{




#line 180 "C:\\Projects\\glm\\glm\\detail\\type_mat3x2.inl"
	}

	template<typename T>
	 inline constexpr mat<3, 2, T>::mat(mat<3, 4, T> const& m)

			: value{col_type(m[0]), col_type(m[1]), col_type(m[2])}
#line 187 "C:\\Projects\\glm\\glm\\detail\\type_mat3x2.inl"
	{




#line 193 "C:\\Projects\\glm\\glm\\detail\\type_mat3x2.inl"
	}

	template<typename T>
	 inline constexpr mat<3, 2, T>::mat(mat<4, 2, T> const& m)

			: value{col_type(m[0]), col_type(m[1]), col_type(m[2])}
#line 200 "C:\\Projects\\glm\\glm\\detail\\type_mat3x2.inl"
	{




#line 206 "C:\\Projects\\glm\\glm\\detail\\type_mat3x2.inl"
	}

	template<typename T>
	 inline constexpr mat<3, 2, T>::mat(mat<4, 3, T> const& m)

			: value{col_type(m[0]), col_type(m[1]), col_type(m[2])}
#line 213 "C:\\Projects\\glm\\glm\\detail\\type_mat3x2.inl"
	{




#line 219 "C:\\Projects\\glm\\glm\\detail\\type_mat3x2.inl"
	}

	

	template<typename T>
	 inline typename mat<3, 2, T>::col_type & mat<3, 2, T>::operator[](typename mat<3, 2, T>::length_type i)
	{
		(void)( (!!(i < this->length())) || (_wassert(L"i < this->length()", L"C:\\Projects\\glm\\glm\\detail\\type_mat3x2.inl", (unsigned)(226)), 0) );
		return this->value[i];
	}

	template<typename T>
	 inline constexpr typename mat<3, 2, T>::col_type const& mat<3, 2, T>::operator[](typename mat<3, 2, T>::length_type i) const
	{
		(void)( (!!(i < this->length())) || (_wassert(L"i < this->length()", L"C:\\Projects\\glm\\glm\\detail\\type_mat3x2.inl", (unsigned)(233)), 0) );
		return this->value[i];
	}

	

	template<typename T>
	template<typename U>
	 inline mat<3, 2, T>& mat<3, 2, T>::operator=(mat<3, 2, U> const& m)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
		this->value[2] = m[2];
		return *this;
	}

	template<typename T>
	template<typename U>
	 inline mat<3, 2, T>& mat<3, 2, T>::operator+=(U s)
	{
		this->value[0] += s;
		this->value[1] += s;
		this->value[2] += s;
		return *this;
	}

	template<typename T>
	template<typename U>
	 inline mat<3, 2, T>& mat<3, 2, T>::operator+=(mat<3, 2, U> const& m)
	{
		this->value[0] += m[0];
		this->value[1] += m[1];
		this->value[2] += m[2];
		return *this;
	}

	template<typename T>
	template<typename U>
	 inline mat<3, 2, T>& mat<3, 2, T>::operator-=(U s)
	{
		this->value[0] -= s;
		this->value[1] -= s;
		this->value[2] -= s;
		return *this;
	}

	template<typename T>
	template<typename U>
	 inline mat<3, 2, T>& mat<3, 2, T>::operator-=(mat<3, 2, U> const& m)
	{
		this->value[0] -= m[0];
		this->value[1] -= m[1];
		this->value[2] -= m[2];
		return *this;
	}

	template<typename T>
	template<typename U>
	 inline mat<3, 2, T>& mat<3, 2, T>::operator*=(U s)
	{
		this->value[0] *= s;
		this->value[1] *= s;
		this->value[2] *= s;
		return *this;
	}

	template<typename T>
	template<typename U>
	 inline mat<3, 2, T> & mat<3, 2, T>::operator/=(U s)
	{
		this->value[0] /= s;
		this->value[1] /= s;
		this->value[2] /= s;
		return *this;
	}

	

	template<typename T>
	 inline mat<3, 2, T> operator+(mat<3, 2, T> const& m)
	{
		return m;
	}

	template<typename T>
	 inline mat<3, 2, T> operator-(mat<3, 2, T> const& m)
	{
		return mat<3, 2, T>(
			-m[0],
			-m[1],
			-m[2]);
	}

	

	template<typename T>
	 inline mat<3, 2, T> operator+(mat<3, 2, T> const& m, T scalar)
	{
		return mat<3, 2, T>(
			m[0] + scalar,
			m[1] + scalar,
			m[2] + scalar);
	}

	template<typename T>
	 inline mat<3, 2, T> operator+(mat<3, 2, T> const& m1, mat<3, 2, T> const& m2)
	{
		return mat<3, 2, T>(
			m1[0] + m2[0],
			m1[1] + m2[1],
			m1[2] + m2[2]);
	}

	template<typename T>
	 inline mat<3, 2, T> operator-(mat<3, 2, T> const& m, T scalar)
	{
		return mat<3, 2, T>(
			m[0] - scalar,
			m[1] - scalar,
			m[2] - scalar);
	}

	template<typename T>
	 inline mat<3, 2, T> operator-(mat<3, 2, T> const& m1, mat<3, 2, T> const& m2)
	{
		return mat<3, 2, T>(
			m1[0] - m2[0],
			m1[1] - m2[1],
			m1[2] - m2[2]);
	}

	template<typename T>
	 inline mat<3, 2, T> operator*(mat<3, 2, T> const& m, T scalar)
	{
		return mat<3, 2, T>(
			m[0] * scalar,
			m[1] * scalar,
			m[2] * scalar);
	}

	template<typename T>
	 inline mat<3, 2, T> operator*(T scalar, mat<3, 2, T> const& m)
	{
		return mat<3, 2, T>(
			m[0] * scalar,
			m[1] * scalar,
			m[2] * scalar);
	}

	template<typename T>
	 inline typename mat<3, 2, T>::col_type operator*(mat<3, 2, T> const& m, typename mat<3, 2, T>::row_type const& v)
	{
		return typename mat<3, 2, T>::col_type(
			m[0][0] * v.x + m[1][0] * v.y + m[2][0] * v.z,
			m[0][1] * v.x + m[1][1] * v.y + m[2][1] * v.z);
	}

	template<typename T>
	 inline typename mat<3, 2, T>::row_type operator*(typename mat<3, 2, T>::col_type const& v, mat<3, 2, T> const& m)
	{
		return typename mat<3, 2, T>::row_type(
			v.x * m[0][0] + v.y * m[0][1],
			v.x * m[1][0] + v.y * m[1][1],
			v.x * m[2][0] + v.y * m[2][1]);
	}

	template<typename T>
	 inline mat<2, 2, T> operator*(mat<3, 2, T> const& m1, mat<2, 3, T> const& m2)
	{
		const T SrcA00 = m1[0][0];
		const T SrcA01 = m1[0][1];
		const T SrcA10 = m1[1][0];
		const T SrcA11 = m1[1][1];
		const T SrcA20 = m1[2][0];
		const T SrcA21 = m1[2][1];

		const T SrcB00 = m2[0][0];
		const T SrcB01 = m2[0][1];
		const T SrcB02 = m2[0][2];
		const T SrcB10 = m2[1][0];
		const T SrcB11 = m2[1][1];
		const T SrcB12 = m2[1][2];

		mat<2, 2, T> Result;
		Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01 + SrcA20 * SrcB02;
		Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01 + SrcA21 * SrcB02;
		Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11 + SrcA20 * SrcB12;
		Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11 + SrcA21 * SrcB12;
		return Result;
	}

	template<typename T>
	 inline mat<3, 2, T> operator*(mat<3, 2, T> const& m1, mat<3, 3, T> const& m2)
	{
		return mat<3, 2, T>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2],
			m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2],
			m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2]);
	}

	template<typename T>
	 inline mat<4, 2, T> operator*(mat<3, 2, T> const& m1, mat<4, 3, T> const& m2)
	{
		return mat<4, 2, T>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2],
			m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2],
			m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2],
			m1[0][0] * m2[3][0] + m1[1][0] * m2[3][1] + m1[2][0] * m2[3][2],
			m1[0][1] * m2[3][0] + m1[1][1] * m2[3][1] + m1[2][1] * m2[3][2]);
	}

	template<typename T>
	 inline mat<3, 2, T> operator/(mat<3, 2, T> const& m, T scalar)
	{
		return mat<3, 2, T>(
			m[0] / scalar,
			m[1] / scalar,
			m[2] / scalar);
	}

	template<typename T>
	 inline mat<3, 2, T> operator/(T scalar, mat<3, 2, T> const& m)
	{
		return mat<3, 2, T>(
			scalar / m[0],
			scalar / m[1],
			scalar / m[2]);
	}

	

	template<typename T>
	 inline bool operator==(mat<3, 2, T> const& m1, mat<3, 2, T> const& m2)
	{
		return (m1[0] == m2[0]) && (m1[1] == m2[1]) && (m1[2] == m2[2]);
	}

	template<typename T>
	 inline bool operator!=(mat<3, 2, T> const& m1, mat<3, 2, T> const& m2)
	{
		return (m1[0] != m2[0]) || (m1[1] != m2[1]) || (m1[2] != m2[2]);
	}
} 
#line 159 "C:\\Projects\\glm\\glm\\ext\\../detail/type_mat3x2.hpp"
#line 160 "C:\\Projects\\glm\\glm\\ext\\../detail/type_mat3x2.hpp"
#line 6 "C:\\Projects\\glm\\glm\\./ext/matrix_double3x2.hpp"

namespace glm
{
	
	

	
	
	
	typedef mat<3, 2, double>		dmat3x2;

	
}
#line 6 "C:\\Projects\\glm\\glm\\mat3x2.hpp"
#line 1 "C:\\Projects\\glm\\glm\\./ext/matrix_float3x2.hpp"



#pragma once


namespace glm
{
	
	

	
	
	
	typedef mat<3, 2, float>			mat3x2;

	
}
#line 7 "C:\\Projects\\glm\\glm\\mat3x2.hpp"
#line 24 "C:\\Projects\\glm\\glm\\detail\\../matrix.hpp"

#line 1 "C:\\Projects\\glm\\glm\\mat3x4.hpp"



#pragma once
#line 1 "C:\\Projects\\glm\\glm\\./ext/matrix_double3x4.hpp"



#pragma once
#line 1 "C:\\Projects\\glm\\glm\\ext\\../detail/type_mat3x4.hpp"



#pragma once






namespace glm
{
	template<typename T>
	struct mat<3, 4, T>
	{
		typedef vec<4, T> col_type;
		typedef vec<3, T> row_type;
		typedef mat<3, 4, T> type;
		typedef mat<4, 3, T> transpose_type;
		typedef T value_type;

	private:
		col_type value[3];

	public:
		

		typedef length_t length_type;
		 static constexpr length_type length() { return 3; }

		 col_type & operator[](length_type i);
		 constexpr col_type const& operator[](length_type i) const;

		

		 constexpr mat() = default;
		 constexpr mat(mat<3, 4, T> const& m);

		 explicit constexpr mat(T scalar);
		 constexpr mat(
			T x0, T y0, T z0, T w0,
			T x1, T y1, T z1, T w1,
			T x2, T y2, T z2, T w2);
		 constexpr mat(
			col_type const& v0,
			col_type const& v1,
			col_type const& v2);

		

		template<
			typename X1, typename Y1, typename Z1, typename W1,
			typename X2, typename Y2, typename Z2, typename W2,
			typename X3, typename Y3, typename Z3, typename W3>
		 constexpr mat(
			X1 x1, Y1 y1, Z1 z1, W1 w1,
			X2 x2, Y2 y2, Z2 z2, W2 w2,
			X3 x3, Y3 y3, Z3 z3, W3 w3);

		template<typename V1, typename V2, typename V3>
		 constexpr mat(
			vec<4, V1> const& v1,
			vec<4, V2> const& v2,
			vec<4, V3> const& v3);

		

		  constexpr mat(mat<2, 2, T> const& x);
		  constexpr mat(mat<3, 3, T> const& x);
		  constexpr mat(mat<4, 4, T> const& x);
		  constexpr mat(mat<2, 3, T> const& x);
		  constexpr mat(mat<3, 2, T> const& x);
		  constexpr mat(mat<2, 4, T> const& x);
		  constexpr mat(mat<4, 2, T> const& x);
		  constexpr mat(mat<4, 3, T> const& x);

		

		template<typename U>
		 mat<3, 4, T> & operator=(mat<3, 4, U> const& m);
		template<typename U>
		 mat<3, 4, T> & operator+=(U s);
		template<typename U>
		 mat<3, 4, T> & operator+=(mat<3, 4, U> const& m);
		template<typename U>
		 mat<3, 4, T> & operator-=(U s);
		template<typename U>
		 mat<3, 4, T> & operator-=(mat<3, 4, U> const& m);
		template<typename U>
		 mat<3, 4, T> & operator*=(U s);
		template<typename U>
		 mat<3, 4, T> & operator/=(U s);
	};

	

	template<typename T>
	 mat<3, 4, T> operator+(mat<3, 4, T> const& m);

	template<typename T>
	 mat<3, 4, T> operator-(mat<3, 4, T> const& m);

	

	template<typename T>
	 mat<3, 4, T> operator+(mat<3, 4, T> const& m, T scalar);

	template<typename T>
	 mat<3, 4, T> operator+(mat<3, 4, T> const& m1, mat<3, 4, T> const& m2);

	template<typename T>
	 mat<3, 4, T> operator-(mat<3, 4, T> const& m, T scalar);

	template<typename T>
	 mat<3, 4, T> operator-(mat<3, 4, T> const& m1, mat<3, 4, T> const& m2);

	template<typename T>
	 mat<3, 4, T> operator*(mat<3, 4, T> const& m, T scalar);

	template<typename T>
	 mat<3, 4, T> operator*(T scalar, mat<3, 4, T> const& m);

	template<typename T>
	 typename mat<3, 4, T>::col_type operator*(mat<3, 4, T> const& m, typename mat<3, 4, T>::row_type const& v);

	template<typename T>
	 typename mat<3, 4, T>::row_type operator*(typename mat<3, 4, T>::col_type const& v, mat<3, 4, T> const& m);

	template<typename T>
	 mat<4, 4, T> operator*(mat<3, 4, T> const& m1,	mat<4, 3, T> const& m2);

	template<typename T>
	 mat<2, 4, T> operator*(mat<3, 4, T> const& m1, mat<2, 3, T> const& m2);

	template<typename T>
	 mat<3, 4, T> operator*(mat<3, 4, T> const& m1,	mat<3, 3, T> const& m2);

	template<typename T>
	 mat<3, 4, T> operator/(mat<3, 4, T> const& m, T scalar);

	template<typename T>
	 mat<3, 4, T> operator/(T scalar, mat<3, 4, T> const& m);

	

	template<typename T>
	 bool operator==(mat<3, 4, T> const& m1, mat<3, 4, T> const& m2);

	template<typename T>
	 bool operator!=(mat<3, 4, T> const& m1, mat<3, 4, T> const& m2);
}


#line 1 "C:\\Projects\\glm\\glm\\detail\\type_mat3x4.inl"
namespace glm
{
	














#line 19 "C:\\Projects\\glm\\glm\\detail\\type_mat3x4.inl"

	template<typename T>
	 inline constexpr mat<3, 4, T>::mat(mat<3, 4, T> const& m)

			: value{col_type(m[0]), col_type(m[1]), col_type(m[2])}
#line 25 "C:\\Projects\\glm\\glm\\detail\\type_mat3x4.inl"
	{




#line 31 "C:\\Projects\\glm\\glm\\detail\\type_mat3x4.inl"
	}

	template<typename T>
	 inline constexpr mat<3, 4, T>::mat(T s)

			: value{col_type(s, 0, 0, 0), col_type(0, s, 0, 0), col_type(0, 0, s, 0)}
#line 38 "C:\\Projects\\glm\\glm\\detail\\type_mat3x4.inl"
	{




#line 44 "C:\\Projects\\glm\\glm\\detail\\type_mat3x4.inl"
	}

	template<typename T>
	 inline constexpr mat<3, 4, T>::mat
	(
		T x0, T y0, T z0, T w0,
		T x1, T y1, T z1, T w1,
		T x2, T y2, T z2, T w2
	)

			: value{
				col_type(x0, y0, z0, w0),
				col_type(x1, y1, z1, w1),
				col_type(x2, y2, z2, w2)}
#line 59 "C:\\Projects\\glm\\glm\\detail\\type_mat3x4.inl"
	{




#line 65 "C:\\Projects\\glm\\glm\\detail\\type_mat3x4.inl"
	}

	template<typename T>
	 inline constexpr mat<3, 4, T>::mat(col_type const& v0, col_type const& v1, col_type const& v2)

			: value{col_type(v0), col_type(v1), col_type(v2)}
#line 72 "C:\\Projects\\glm\\glm\\detail\\type_mat3x4.inl"
	{




#line 78 "C:\\Projects\\glm\\glm\\detail\\type_mat3x4.inl"
	}

	

	template<typename T>
	template<
		typename X0, typename Y0, typename Z0, typename W0,
		typename X1, typename Y1, typename Z1, typename W1,
		typename X2, typename Y2, typename Z2, typename W2>
	 inline constexpr mat<3, 4, T>::mat
	(
		X0 x0, Y0 y0, Z0 z0, W0 w0,
		X1 x1, Y1 y1, Z1 z1, W1 w1,
		X2 x2, Y2 y2, Z2 z2, W2 w2
	)

			: value{
				col_type(x0, y0, z0, w0),
				col_type(x1, y1, z1, w1),
				col_type(x2, y2, z2, w2)}
#line 99 "C:\\Projects\\glm\\glm\\detail\\type_mat3x4.inl"
	{




#line 105 "C:\\Projects\\glm\\glm\\detail\\type_mat3x4.inl"
	}

	template<typename T>
	template<typename V1, typename V2, typename V3>
	 inline constexpr mat<3, 4, T>::mat(vec<4, V1> const& v0, vec<4, V2> const& v1, vec<4, V3> const& v2)

			: value{col_type(v0), col_type(v1), col_type(v2)}
#line 113 "C:\\Projects\\glm\\glm\\detail\\type_mat3x4.inl"
	{




#line 119 "C:\\Projects\\glm\\glm\\detail\\type_mat3x4.inl"
	}

	

	template<typename T>
	 inline constexpr mat<3, 4, T>::mat(mat<2, 2, T> const& m)

			: value{col_type(m[0], 0, 0), col_type(m[1], 0, 0), col_type(0, 0, 1, 0)}
#line 128 "C:\\Projects\\glm\\glm\\detail\\type_mat3x4.inl"
	{




#line 134 "C:\\Projects\\glm\\glm\\detail\\type_mat3x4.inl"
	}

	template<typename T>
	 inline constexpr mat<3, 4, T>::mat(mat<3, 3, T> const& m)

			: value{col_type(m[0], 0), col_type(m[1], 0), col_type(m[2], 0)}
#line 141 "C:\\Projects\\glm\\glm\\detail\\type_mat3x4.inl"
	{




#line 147 "C:\\Projects\\glm\\glm\\detail\\type_mat3x4.inl"
	}

	template<typename T>
	 inline constexpr mat<3, 4, T>::mat(mat<4, 4, T> const& m)

			: value{col_type(m[0]), col_type(m[1]), col_type(m[2])}
#line 154 "C:\\Projects\\glm\\glm\\detail\\type_mat3x4.inl"
	{




#line 160 "C:\\Projects\\glm\\glm\\detail\\type_mat3x4.inl"
	}

	template<typename T>
	 inline constexpr mat<3, 4, T>::mat(mat<2, 3, T> const& m)

			: value{col_type(m[0], 0), col_type(m[1], 0), col_type(0, 0, 1, 0)}
#line 167 "C:\\Projects\\glm\\glm\\detail\\type_mat3x4.inl"
	{




#line 173 "C:\\Projects\\glm\\glm\\detail\\type_mat3x4.inl"
	}

	template<typename T>
	 inline constexpr mat<3, 4, T>::mat(mat<3, 2, T> const& m)

			: value{col_type(m[0], 0, 0), col_type(m[1], 0, 0), col_type(m[2], 1, 0)}
#line 180 "C:\\Projects\\glm\\glm\\detail\\type_mat3x4.inl"
	{




#line 186 "C:\\Projects\\glm\\glm\\detail\\type_mat3x4.inl"
	}

	template<typename T>
	 inline constexpr mat<3, 4, T>::mat(mat<2, 4, T> const& m)

			: value{col_type(m[0]), col_type(m[1]), col_type(0, 0, 1, 0)}
#line 193 "C:\\Projects\\glm\\glm\\detail\\type_mat3x4.inl"
	{




#line 199 "C:\\Projects\\glm\\glm\\detail\\type_mat3x4.inl"
	}

	template<typename T>
	 inline constexpr mat<3, 4, T>::mat(mat<4, 2, T> const& m)

			: value{col_type(m[0], 0, 0), col_type(m[1], 0, 0), col_type(m[2], 1, 0)}
#line 206 "C:\\Projects\\glm\\glm\\detail\\type_mat3x4.inl"
	{




#line 212 "C:\\Projects\\glm\\glm\\detail\\type_mat3x4.inl"
	}

	template<typename T>
	 inline constexpr mat<3, 4, T>::mat(mat<4, 3, T> const& m)

			: value{col_type(m[0], 0), col_type(m[1], 0), col_type(m[2], 0)}
#line 219 "C:\\Projects\\glm\\glm\\detail\\type_mat3x4.inl"
	{




#line 225 "C:\\Projects\\glm\\glm\\detail\\type_mat3x4.inl"
	}

	

	template<typename T>
	 inline typename mat<3, 4, T>::col_type & mat<3, 4, T>::operator[](typename mat<3, 4, T>::length_type i)
	{
		(void)( (!!(i < this->length())) || (_wassert(L"i < this->length()", L"C:\\Projects\\glm\\glm\\detail\\type_mat3x4.inl", (unsigned)(232)), 0) );
		return this->value[i];
	}

	template<typename T>
	 inline constexpr typename mat<3, 4, T>::col_type const& mat<3, 4, T>::operator[](typename mat<3, 4, T>::length_type i) const
	{
		(void)( (!!(i < this->length())) || (_wassert(L"i < this->length()", L"C:\\Projects\\glm\\glm\\detail\\type_mat3x4.inl", (unsigned)(239)), 0) );
		return this->value[i];
	}

	

	template<typename T>
	template<typename U>
	 inline mat<3, 4, T>& mat<3, 4, T>::operator=(mat<3, 4, U> const& m)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
		this->value[2] = m[2];
		return *this;
	}

	template<typename T>
	template<typename U>
	 inline mat<3, 4, T>& mat<3, 4, T>::operator+=(U s)
	{
		this->value[0] += s;
		this->value[1] += s;
		this->value[2] += s;
		return *this;
	}

	template<typename T>
	template<typename U>
	 inline mat<3, 4, T>& mat<3, 4, T>::operator+=(mat<3, 4, U> const& m)
	{
		this->value[0] += m[0];
		this->value[1] += m[1];
		this->value[2] += m[2];
		return *this;
	}

	template<typename T>
	template<typename U>
	 inline mat<3, 4, T>& mat<3, 4, T>::operator-=(U s)
	{
		this->value[0] -= s;
		this->value[1] -= s;
		this->value[2] -= s;
		return *this;
	}

	template<typename T>
	template<typename U>
	 inline mat<3, 4, T>& mat<3, 4, T>::operator-=(mat<3, 4, U> const& m)
	{
		this->value[0] -= m[0];
		this->value[1] -= m[1];
		this->value[2] -= m[2];
		return *this;
	}

	template<typename T>
	template<typename U>
	 inline mat<3, 4, T>& mat<3, 4, T>::operator*=(U s)
	{
		this->value[0] *= s;
		this->value[1] *= s;
		this->value[2] *= s;
		return *this;
	}

	template<typename T>
	template<typename U>
	 inline mat<3, 4, T> & mat<3, 4, T>::operator/=(U s)
	{
		this->value[0] /= s;
		this->value[1] /= s;
		this->value[2] /= s;
		return *this;
	}

	

	template<typename T>
	 inline mat<3, 4, T> operator+(mat<3, 4, T> const& m)
	{
		return m;
	}

	template<typename T>
	 inline mat<3, 4, T> operator-(mat<3, 4, T> const& m)
	{
		return mat<3, 4, T>(
			-m[0],
			-m[1],
			-m[2]);
	}

	

	template<typename T>
	 inline mat<3, 4, T> operator+(mat<3, 4, T> const& m, T scalar)
	{
		return mat<3, 4, T>(
			m[0] + scalar,
			m[1] + scalar,
			m[2] + scalar);
	}

	template<typename T>
	 inline mat<3, 4, T> operator+(mat<3, 4, T> const& m1, mat<3, 4, T> const& m2)
	{
		return mat<3, 4, T>(
			m1[0] + m2[0],
			m1[1] + m2[1],
			m1[2] + m2[2]);
	}

	template<typename T>
	 inline mat<3, 4, T> operator-(mat<3, 4, T> const& m,	T scalar)
	{
		return mat<3, 4, T>(
			m[0] - scalar,
			m[1] - scalar,
			m[2] - scalar);
	}

	template<typename T>
	 inline mat<3, 4, T> operator-(mat<3, 4, T> const& m1, mat<3, 4, T> const& m2)
	{
		return mat<3, 4, T>(
			m1[0] - m2[0],
			m1[1] - m2[1],
			m1[2] - m2[2]);
	}

	template<typename T>
	 inline mat<3, 4, T> operator*(mat<3, 4, T> const& m, T scalar)
	{
		return mat<3, 4, T>(
			m[0] * scalar,
			m[1] * scalar,
			m[2] * scalar);
	}

	template<typename T>
	 inline mat<3, 4, T> operator*(T scalar, mat<3, 4, T> const& m)
	{
		return mat<3, 4, T>(
			m[0] * scalar,
			m[1] * scalar,
			m[2] * scalar);
	}

	template<typename T>
	 inline typename mat<3, 4, T>::col_type operator*
	(
		mat<3, 4, T> const& m,
		typename mat<3, 4, T>::row_type const& v
	)
	{
		return typename mat<3, 4, T>::col_type(
			m[0][0] * v.x + m[1][0] * v.y + m[2][0] * v.z,
			m[0][1] * v.x + m[1][1] * v.y + m[2][1] * v.z,
			m[0][2] * v.x + m[1][2] * v.y + m[2][2] * v.z,
			m[0][3] * v.x + m[1][3] * v.y + m[2][3] * v.z);
	}

	template<typename T>
	 inline typename mat<3, 4, T>::row_type operator*
	(
		typename mat<3, 4, T>::col_type const& v,
		mat<3, 4, T> const& m
	)
	{
		return typename mat<3, 4, T>::row_type(
			v.x * m[0][0] + v.y * m[0][1] + v.z * m[0][2] + v.w * m[0][3],
			v.x * m[1][0] + v.y * m[1][1] + v.z * m[1][2] + v.w * m[1][3],
			v.x * m[2][0] + v.y * m[2][1] + v.z * m[2][2] + v.w * m[2][3]);
	}

	template<typename T>
	 inline mat<4, 4, T> operator*(mat<3, 4, T> const& m1, mat<4, 3, T> const& m2)
	{
		const T SrcA00 = m1[0][0];
		const T SrcA01 = m1[0][1];
		const T SrcA02 = m1[0][2];
		const T SrcA03 = m1[0][3];
		const T SrcA10 = m1[1][0];
		const T SrcA11 = m1[1][1];
		const T SrcA12 = m1[1][2];
		const T SrcA13 = m1[1][3];
		const T SrcA20 = m1[2][0];
		const T SrcA21 = m1[2][1];
		const T SrcA22 = m1[2][2];
		const T SrcA23 = m1[2][3];

		const T SrcB00 = m2[0][0];
		const T SrcB01 = m2[0][1];
		const T SrcB02 = m2[0][2];
		const T SrcB10 = m2[1][0];
		const T SrcB11 = m2[1][1];
		const T SrcB12 = m2[1][2];
		const T SrcB20 = m2[2][0];
		const T SrcB21 = m2[2][1];
		const T SrcB22 = m2[2][2];
		const T SrcB30 = m2[3][0];
		const T SrcB31 = m2[3][1];
		const T SrcB32 = m2[3][2];

		mat<4, 4, T> Result;
		Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01 + SrcA20 * SrcB02;
		Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01 + SrcA21 * SrcB02;
		Result[0][2] = SrcA02 * SrcB00 + SrcA12 * SrcB01 + SrcA22 * SrcB02;
		Result[0][3] = SrcA03 * SrcB00 + SrcA13 * SrcB01 + SrcA23 * SrcB02;
		Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11 + SrcA20 * SrcB12;
		Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11 + SrcA21 * SrcB12;
		Result[1][2] = SrcA02 * SrcB10 + SrcA12 * SrcB11 + SrcA22 * SrcB12;
		Result[1][3] = SrcA03 * SrcB10 + SrcA13 * SrcB11 + SrcA23 * SrcB12;
		Result[2][0] = SrcA00 * SrcB20 + SrcA10 * SrcB21 + SrcA20 * SrcB22;
		Result[2][1] = SrcA01 * SrcB20 + SrcA11 * SrcB21 + SrcA21 * SrcB22;
		Result[2][2] = SrcA02 * SrcB20 + SrcA12 * SrcB21 + SrcA22 * SrcB22;
		Result[2][3] = SrcA03 * SrcB20 + SrcA13 * SrcB21 + SrcA23 * SrcB22;
		Result[3][0] = SrcA00 * SrcB30 + SrcA10 * SrcB31 + SrcA20 * SrcB32;
		Result[3][1] = SrcA01 * SrcB30 + SrcA11 * SrcB31 + SrcA21 * SrcB32;
		Result[3][2] = SrcA02 * SrcB30 + SrcA12 * SrcB31 + SrcA22 * SrcB32;
		Result[3][3] = SrcA03 * SrcB30 + SrcA13 * SrcB31 + SrcA23 * SrcB32;
		return Result;
	}

	template<typename T>
	 inline mat<2, 4, T> operator*(mat<3, 4, T> const& m1, mat<2, 3, T> const& m2)
	{
		return mat<2, 4, T>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2],
			m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2],
			m1[0][3] * m2[0][0] + m1[1][3] * m2[0][1] + m1[2][3] * m2[0][2],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2],
			m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2],
			m1[0][3] * m2[1][0] + m1[1][3] * m2[1][1] + m1[2][3] * m2[1][2]);
	}

	template<typename T>
	 inline mat<3, 4, T> operator*(mat<3, 4, T> const& m1, mat<3, 3, T> const& m2)
	{
		return mat<3, 4, T>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2],
			m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2],
			m1[0][3] * m2[0][0] + m1[1][3] * m2[0][1] + m1[2][3] * m2[0][2],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2],
			m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2],
			m1[0][3] * m2[1][0] + m1[1][3] * m2[1][1] + m1[2][3] * m2[1][2],
			m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2],
			m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2],
			m1[0][2] * m2[2][0] + m1[1][2] * m2[2][1] + m1[2][2] * m2[2][2],
			m1[0][3] * m2[2][0] + m1[1][3] * m2[2][1] + m1[2][3] * m2[2][2]);
	}

	template<typename T>
	 inline mat<3, 4, T> operator/(mat<3, 4, T> const& m,	T scalar)
	{
		return mat<3, 4, T>(
			m[0] / scalar,
			m[1] / scalar,
			m[2] / scalar);
	}

	template<typename T>
	 inline mat<3, 4, T> operator/(T scalar, mat<3, 4, T> const& m)
	{
		return mat<3, 4, T>(
			scalar / m[0],
			scalar / m[1],
			scalar / m[2]);
	}

	

	template<typename T>
	 inline bool operator==(mat<3, 4, T> const& m1, mat<3, 4, T> const& m2)
	{
		return (m1[0] == m2[0]) && (m1[1] == m2[1]) && (m1[2] == m2[2]);
	}

	template<typename T>
	 inline bool operator!=(mat<3, 4, T> const& m1, mat<3, 4, T> const& m2)
	{
		return (m1[0] != m2[0]) || (m1[1] != m2[1]) || (m1[2] != m2[2]);
	}
} 
#line 155 "C:\\Projects\\glm\\glm\\ext\\../detail/type_mat3x4.hpp"
#line 156 "C:\\Projects\\glm\\glm\\ext\\../detail/type_mat3x4.hpp"
#line 6 "C:\\Projects\\glm\\glm\\./ext/matrix_double3x4.hpp"

namespace glm
{
	
	

	
	
	
	typedef mat<3, 4, double>		dmat3x4;

	
}
#line 6 "C:\\Projects\\glm\\glm\\mat3x4.hpp"
#line 1 "C:\\Projects\\glm\\glm\\./ext/matrix_float3x4.hpp"



#pragma once


namespace glm
{
	
	

	
	
	
	typedef mat<3, 4, float>			mat3x4;

	
}
#line 7 "C:\\Projects\\glm\\glm\\mat3x4.hpp"
#line 26 "C:\\Projects\\glm\\glm\\detail\\../matrix.hpp"
#line 1 "C:\\Projects\\glm\\glm\\mat4x2.hpp"



#pragma once
#line 1 "C:\\Projects\\glm\\glm\\./ext/matrix_double4x2.hpp"



#pragma once
#line 1 "C:\\Projects\\glm\\glm\\ext\\../detail/type_mat4x2.hpp"



#pragma once






namespace glm
{
	template<typename T>
	struct mat<4, 2, T>
	{
		typedef vec<2, T> col_type;
		typedef vec<4, T> row_type;
		typedef mat<4, 2, T> type;
		typedef mat<2, 4, T> transpose_type;
		typedef T value_type;

	private:
		col_type value[4];

	public:
		

		typedef length_t length_type;
		 static constexpr length_type length() { return 4; }

		 col_type & operator[](length_type i);
		 constexpr col_type const& operator[](length_type i) const;

		

		 constexpr mat() = default;
		 constexpr mat(mat<4, 2, T> const& m);

		 explicit constexpr mat(T scalar);
		 constexpr mat(
			T x0, T y0,
			T x1, T y1,
			T x2, T y2,
			T x3, T y3);
		 constexpr mat(
			col_type const& v0,
			col_type const& v1,
			col_type const& v2,
			col_type const& v3);

		

		template<
			typename X0, typename Y0,
			typename X1, typename Y1,
			typename X2, typename Y2,
			typename X3, typename Y3>
		 constexpr mat(
			X0 x0, Y0 y0,
			X1 x1, Y1 y1,
			X2 x2, Y2 y2,
			X3 x3, Y3 y3);

		template<typename V1, typename V2, typename V3, typename V4>
		 constexpr mat(
			vec<2, V1> const& v1,
			vec<2, V2> const& v2,
			vec<2, V3> const& v3,
			vec<2, V4> const& v4);

		

		  constexpr mat(mat<2, 2, T> const& x);
		  constexpr mat(mat<3, 3, T> const& x);
		  constexpr mat(mat<4, 4, T> const& x);
		  constexpr mat(mat<2, 3, T> const& x);
		  constexpr mat(mat<3, 2, T> const& x);
		  constexpr mat(mat<2, 4, T> const& x);
		  constexpr mat(mat<4, 3, T> const& x);
		  constexpr mat(mat<3, 4, T> const& x);

		

		template<typename U>
		 mat<4, 2, T> & operator=(mat<4, 2, U> const& m);
		template<typename U>
		 mat<4, 2, T> & operator+=(U s);
		template<typename U>
		 mat<4, 2, T> & operator+=(mat<4, 2, U> const& m);
		template<typename U>
		 mat<4, 2, T> & operator-=(U s);
		template<typename U>
		 mat<4, 2, T> & operator-=(mat<4, 2, U> const& m);
		template<typename U>
		 mat<4, 2, T> & operator*=(U s);
		template<typename U>
		 mat<4, 2, T> & operator/=(U s);
	};

	

	template<typename T>
	 mat<4, 2, T> operator+(mat<4, 2, T> const& m);

	template<typename T>
	 mat<4, 2, T> operator-(mat<4, 2, T> const& m);

	

	template<typename T>
	 mat<4, 2, T> operator+(mat<4, 2, T> const& m, T scalar);

	template<typename T>
	 mat<4, 2, T> operator+(mat<4, 2, T> const& m1, mat<4, 2, T> const& m2);

	template<typename T>
	 mat<4, 2, T> operator-(mat<4, 2, T> const& m, T scalar);

	template<typename T>
	 mat<4, 2, T> operator-(mat<4, 2, T> const& m1,	mat<4, 2, T> const& m2);

	template<typename T>
	 mat<4, 2, T> operator*(mat<4, 2, T> const& m, T scalar);

	template<typename T>
	 mat<4, 2, T> operator*(T scalar, mat<4, 2, T> const& m);

	template<typename T>
	 typename mat<4, 2, T>::col_type operator*(mat<4, 2, T> const& m, typename mat<4, 2, T>::row_type const& v);

	template<typename T>
	 typename mat<4, 2, T>::row_type operator*(typename mat<4, 2, T>::col_type const& v, mat<4, 2, T> const& m);

	template<typename T>
	 mat<2, 2, T> operator*(mat<4, 2, T> const& m1, mat<2, 4, T> const& m2);

	template<typename T>
	 mat<3, 2, T> operator*(mat<4, 2, T> const& m1, mat<3, 4, T> const& m2);

	template<typename T>
	 mat<4, 2, T> operator*(mat<4, 2, T> const& m1, mat<4, 4, T> const& m2);

	template<typename T>
	 mat<4, 2, T> operator/(mat<4, 2, T> const& m, T scalar);

	template<typename T>
	 mat<4, 2, T> operator/(T scalar, mat<4, 2, T> const& m);

	

	template<typename T>
	 bool operator==(mat<4, 2, T> const& m1, mat<4, 2, T> const& m2);

	template<typename T>
	 bool operator!=(mat<4, 2, T> const& m1, mat<4, 2, T> const& m2);
}


#line 1 "C:\\Projects\\glm\\glm\\detail\\type_mat4x2.inl"
namespace glm
{
	















#line 20 "C:\\Projects\\glm\\glm\\detail\\type_mat4x2.inl"

	template<typename T>
	 inline constexpr mat<4, 2, T>::mat(mat<4, 2, T> const& m)

			: value{col_type(m[0]), col_type(m[1]), col_type(m[2]), col_type(m[3])}
#line 26 "C:\\Projects\\glm\\glm\\detail\\type_mat4x2.inl"
	{





#line 33 "C:\\Projects\\glm\\glm\\detail\\type_mat4x2.inl"
	}

	template<typename T>
	 inline constexpr mat<4, 2, T>::mat(T s)

			: value{col_type(s, 0), col_type(0, s), col_type(0, 0), col_type(0, 0)}
#line 40 "C:\\Projects\\glm\\glm\\detail\\type_mat4x2.inl"
	{





#line 47 "C:\\Projects\\glm\\glm\\detail\\type_mat4x2.inl"
	}

	template<typename T>
	 inline constexpr mat<4, 2, T>::mat
	(
		T x0, T y0,
		T x1, T y1,
		T x2, T y2,
		T x3, T y3
	)

			: value{col_type(x0, y0), col_type(x1, y1), col_type(x2, y2), col_type(x3, y3)}
#line 60 "C:\\Projects\\glm\\glm\\detail\\type_mat4x2.inl"
	{





#line 67 "C:\\Projects\\glm\\glm\\detail\\type_mat4x2.inl"
	}

	template<typename T>
	 inline constexpr mat<4, 2, T>::mat(col_type const& v0, col_type const& v1, col_type const& v2, col_type const& v3)

			: value{col_type(v0), col_type(v1), col_type(v2), col_type(v3)}
#line 74 "C:\\Projects\\glm\\glm\\detail\\type_mat4x2.inl"
	{





#line 81 "C:\\Projects\\glm\\glm\\detail\\type_mat4x2.inl"
	}

	

	template<typename T>
	template<
		typename X0, typename Y0,
		typename X1, typename Y1,
		typename X2, typename Y2,
		typename X3, typename Y3>
	 inline constexpr mat<4, 2, T>::mat
	(
		X0 x0, Y0 y0,
		X1 x1, Y1 y1,
		X2 x2, Y2 y2,
		X3 x3, Y3 y3
	)

			: value{col_type(x0, y0), col_type(x1, y1), col_type(x2, y2), col_type(x3, y3)}
#line 101 "C:\\Projects\\glm\\glm\\detail\\type_mat4x2.inl"
	{





#line 108 "C:\\Projects\\glm\\glm\\detail\\type_mat4x2.inl"
	}

	template<typename T>
	template<typename V0, typename V1, typename V2, typename V3>
	 inline constexpr mat<4, 2, T>::mat(vec<2, V0> const& v0, vec<2, V1> const& v1, vec<2, V2> const& v2, vec<2, V3> const& v3)

			: value{col_type(v0), col_type(v1), col_type(v2), col_type(v3)}
#line 116 "C:\\Projects\\glm\\glm\\detail\\type_mat4x2.inl"
	{





#line 123 "C:\\Projects\\glm\\glm\\detail\\type_mat4x2.inl"
	}

	

	template<typename T>
	 inline constexpr mat<4, 2, T>::mat(mat<2, 2, T> const& m)

			: value{col_type(m[0]), col_type(m[1]), col_type(0), col_type(0)}
#line 132 "C:\\Projects\\glm\\glm\\detail\\type_mat4x2.inl"
	{





#line 139 "C:\\Projects\\glm\\glm\\detail\\type_mat4x2.inl"
	}

	template<typename T>
	 inline constexpr mat<4, 2, T>::mat(mat<3, 3, T> const& m)

			: value{col_type(m[0]), col_type(m[1]), col_type(m[2]), col_type(0)}
#line 146 "C:\\Projects\\glm\\glm\\detail\\type_mat4x2.inl"
	{





#line 153 "C:\\Projects\\glm\\glm\\detail\\type_mat4x2.inl"
	}

	template<typename T>
	 inline constexpr mat<4, 2, T>::mat(mat<4, 4, T> const& m)

			: value{col_type(m[0]), col_type(m[1]), col_type(m[2]), col_type(m[3])}
#line 160 "C:\\Projects\\glm\\glm\\detail\\type_mat4x2.inl"
	{





#line 167 "C:\\Projects\\glm\\glm\\detail\\type_mat4x2.inl"
	}

	template<typename T>
	 inline constexpr mat<4, 2, T>::mat(mat<2, 3, T> const& m)

			: value{col_type(m[0]), col_type(m[1]), col_type(0), col_type(0)}
#line 174 "C:\\Projects\\glm\\glm\\detail\\type_mat4x2.inl"
	{





#line 181 "C:\\Projects\\glm\\glm\\detail\\type_mat4x2.inl"
	}

	template<typename T>
	 inline constexpr mat<4, 2, T>::mat(mat<3, 2, T> const& m)

			: value{col_type(m[0]), col_type(m[1]), col_type(m[2]), col_type(0)}
#line 188 "C:\\Projects\\glm\\glm\\detail\\type_mat4x2.inl"
	{





#line 195 "C:\\Projects\\glm\\glm\\detail\\type_mat4x2.inl"
	}

	template<typename T>
	 inline constexpr mat<4, 2, T>::mat(mat<2, 4, T> const& m)

			: value{col_type(m[0]), col_type(m[1]), col_type(0), col_type(0)}
#line 202 "C:\\Projects\\glm\\glm\\detail\\type_mat4x2.inl"
	{





#line 209 "C:\\Projects\\glm\\glm\\detail\\type_mat4x2.inl"
	}

	template<typename T>
	 inline constexpr mat<4, 2, T>::mat(mat<4, 3, T> const& m)

			: value{col_type(m[0]), col_type(m[1]), col_type(m[2]), col_type(m[3])}
#line 216 "C:\\Projects\\glm\\glm\\detail\\type_mat4x2.inl"
	{





#line 223 "C:\\Projects\\glm\\glm\\detail\\type_mat4x2.inl"
	}

	template<typename T>
	 inline constexpr mat<4, 2, T>::mat(mat<3, 4, T> const& m)

			: value{col_type(m[0]), col_type(m[1]), col_type(m[2]), col_type(0)}
#line 230 "C:\\Projects\\glm\\glm\\detail\\type_mat4x2.inl"
	{





#line 237 "C:\\Projects\\glm\\glm\\detail\\type_mat4x2.inl"
	}

	

	template<typename T>
	 inline typename mat<4, 2, T>::col_type & mat<4, 2, T>::operator[](typename mat<4, 2, T>::length_type i)
	{
		(void)( (!!(i < this->length())) || (_wassert(L"i < this->length()", L"C:\\Projects\\glm\\glm\\detail\\type_mat4x2.inl", (unsigned)(244)), 0) );
		return this->value[i];
	}

	template<typename T>
	 inline constexpr typename mat<4, 2, T>::col_type const& mat<4, 2, T>::operator[](typename mat<4, 2, T>::length_type i) const
	{
		(void)( (!!(i < this->length())) || (_wassert(L"i < this->length()", L"C:\\Projects\\glm\\glm\\detail\\type_mat4x2.inl", (unsigned)(251)), 0) );
		return this->value[i];
	}

	

	template<typename T>
	template<typename U>
	 inline mat<4, 2, T>& mat<4, 2, T>::operator=(mat<4, 2, U> const& m)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
		this->value[2] = m[2];
		this->value[3] = m[3];
		return *this;
	}

	template<typename T>
	template<typename U>
	 inline mat<4, 2, T> & mat<4, 2, T>::operator+=(U s)
	{
		this->value[0] += s;
		this->value[1] += s;
		this->value[2] += s;
		this->value[3] += s;
		return *this;
	}

	template<typename T>
	template<typename U>
	 inline mat<4, 2, T> & mat<4, 2, T>::operator+=(mat<4, 2, U> const& m)
	{
		this->value[0] += m[0];
		this->value[1] += m[1];
		this->value[2] += m[2];
		this->value[3] += m[3];
		return *this;
	}

	template<typename T>
	template<typename U>
	 inline mat<4, 2, T> & mat<4, 2, T>::operator-=(U s)
	{
		this->value[0] -= s;
		this->value[1] -= s;
		this->value[2] -= s;
		this->value[3] -= s;
		return *this;
	}

	template<typename T>
	template<typename U>
	 inline mat<4, 2, T> & mat<4, 2, T>::operator-=(mat<4, 2, U> const& m)
	{
		this->value[0] -= m[0];
		this->value[1] -= m[1];
		this->value[2] -= m[2];
		this->value[3] -= m[3];
		return *this;
	}

	template<typename T>
	template<typename U>
	 inline mat<4, 2, T> & mat<4, 2, T>::operator*=(U s)
	{
		this->value[0] *= s;
		this->value[1] *= s;
		this->value[2] *= s;
		this->value[3] *= s;
		return *this;
	}

	template<typename T>
	template<typename U>
	 inline mat<4, 2, T> & mat<4, 2, T>::operator/=(U s)
	{
		this->value[0] /= s;
		this->value[1] /= s;
		this->value[2] /= s;
		this->value[3] /= s;
		return *this;
	}

	

	template<typename T>
	 inline mat<4, 2, T> operator+(mat<4, 2, T> const& m)
	{
		return m;
	}

	template<typename T>
	 inline mat<4, 2, T> operator-(mat<4, 2, T> const& m)
	{
		return mat<4, 2, T>(
			-m[0],
			-m[1],
			-m[2],
			-m[3]);
	}

	

	template<typename T>
	 inline mat<4, 2, T> operator+(mat<4, 2, T> const& m, T scalar)
	{
		return mat<4, 2, T>(
			m[0] + scalar,
			m[1] + scalar,
			m[2] + scalar,
			m[3] + scalar);
	}

	template<typename T>
	 inline mat<4, 2, T> operator+(mat<4, 2, T> const& m1, mat<4, 2, T> const& m2)
	{
		return mat<4, 2, T>(
			m1[0] + m2[0],
			m1[1] + m2[1],
			m1[2] + m2[2],
			m1[3] + m2[3]);
	}

	template<typename T>
	 inline mat<4, 2, T> operator-(mat<4, 2, T> const& m, T scalar)
	{
		return mat<4, 2, T>(
			m[0] - scalar,
			m[1] - scalar,
			m[2] - scalar,
			m[3] - scalar);
	}

	template<typename T>
	 inline mat<4, 2, T> operator-(mat<4, 2, T> const& m1, mat<4, 2, T> const& m2)
	{
		return mat<4, 2, T>(
			m1[0] - m2[0],
			m1[1] - m2[1],
			m1[2] - m2[2],
			m1[3] - m2[3]);
	}

	template<typename T>
	 inline mat<4, 2, T> operator*(mat<4, 2, T> const& m, T scalar)
	{
		return mat<4, 2, T>(
			m[0] * scalar,
			m[1] * scalar,
			m[2] * scalar,
			m[3] * scalar);
	}

	template<typename T>
	 inline mat<4, 2, T> operator*(T scalar, mat<4, 2, T> const& m)
	{
		return mat<4, 2, T>(
			m[0] * scalar,
			m[1] * scalar,
			m[2] * scalar,
			m[3] * scalar);
	}

	template<typename T>
	 inline typename mat<4, 2, T>::col_type operator*(mat<4, 2, T> const& m, typename mat<4, 2, T>::row_type const& v)
	{
		return typename mat<4, 2, T>::col_type(
			m[0][0] * v.x + m[1][0] * v.y + m[2][0] * v.z + m[3][0] * v.w,
			m[0][1] * v.x + m[1][1] * v.y + m[2][1] * v.z + m[3][1] * v.w);
	}

	template<typename T>
	 inline typename mat<4, 2, T>::row_type operator*(typename mat<4, 2, T>::col_type const& v, mat<4, 2, T> const& m)
	{
		return typename mat<4, 2, T>::row_type(
			v.x * m[0][0] + v.y * m[0][1],
			v.x * m[1][0] + v.y * m[1][1],
			v.x * m[2][0] + v.y * m[2][1],
			v.x * m[3][0] + v.y * m[3][1]);
	}

	template<typename T>
	 inline mat<2, 2, T> operator*(mat<4, 2, T> const& m1, mat<2, 4, T> const& m2)
	{
		T const SrcA00 = m1[0][0];
		T const SrcA01 = m1[0][1];
		T const SrcA10 = m1[1][0];
		T const SrcA11 = m1[1][1];
		T const SrcA20 = m1[2][0];
		T const SrcA21 = m1[2][1];
		T const SrcA30 = m1[3][0];
		T const SrcA31 = m1[3][1];

		T const SrcB00 = m2[0][0];
		T const SrcB01 = m2[0][1];
		T const SrcB02 = m2[0][2];
		T const SrcB03 = m2[0][3];
		T const SrcB10 = m2[1][0];
		T const SrcB11 = m2[1][1];
		T const SrcB12 = m2[1][2];
		T const SrcB13 = m2[1][3];

		mat<2, 2, T> Result;
		Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01 + SrcA20 * SrcB02 + SrcA30 * SrcB03;
		Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01 + SrcA21 * SrcB02 + SrcA31 * SrcB03;
		Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11 + SrcA20 * SrcB12 + SrcA30 * SrcB13;
		Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11 + SrcA21 * SrcB12 + SrcA31 * SrcB13;
		return Result;
	}

	template<typename T>
	 inline mat<3, 2, T> operator*(mat<4, 2, T> const& m1, mat<3, 4, T> const& m2)
	{
		return mat<3, 2, T>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2] + m1[3][0] * m2[0][3],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2] + m1[3][1] * m2[0][3],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2] + m1[3][0] * m2[1][3],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2] + m1[3][1] * m2[1][3],
			m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2] + m1[3][0] * m2[2][3],
			m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2] + m1[3][1] * m2[2][3]);
	}

	template<typename T>
	 inline mat<4, 2, T> operator*(mat<4, 2, T> const& m1, mat<4, 4, T> const& m2)
	{
		return mat<4, 2, T>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2] + m1[3][0] * m2[0][3],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2] + m1[3][1] * m2[0][3],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2] + m1[3][0] * m2[1][3],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2] + m1[3][1] * m2[1][3],
			m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2] + m1[3][0] * m2[2][3],
			m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2] + m1[3][1] * m2[2][3],
			m1[0][0] * m2[3][0] + m1[1][0] * m2[3][1] + m1[2][0] * m2[3][2] + m1[3][0] * m2[3][3],
			m1[0][1] * m2[3][0] + m1[1][1] * m2[3][1] + m1[2][1] * m2[3][2] + m1[3][1] * m2[3][3]);
	}

	template<typename T>
	 inline mat<4, 2, T> operator/(mat<4, 2, T> const& m, T scalar)
	{
		return mat<4, 2, T>(
			m[0] / scalar,
			m[1] / scalar,
			m[2] / scalar,
			m[3] / scalar);
	}

	template<typename T>
	 inline mat<4, 2, T> operator/(T scalar, mat<4, 2, T> const& m)
	{
		return mat<4, 2, T>(
			scalar / m[0],
			scalar / m[1],
			scalar / m[2],
			scalar / m[3]);
	}

	

	template<typename T>
	 inline bool operator==(mat<4, 2, T> const& m1, mat<4, 2, T> const& m2)
	{
		return (m1[0] == m2[0]) && (m1[1] == m2[1]) && (m1[2] == m2[2]) && (m1[3] == m2[3]);
	}

	template<typename T>
	 inline bool operator!=(mat<4, 2, T> const& m1, mat<4, 2, T> const& m2)
	{
		return (m1[0] != m2[0]) || (m1[1] != m2[1]) || (m1[2] != m2[2]) || (m1[3] != m2[3]);
	}
} 
#line 160 "C:\\Projects\\glm\\glm\\ext\\../detail/type_mat4x2.hpp"
#line 161 "C:\\Projects\\glm\\glm\\ext\\../detail/type_mat4x2.hpp"
#line 6 "C:\\Projects\\glm\\glm\\./ext/matrix_double4x2.hpp"

namespace glm
{
	
	

	
	
	
	typedef mat<4, 2, double>		dmat4x2;

	
}
#line 6 "C:\\Projects\\glm\\glm\\mat4x2.hpp"
#line 1 "C:\\Projects\\glm\\glm\\./ext/matrix_float4x2.hpp"



#pragma once


namespace glm
{
	
	

	
	
	
	typedef mat<4, 2, float>			mat4x2;

	
}
#line 7 "C:\\Projects\\glm\\glm\\mat4x2.hpp"
#line 27 "C:\\Projects\\glm\\glm\\detail\\../matrix.hpp"
#line 1 "C:\\Projects\\glm\\glm\\mat4x3.hpp"



#pragma once
#line 1 "C:\\Projects\\glm\\glm\\./ext/matrix_double4x3.hpp"



#pragma once
#line 1 "C:\\Projects\\glm\\glm\\ext\\../detail/type_mat4x3.hpp"



#pragma once






namespace glm
{
	template<typename T>
	struct mat<4, 3, T>
	{
		typedef vec<3, T> col_type;
		typedef vec<4, T> row_type;
		typedef mat<4, 3, T> type;
		typedef mat<3, 4, T> transpose_type;
		typedef T value_type;

	private:
		col_type value[4];

	public:
		

		typedef length_t length_type;
		 static constexpr length_type length() { return 4; }

		 col_type & operator[](length_type i);
		 constexpr col_type const& operator[](length_type i) const;

		

		 constexpr mat() = default;
		 constexpr mat(mat<4, 3, T> const& m);

		 explicit constexpr mat(T const& x);
		 constexpr mat(
			T const& x0, T const& y0, T const& z0,
			T const& x1, T const& y1, T const& z1,
			T const& x2, T const& y2, T const& z2,
			T const& x3, T const& y3, T const& z3);
		 constexpr mat(
			col_type const& v0,
			col_type const& v1,
			col_type const& v2,
			col_type const& v3);

		

		template<
			typename X1, typename Y1, typename Z1,
			typename X2, typename Y2, typename Z2,
			typename X3, typename Y3, typename Z3,
			typename X4, typename Y4, typename Z4>
		 constexpr mat(
			X1 const& x1, Y1 const& y1, Z1 const& z1,
			X2 const& x2, Y2 const& y2, Z2 const& z2,
			X3 const& x3, Y3 const& y3, Z3 const& z3,
			X4 const& x4, Y4 const& y4, Z4 const& z4);

		template<typename V1, typename V2, typename V3, typename V4>
		 constexpr mat(
			vec<3, V1> const& v1,
			vec<3, V2> const& v2,
			vec<3, V3> const& v3,
			vec<3, V4> const& v4);

		
		  constexpr mat(mat<2, 2, T> const& x);
		  constexpr mat(mat<3, 3, T> const& x);
		  constexpr mat(mat<4, 4, T> const& x);
		  constexpr mat(mat<2, 3, T> const& x);
		  constexpr mat(mat<3, 2, T> const& x);
		  constexpr mat(mat<2, 4, T> const& x);
		  constexpr mat(mat<4, 2, T> const& x);
		  constexpr mat(mat<3, 4, T> const& x);

		

		template<typename U>
		 mat<4, 3, T> & operator=(mat<4, 3, U> const& m);
		template<typename U>
		 mat<4, 3, T> & operator+=(U s);
		template<typename U>
		 mat<4, 3, T> & operator+=(mat<4, 3, U> const& m);
		template<typename U>
		 mat<4, 3, T> & operator-=(U s);
		template<typename U>
		 mat<4, 3, T> & operator-=(mat<4, 3, U> const& m);
		template<typename U>
		 mat<4, 3, T> & operator*=(U s);
		template<typename U>
		 mat<4, 3, T> & operator/=(U s);
	};

	

	template<typename T>
	 mat<4, 3, T> operator+(mat<4, 3, T> const& m);

	template<typename T>
	 mat<4, 3, T> operator-(mat<4, 3, T> const& m);

	

	template<typename T>
	 mat<4, 3, T> operator+(mat<4, 3, T> const& m, T const& s);

	template<typename T>
	 mat<4, 3, T> operator+(mat<4, 3, T> const& m1, mat<4, 3, T> const& m2);

	template<typename T>
	 mat<4, 3, T> operator-(mat<4, 3, T> const& m, T const& s);

	template<typename T>
	 mat<4, 3, T> operator-(mat<4, 3, T> const& m1, mat<4, 3, T> const& m2);

	template<typename T>
	 mat<4, 3, T> operator*(mat<4, 3, T> const& m, T const& s);

	template<typename T>
	 mat<4, 3, T> operator*(T const& s, mat<4, 3, T> const& m);

	template<typename T>
	 typename mat<4, 3, T>::col_type operator*(mat<4, 3, T> const& m, typename mat<4, 3, T>::row_type const& v);

	template<typename T>
	 typename mat<4, 3, T>::row_type operator*(typename mat<4, 3, T>::col_type const& v, mat<4, 3, T> const& m);

	template<typename T>
	 mat<2, 3, T> operator*(mat<4, 3, T> const& m1, mat<2, 4, T> const& m2);

	template<typename T>
	 mat<3, 3, T> operator*(mat<4, 3, T> const& m1,	mat<3, 4, T> const& m2);

	template<typename T>
	 mat<4, 3, T> operator*(mat<4, 3, T> const& m1, mat<4, 4, T> const& m2);

	template<typename T>
	 mat<4, 3, T> operator/(mat<4, 3, T> const& m, T const& s);

	template<typename T>
	 mat<4, 3, T> operator/(T const& s, mat<4, 3, T> const& m);

	

	template<typename T>
	 bool operator==(mat<4, 3, T> const& m1, mat<4, 3, T> const& m2);

	template<typename T>
	 bool operator!=(mat<4, 3, T> const& m1, mat<4, 3, T> const& m2);
}


#line 1 "C:\\Projects\\glm\\glm\\detail\\type_mat4x3.inl"
namespace glm
{
	















#line 20 "C:\\Projects\\glm\\glm\\detail\\type_mat4x3.inl"

	template<typename T>
	 inline constexpr mat<4, 3, T>::mat(mat<4, 3, T> const& m)

			: value{col_type(m[0]), col_type(m[1]), col_type(m[2]), col_type(m[3])}
#line 26 "C:\\Projects\\glm\\glm\\detail\\type_mat4x3.inl"
	{





#line 33 "C:\\Projects\\glm\\glm\\detail\\type_mat4x3.inl"
	}

	template<typename T>
	 inline constexpr mat<4, 3, T>::mat(T const& s)

			: value{col_type(s, 0, 0), col_type(0, s, 0), col_type(0, 0, s), col_type(0, 0, 0)}
#line 40 "C:\\Projects\\glm\\glm\\detail\\type_mat4x3.inl"
	{





#line 47 "C:\\Projects\\glm\\glm\\detail\\type_mat4x3.inl"
	}

	template<typename T>
	 inline constexpr mat<4, 3, T>::mat
	(
		T const& x0, T const& y0, T const& z0,
		T const& x1, T const& y1, T const& z1,
		T const& x2, T const& y2, T const& z2,
		T const& x3, T const& y3, T const& z3
	)

			: value{col_type(x0, y0, z0), col_type(x1, y1, z1), col_type(x2, y2, z2), col_type(x3, y3, z3)}
#line 60 "C:\\Projects\\glm\\glm\\detail\\type_mat4x3.inl"
	{





#line 67 "C:\\Projects\\glm\\glm\\detail\\type_mat4x3.inl"
	}

	template<typename T>
	 inline constexpr mat<4, 3, T>::mat(col_type const& v0, col_type const& v1, col_type const& v2, col_type const& v3)

			: value{col_type(v0), col_type(v1), col_type(v2), col_type(v3)}
#line 74 "C:\\Projects\\glm\\glm\\detail\\type_mat4x3.inl"
	{





#line 81 "C:\\Projects\\glm\\glm\\detail\\type_mat4x3.inl"
	}

	

	template<typename T>
	template<
		typename X0, typename Y0, typename Z0,
		typename X1, typename Y1, typename Z1,
		typename X2, typename Y2, typename Z2,
		typename X3, typename Y3, typename Z3>
	 inline constexpr mat<4, 3, T>::mat
	(
		X0 const& x0, Y0 const& y0, Z0 const& z0,
		X1 const& x1, Y1 const& y1, Z1 const& z1,
		X2 const& x2, Y2 const& y2, Z2 const& z2,
		X3 const& x3, Y3 const& y3, Z3 const& z3
	)

			: value{col_type(x0, y0, z0), col_type(x1, y1, z1), col_type(x2, y2, z2), col_type(x3, y3, z3)}
#line 101 "C:\\Projects\\glm\\glm\\detail\\type_mat4x3.inl"
	{





#line 108 "C:\\Projects\\glm\\glm\\detail\\type_mat4x3.inl"
	}

	template<typename T>
	template<typename V1, typename V2, typename V3, typename V4>
	 inline constexpr mat<4, 3, T>::mat(vec<3, V1> const& v1, vec<3, V2> const& v2, vec<3, V3> const& v3, vec<3, V4> const& v4)

			: value{col_type(v1), col_type(v2), col_type(v3), col_type(v4)}
#line 116 "C:\\Projects\\glm\\glm\\detail\\type_mat4x3.inl"
	{





#line 123 "C:\\Projects\\glm\\glm\\detail\\type_mat4x3.inl"
	}

	

	template<typename T>
	 inline constexpr mat<4, 3, T>::mat(mat<2, 2, T> const& m)

			: value{col_type(m[0], 0), col_type(m[1], 0), col_type(0, 0, 1), col_type(0)}
#line 132 "C:\\Projects\\glm\\glm\\detail\\type_mat4x3.inl"
	{





#line 139 "C:\\Projects\\glm\\glm\\detail\\type_mat4x3.inl"
	}

	template<typename T>
	 inline constexpr mat<4, 3, T>::mat(mat<3, 3, T> const& m)

			: value{col_type(m[0]), col_type(m[1]), col_type(m[2]), col_type(0)}
#line 146 "C:\\Projects\\glm\\glm\\detail\\type_mat4x3.inl"
	{





#line 153 "C:\\Projects\\glm\\glm\\detail\\type_mat4x3.inl"
	}

	template<typename T>
	 inline constexpr mat<4, 3, T>::mat(mat<4, 4, T> const& m)

			: value{col_type(m[0]), col_type(m[1]), col_type(m[2]), col_type(m[3])}
#line 160 "C:\\Projects\\glm\\glm\\detail\\type_mat4x3.inl"
	{





#line 167 "C:\\Projects\\glm\\glm\\detail\\type_mat4x3.inl"
	}

	template<typename T>
	 inline constexpr mat<4, 3, T>::mat(mat<2, 3, T> const& m)

			: value{col_type(m[0]), col_type(m[1]), col_type(0, 0, 1), col_type(0)}
#line 174 "C:\\Projects\\glm\\glm\\detail\\type_mat4x3.inl"
	{





#line 181 "C:\\Projects\\glm\\glm\\detail\\type_mat4x3.inl"
	}

	template<typename T>
	 inline constexpr mat<4, 3, T>::mat(mat<3, 2, T> const& m)

			: value{col_type(m[0], 0), col_type(m[1], 0), col_type(m[2], 1), col_type(0)}
#line 188 "C:\\Projects\\glm\\glm\\detail\\type_mat4x3.inl"
	{





#line 195 "C:\\Projects\\glm\\glm\\detail\\type_mat4x3.inl"
	}

	template<typename T>
	 inline constexpr mat<4, 3, T>::mat(mat<2, 4, T> const& m)

			: value{col_type(m[0]), col_type(m[1]), col_type(0, 0, 1), col_type(0)}
#line 202 "C:\\Projects\\glm\\glm\\detail\\type_mat4x3.inl"
	{





#line 209 "C:\\Projects\\glm\\glm\\detail\\type_mat4x3.inl"
	}

	template<typename T>
	 inline constexpr mat<4, 3, T>::mat(mat<4, 2, T> const& m)

			: value{col_type(m[0], 0), col_type(m[1], 0), col_type(m[2], 1), col_type(m[3], 0)}
#line 216 "C:\\Projects\\glm\\glm\\detail\\type_mat4x3.inl"
	{





#line 223 "C:\\Projects\\glm\\glm\\detail\\type_mat4x3.inl"
	}

	template<typename T>
	 inline constexpr mat<4, 3, T>::mat(mat<3, 4, T> const& m)

			: value{col_type(m[0]), col_type(m[1]), col_type(m[2]), col_type(0)}
#line 230 "C:\\Projects\\glm\\glm\\detail\\type_mat4x3.inl"
	{





#line 237 "C:\\Projects\\glm\\glm\\detail\\type_mat4x3.inl"
	}

	

	template<typename T>
	 inline typename mat<4, 3, T>::col_type & mat<4, 3, T>::operator[](typename mat<4, 3, T>::length_type i)
	{
		(void)( (!!(i < this->length())) || (_wassert(L"i < this->length()", L"C:\\Projects\\glm\\glm\\detail\\type_mat4x3.inl", (unsigned)(244)), 0) );
		return this->value[i];
	}

	template<typename T>
	 inline constexpr typename mat<4, 3, T>::col_type const& mat<4, 3, T>::operator[](typename mat<4, 3, T>::length_type i) const
	{
		(void)( (!!(i < this->length())) || (_wassert(L"i < this->length()", L"C:\\Projects\\glm\\glm\\detail\\type_mat4x3.inl", (unsigned)(251)), 0) );
		return this->value[i];
	}

	

	template<typename T>
	template<typename U>
	 inline mat<4, 3, T>& mat<4, 3, T>::operator=(mat<4, 3, U> const& m)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
		this->value[2] = m[2];
		this->value[3] = m[3];
		return *this;
	}

	template<typename T>
	template<typename U>
	 inline mat<4, 3, T> & mat<4, 3, T>::operator+=(U s)
	{
		this->value[0] += s;
		this->value[1] += s;
		this->value[2] += s;
		this->value[3] += s;
		return *this;
	}

	template<typename T>
	template<typename U>
	 inline mat<4, 3, T> & mat<4, 3, T>::operator+=(mat<4, 3, U> const& m)
	{
		this->value[0] += m[0];
		this->value[1] += m[1];
		this->value[2] += m[2];
		this->value[3] += m[3];
		return *this;
	}

	template<typename T>
	template<typename U>
	 inline mat<4, 3, T> & mat<4, 3, T>::operator-=(U s)
	{
		this->value[0] -= s;
		this->value[1] -= s;
		this->value[2] -= s;
		this->value[3] -= s;
		return *this;
	}

	template<typename T>
	template<typename U>
	 inline mat<4, 3, T> & mat<4, 3, T>::operator-=(mat<4, 3, U> const& m)
	{
		this->value[0] -= m[0];
		this->value[1] -= m[1];
		this->value[2] -= m[2];
		this->value[3] -= m[3];
		return *this;
	}

	template<typename T>
	template<typename U>
	 inline mat<4, 3, T> & mat<4, 3, T>::operator*=(U s)
	{
		this->value[0] *= s;
		this->value[1] *= s;
		this->value[2] *= s;
		this->value[3] *= s;
		return *this;
	}

	template<typename T>
	template<typename U>
	 inline mat<4, 3, T> & mat<4, 3, T>::operator/=(U s)
	{
		this->value[0] /= s;
		this->value[1] /= s;
		this->value[2] /= s;
		this->value[3] /= s;
		return *this;
	}

	

	template<typename T>
	 inline mat<4, 3, T> operator+(mat<4, 3, T> const& m)
	{
		return m;
	}

	template<typename T>
	 inline mat<4, 3, T> operator-(mat<4, 3, T> const& m)
	{
		return mat<4, 3, T>(
			-m[0],
			-m[1],
			-m[2],
			-m[3]);
	}

	

	template<typename T>
	 inline mat<4, 3, T> operator+(mat<4, 3, T> const& m, T const& s)
	{
		return mat<4, 3, T>(
			m[0] + s,
			m[1] + s,
			m[2] + s,
			m[3] + s);
	}

	template<typename T>
	 inline mat<4, 3, T> operator+(mat<4, 3, T> const& m1, mat<4, 3, T> const& m2)
	{
		return mat<4, 3, T>(
			m1[0] + m2[0],
			m1[1] + m2[1],
			m1[2] + m2[2],
			m1[3] + m2[3]);
	}

	template<typename T>
	 inline mat<4, 3, T> operator-(mat<4, 3, T> const& m, T const& s)
	{
		return mat<4, 3, T>(
			m[0] - s,
			m[1] - s,
			m[2] - s,
			m[3] - s);
	}

	template<typename T>
	 inline mat<4, 3, T> operator-(mat<4, 3, T> const& m1, mat<4, 3, T> const& m2)
	{
		return mat<4, 3, T>(
			m1[0] - m2[0],
			m1[1] - m2[1],
			m1[2] - m2[2],
			m1[3] - m2[3]);
	}

	template<typename T>
	 inline mat<4, 3, T> operator*(mat<4, 3, T> const& m, T const& s)
	{
		return mat<4, 3, T>(
			m[0] * s,
			m[1] * s,
			m[2] * s,
			m[3] * s);
	}

	template<typename T>
	 inline mat<4, 3, T> operator*(T const& s, mat<4, 3, T> const& m)
	{
		return mat<4, 3, T>(
			m[0] * s,
			m[1] * s,
			m[2] * s,
			m[3] * s);
	}

	template<typename T>
	 inline typename mat<4, 3, T>::col_type operator*
	(
		mat<4, 3, T> const& m,
		typename mat<4, 3, T>::row_type const& v)
	{
		return typename mat<4, 3, T>::col_type(
			m[0][0] * v.x + m[1][0] * v.y + m[2][0] * v.z + m[3][0] * v.w,
			m[0][1] * v.x + m[1][1] * v.y + m[2][1] * v.z + m[3][1] * v.w,
			m[0][2] * v.x + m[1][2] * v.y + m[2][2] * v.z + m[3][2] * v.w);
	}

	template<typename T>
	 inline typename mat<4, 3, T>::row_type operator*
	(
		typename mat<4, 3, T>::col_type const& v,
		mat<4, 3, T> const& m)
	{
		return typename mat<4, 3, T>::row_type(
			v.x * m[0][0] + v.y * m[0][1] + v.z * m[0][2],
			v.x * m[1][0] + v.y * m[1][1] + v.z * m[1][2],
			v.x * m[2][0] + v.y * m[2][1] + v.z * m[2][2],
			v.x * m[3][0] + v.y * m[3][1] + v.z * m[3][2]);
	}

	template<typename T>
	 inline mat<2, 3, T> operator*(mat<4, 3, T> const& m1, mat<2, 4, T> const& m2)
	{
		return mat<2, 3, T>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2] + m1[3][0] * m2[0][3],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2] + m1[3][1] * m2[0][3],
			m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2] + m1[3][2] * m2[0][3],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2] + m1[3][0] * m2[1][3],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2] + m1[3][1] * m2[1][3],
			m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2] + m1[3][2] * m2[1][3]);
	}

	template<typename T>
	 inline mat<3, 3, T> operator*(mat<4, 3, T> const& m1, mat<3, 4, T> const& m2)
	{
		T const SrcA00 = m1[0][0];
		T const SrcA01 = m1[0][1];
		T const SrcA02 = m1[0][2];
		T const SrcA10 = m1[1][0];
		T const SrcA11 = m1[1][1];
		T const SrcA12 = m1[1][2];
		T const SrcA20 = m1[2][0];
		T const SrcA21 = m1[2][1];
		T const SrcA22 = m1[2][2];
		T const SrcA30 = m1[3][0];
		T const SrcA31 = m1[3][1];
		T const SrcA32 = m1[3][2];

		T const SrcB00 = m2[0][0];
		T const SrcB01 = m2[0][1];
		T const SrcB02 = m2[0][2];
		T const SrcB03 = m2[0][3];
		T const SrcB10 = m2[1][0];
		T const SrcB11 = m2[1][1];
		T const SrcB12 = m2[1][2];
		T const SrcB13 = m2[1][3];
		T const SrcB20 = m2[2][0];
		T const SrcB21 = m2[2][1];
		T const SrcB22 = m2[2][2];
		T const SrcB23 = m2[2][3];

		mat<3, 3, T> Result;
		Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01 + SrcA20 * SrcB02 + SrcA30 * SrcB03;
		Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01 + SrcA21 * SrcB02 + SrcA31 * SrcB03;
		Result[0][2] = SrcA02 * SrcB00 + SrcA12 * SrcB01 + SrcA22 * SrcB02 + SrcA32 * SrcB03;
		Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11 + SrcA20 * SrcB12 + SrcA30 * SrcB13;
		Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11 + SrcA21 * SrcB12 + SrcA31 * SrcB13;
		Result[1][2] = SrcA02 * SrcB10 + SrcA12 * SrcB11 + SrcA22 * SrcB12 + SrcA32 * SrcB13;
		Result[2][0] = SrcA00 * SrcB20 + SrcA10 * SrcB21 + SrcA20 * SrcB22 + SrcA30 * SrcB23;
		Result[2][1] = SrcA01 * SrcB20 + SrcA11 * SrcB21 + SrcA21 * SrcB22 + SrcA31 * SrcB23;
		Result[2][2] = SrcA02 * SrcB20 + SrcA12 * SrcB21 + SrcA22 * SrcB22 + SrcA32 * SrcB23;
		return Result;
	}

	template<typename T>
	 inline mat<4, 3, T> operator*(mat<4, 3, T> const& m1, mat<4, 4, T> const& m2)
	{
		return mat<4, 3, T>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2] + m1[3][0] * m2[0][3],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2] + m1[3][1] * m2[0][3],
			m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2] + m1[3][2] * m2[0][3],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2] + m1[3][0] * m2[1][3],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2] + m1[3][1] * m2[1][3],
			m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2] + m1[3][2] * m2[1][3],
			m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2] + m1[3][0] * m2[2][3],
			m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2] + m1[3][1] * m2[2][3],
			m1[0][2] * m2[2][0] + m1[1][2] * m2[2][1] + m1[2][2] * m2[2][2] + m1[3][2] * m2[2][3],
			m1[0][0] * m2[3][0] + m1[1][0] * m2[3][1] + m1[2][0] * m2[3][2] + m1[3][0] * m2[3][3],
			m1[0][1] * m2[3][0] + m1[1][1] * m2[3][1] + m1[2][1] * m2[3][2] + m1[3][1] * m2[3][3],
			m1[0][2] * m2[3][0] + m1[1][2] * m2[3][1] + m1[2][2] * m2[3][2] + m1[3][2] * m2[3][3]);
	}

	template<typename T>
	 inline mat<4, 3, T> operator/(mat<4, 3, T> const& m, T const& s)
	{
		return mat<4, 3, T>(
			m[0] / s,
			m[1] / s,
			m[2] / s,
			m[3] / s);
	}

	template<typename T>
	 inline mat<4, 3, T> operator/(T const& s, mat<4, 3, T> const& m)
	{
		return mat<4, 3, T>(
			s / m[0],
			s / m[1],
			s / m[2],
			s / m[3]);
	}

	

	template<typename T>
	 inline bool operator==(mat<4, 3, T> const& m1, mat<4, 3, T> const& m2)
	{
		return (m1[0] == m2[0]) && (m1[1] == m2[1]) && (m1[2] == m2[2]) && (m1[3] == m2[3]);
	}

	template<typename T>
	 inline bool operator!=(mat<4, 3, T> const& m1, mat<4, 3, T> const& m2)
	{
		return (m1[0] != m2[0]) || (m1[1] != m2[1]) || (m1[2] != m2[2]) || (m1[3] != m2[3]);
	}
} 
#line 159 "C:\\Projects\\glm\\glm\\ext\\../detail/type_mat4x3.hpp"
#line 160 "C:\\Projects\\glm\\glm\\ext\\../detail/type_mat4x3.hpp"
#line 6 "C:\\Projects\\glm\\glm\\./ext/matrix_double4x3.hpp"

namespace glm
{
	
	

	
	
	
	typedef mat<4, 3, double>		dmat4x3;

	
}
#line 6 "C:\\Projects\\glm\\glm\\mat4x3.hpp"
#line 1 "C:\\Projects\\glm\\glm\\./ext/matrix_float4x3.hpp"



#pragma once


namespace glm
{
	
	

	
	
	
	typedef mat<4, 3, float>			mat4x3;

	
}
#line 7 "C:\\Projects\\glm\\glm\\mat4x3.hpp"
#line 28 "C:\\Projects\\glm\\glm\\detail\\../matrix.hpp"
#line 1 "C:\\Projects\\glm\\glm\\mat4x4.hpp"



#pragma once
#line 1 "C:\\Projects\\glm\\glm\\./ext/matrix_double4x4.hpp"



#pragma once
#line 1 "C:\\Projects\\glm\\glm\\ext\\../detail/type_mat4x4.hpp"



#pragma once





namespace glm
{
	template<typename T>
	struct mat<4, 4, T>
	{
		typedef vec<4, T> col_type;
		typedef vec<4, T> row_type;
		typedef mat<4, 4, T> type;
		typedef mat<4, 4, T> transpose_type;
		typedef T value_type;

	private:
		col_type value[4];

	public:
		

		typedef length_t length_type;
		 static constexpr length_type length(){return 4;}

		 col_type & operator[](length_type i);
		 constexpr col_type const& operator[](length_type i) const;

		

		 constexpr mat() = default;
		 constexpr mat(mat<4, 4, T> const& m);

		 explicit constexpr mat(T const& x);
		 constexpr mat(
			T const& x0, T const& y0, T const& z0, T const& w0,
			T const& x1, T const& y1, T const& z1, T const& w1,
			T const& x2, T const& y2, T const& z2, T const& w2,
			T const& x3, T const& y3, T const& z3, T const& w3);
		 constexpr mat(
			col_type const& v0,
			col_type const& v1,
			col_type const& v2,
			col_type const& v3);

		

		template<
			typename X1, typename Y1, typename Z1, typename W1,
			typename X2, typename Y2, typename Z2, typename W2,
			typename X3, typename Y3, typename Z3, typename W3,
			typename X4, typename Y4, typename Z4, typename W4>
		 constexpr mat(
			X1 const& x1, Y1 const& y1, Z1 const& z1, W1 const& w1,
			X2 const& x2, Y2 const& y2, Z2 const& z2, W2 const& w2,
			X3 const& x3, Y3 const& y3, Z3 const& z3, W3 const& w3,
			X4 const& x4, Y4 const& y4, Z4 const& z4, W4 const& w4);

		template<typename V1, typename V2, typename V3, typename V4>
		 constexpr mat(
			vec<4, V1> const& v1,
			vec<4, V2> const& v2,
			vec<4, V3> const& v3,
			vec<4, V4> const& v4);

		

		  constexpr mat(mat<2, 2, T> const& x);
		  constexpr mat(mat<3, 3, T> const& x);
		  constexpr mat(mat<2, 3, T> const& x);
		  constexpr mat(mat<3, 2, T> const& x);
		  constexpr mat(mat<2, 4, T> const& x);
		  constexpr mat(mat<4, 2, T> const& x);
		  constexpr mat(mat<3, 4, T> const& x);
		  constexpr mat(mat<4, 3, T> const& x);

		

		template<typename U>
		 mat<4, 4, T> & operator=(mat<4, 4, U> const& m);
		template<typename U>
		 mat<4, 4, T> & operator+=(U s);
		template<typename U>
		 mat<4, 4, T> & operator+=(mat<4, 4, U> const& m);
		template<typename U>
		 mat<4, 4, T> & operator-=(U s);
		template<typename U>
		 mat<4, 4, T> & operator-=(mat<4, 4, U> const& m);
		template<typename U>
		 mat<4, 4, T> & operator*=(U s);
		template<typename U>
		 mat<4, 4, T> & operator*=(mat<4, 4, U> const& m);
		template<typename U>
		 mat<4, 4, T> & operator/=(U s);
		template<typename U>
		 mat<4, 4, T> & operator/=(mat<4, 4, U> const& m);
	};

	

	template<typename T>
	 mat<4, 4, T> operator+(mat<4, 4, T> const& m);

	template<typename T>
	 mat<4, 4, T> operator-(mat<4, 4, T> const& m);

	

	template<typename T>
	 mat<4, 4, T> operator+(mat<4, 4, T> const& m, T const& s);

	template<typename T>
	 mat<4, 4, T> operator+(T const& s, mat<4, 4, T> const& m);

	template<typename T>
	 mat<4, 4, T> operator+(mat<4, 4, T> const& m1, mat<4, 4, T> const& m2);

	template<typename T>
	 mat<4, 4, T> operator-(mat<4, 4, T> const& m, T const& s);

	template<typename T>
	 mat<4, 4, T> operator-(T const& s, mat<4, 4, T> const& m);

	template<typename T>
	 mat<4, 4, T> operator-(mat<4, 4, T> const& m1,	mat<4, 4, T> const& m2);

	template<typename T>
	 mat<4, 4, T> operator*(mat<4, 4, T> const& m, T const& s);

	template<typename T>
	 mat<4, 4, T> operator*(T const& s, mat<4, 4, T> const& m);

	template<typename T>
	 typename mat<4, 4, T>::col_type operator*(mat<4, 4, T> const& m, typename mat<4, 4, T>::row_type const& v);

	template<typename T>
	 typename mat<4, 4, T>::row_type operator*(typename mat<4, 4, T>::col_type const& v, mat<4, 4, T> const& m);

	template<typename T>
	 mat<2, 4, T> operator*(mat<4, 4, T> const& m1, mat<2, 4, T> const& m2);

	template<typename T>
	 mat<3, 4, T> operator*(mat<4, 4, T> const& m1, mat<3, 4, T> const& m2);

	template<typename T>
	 mat<4, 4, T> operator*(mat<4, 4, T> const& m1, mat<4, 4, T> const& m2);

	template<typename T>
	 mat<4, 4, T> operator/(mat<4, 4, T> const& m, T const& s);

	template<typename T>
	 mat<4, 4, T> operator/(T const& s, mat<4, 4, T> const& m);

	template<typename T>
	 typename mat<4, 4, T>::col_type operator/(mat<4, 4, T> const& m, typename mat<4, 4, T>::row_type const& v);

	template<typename T>
	 typename mat<4, 4, T>::row_type operator/(typename mat<4, 4, T>::col_type const& v, mat<4, 4, T> const& m);

	template<typename T>
	 mat<4, 4, T> operator/(mat<4, 4, T> const& m1,	mat<4, 4, T> const& m2);

	

	template<typename T>
	 bool operator==(mat<4, 4, T> const& m1, mat<4, 4, T> const& m2);

	template<typename T>
	 bool operator!=(mat<4, 4, T> const& m1, mat<4, 4, T> const& m2);
}


#line 1 "C:\\Projects\\glm\\glm\\detail\\type_mat4x4.inl"


namespace glm
{
	















#line 22 "C:\\Projects\\glm\\glm\\detail\\type_mat4x4.inl"

	template<typename T>
	 inline constexpr mat<4, 4, T>::mat(mat<4, 4, T> const& m)

			: value{col_type(m[0]), col_type(m[1]), col_type(m[2]), col_type(m[3])}
#line 28 "C:\\Projects\\glm\\glm\\detail\\type_mat4x4.inl"
	{





#line 35 "C:\\Projects\\glm\\glm\\detail\\type_mat4x4.inl"
	}

	template<typename T>
	 inline constexpr mat<4, 4, T>::mat(T const& s)

			: value{col_type(s, 0, 0, 0), col_type(0, s, 0, 0), col_type(0, 0, s, 0), col_type(0, 0, 0, s)}
#line 42 "C:\\Projects\\glm\\glm\\detail\\type_mat4x4.inl"
	{





#line 49 "C:\\Projects\\glm\\glm\\detail\\type_mat4x4.inl"
	}

	template<typename T>
	 inline constexpr mat<4, 4, T>::mat
	(
		T const& x0, T const& y0, T const& z0, T const& w0,
		T const& x1, T const& y1, T const& z1, T const& w1,
		T const& x2, T const& y2, T const& z2, T const& w2,
		T const& x3, T const& y3, T const& z3, T const& w3
	)

			: value{
				col_type(x0, y0, z0, w0),
				col_type(x1, y1, z1, w1),
				col_type(x2, y2, z2, w2),
				col_type(x3, y3, z3, w3)}
#line 66 "C:\\Projects\\glm\\glm\\detail\\type_mat4x4.inl"
	{





#line 73 "C:\\Projects\\glm\\glm\\detail\\type_mat4x4.inl"
	}

	template<typename T>
	 inline constexpr mat<4, 4, T>::mat(col_type const& v0, col_type const& v1, col_type const& v2, col_type const& v3)

			: value{col_type(v0), col_type(v1), col_type(v2), col_type(v3)}
#line 80 "C:\\Projects\\glm\\glm\\detail\\type_mat4x4.inl"
	{





#line 87 "C:\\Projects\\glm\\glm\\detail\\type_mat4x4.inl"
	}

	

	template<typename T>
	template<
		typename X1, typename Y1, typename Z1, typename W1,
		typename X2, typename Y2, typename Z2, typename W2,
		typename X3, typename Y3, typename Z3, typename W3,
		typename X4, typename Y4, typename Z4, typename W4>
	 inline constexpr mat<4, 4, T>::mat
	(
		X1 const& x1, Y1 const& y1, Z1 const& z1, W1 const& w1,
		X2 const& x2, Y2 const& y2, Z2 const& z2, W2 const& w2,
		X3 const& x3, Y3 const& y3, Z3 const& z3, W3 const& w3,
		X4 const& x4, Y4 const& y4, Z4 const& z4, W4 const& w4
	)

			: value{col_type(x1, y1, z1, w1), col_type(x2, y2, z2, w2), col_type(x3, y3, z3, w3), col_type(x4, y4, z4, w4)}
#line 107 "C:\\Projects\\glm\\glm\\detail\\type_mat4x4.inl"
	{
		static_assert(std::numeric_limits<X1>::is_iec559 || std::numeric_limits<X1>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 1st parameter type invalid.");
		static_assert(std::numeric_limits<Y1>::is_iec559 || std::numeric_limits<Y1>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 2nd parameter type invalid.");
		static_assert(std::numeric_limits<Z1>::is_iec559 || std::numeric_limits<Z1>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 3rd parameter type invalid.");
		static_assert(std::numeric_limits<W1>::is_iec559 || std::numeric_limits<W1>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 4th parameter type invalid.");

		static_assert(std::numeric_limits<X2>::is_iec559 || std::numeric_limits<X2>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 5th parameter type invalid.");
		static_assert(std::numeric_limits<Y2>::is_iec559 || std::numeric_limits<Y2>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 6th parameter type invalid.");
		static_assert(std::numeric_limits<Z2>::is_iec559 || std::numeric_limits<Z2>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 7th parameter type invalid.");
		static_assert(std::numeric_limits<W2>::is_iec559 || std::numeric_limits<W2>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 8th parameter type invalid.");

		static_assert(std::numeric_limits<X3>::is_iec559 || std::numeric_limits<X3>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 9th parameter type invalid.");
		static_assert(std::numeric_limits<Y3>::is_iec559 || std::numeric_limits<Y3>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 10th parameter type invalid.");
		static_assert(std::numeric_limits<Z3>::is_iec559 || std::numeric_limits<Z3>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 11th parameter type invalid.");
		static_assert(std::numeric_limits<W3>::is_iec559 || std::numeric_limits<W3>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 12th parameter type invalid.");

		static_assert(std::numeric_limits<X4>::is_iec559 || std::numeric_limits<X4>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 13th parameter type invalid.");
		static_assert(std::numeric_limits<Y4>::is_iec559 || std::numeric_limits<Y4>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 14th parameter type invalid.");
		static_assert(std::numeric_limits<Z4>::is_iec559 || std::numeric_limits<Z4>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 15th parameter type invalid.");
		static_assert(std::numeric_limits<W4>::is_iec559 || std::numeric_limits<W4>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 16th parameter type invalid.");






#line 134 "C:\\Projects\\glm\\glm\\detail\\type_mat4x4.inl"
	}

	template<typename T>
	template<typename V1, typename V2, typename V3, typename V4>
	 inline constexpr mat<4, 4, T>::mat(vec<4, V1> const& v1, vec<4, V2> const& v2, vec<4, V3> const& v3, vec<4, V4> const& v4)

			: value{col_type(v1), col_type(v2), col_type(v3), col_type(v4)}
#line 142 "C:\\Projects\\glm\\glm\\detail\\type_mat4x4.inl"
	{
		static_assert(std::numeric_limits<V1>::is_iec559 || std::numeric_limits<V1>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 1st parameter type invalid.");
		static_assert(std::numeric_limits<V2>::is_iec559 || std::numeric_limits<V2>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 2nd parameter type invalid.");
		static_assert(std::numeric_limits<V3>::is_iec559 || std::numeric_limits<V3>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 3rd parameter type invalid.");
		static_assert(std::numeric_limits<V4>::is_iec559 || std::numeric_limits<V4>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 4th parameter type invalid.");






#line 154 "C:\\Projects\\glm\\glm\\detail\\type_mat4x4.inl"
	}

	

	template<typename T>
	 inline constexpr mat<4, 4, T>::mat(mat<2, 2, T> const& m)

			: value{col_type(m[0], 0, 0), col_type(m[1], 0, 0), col_type(0, 0, 1, 0), col_type(0, 0, 0, 1)}
#line 163 "C:\\Projects\\glm\\glm\\detail\\type_mat4x4.inl"
	{





#line 170 "C:\\Projects\\glm\\glm\\detail\\type_mat4x4.inl"
	}

	template<typename T>
	 inline constexpr mat<4, 4, T>::mat(mat<3, 3, T> const& m)

			: value{col_type(m[0], 0), col_type(m[1], 0), col_type(m[2], 0), col_type(0, 0, 0, 1)}
#line 177 "C:\\Projects\\glm\\glm\\detail\\type_mat4x4.inl"
	{





#line 184 "C:\\Projects\\glm\\glm\\detail\\type_mat4x4.inl"
	}

	template<typename T>
	 inline constexpr mat<4, 4, T>::mat(mat<2, 3, T> const& m)

			: value{col_type(m[0], 0), col_type(m[1], 0), col_type(0, 0, 1, 0), col_type(0, 0, 0, 1)}
#line 191 "C:\\Projects\\glm\\glm\\detail\\type_mat4x4.inl"
	{





#line 198 "C:\\Projects\\glm\\glm\\detail\\type_mat4x4.inl"
	}

	template<typename T>
	 inline constexpr mat<4, 4, T>::mat(mat<3, 2, T> const& m)

			: value{col_type(m[0], 0, 0), col_type(m[1], 0, 0), col_type(m[2], 1, 0), col_type(0, 0, 0, 1)}
#line 205 "C:\\Projects\\glm\\glm\\detail\\type_mat4x4.inl"
	{





#line 212 "C:\\Projects\\glm\\glm\\detail\\type_mat4x4.inl"
	}

	template<typename T>
	 inline constexpr mat<4, 4, T>::mat(mat<2, 4, T> const& m)

			: value{col_type(m[0]), col_type(m[1]), col_type(0, 0, 1, 0), col_type(0, 0, 0, 1)}
#line 219 "C:\\Projects\\glm\\glm\\detail\\type_mat4x4.inl"
	{





#line 226 "C:\\Projects\\glm\\glm\\detail\\type_mat4x4.inl"
	}

	template<typename T>
	 inline constexpr mat<4, 4, T>::mat(mat<4, 2, T> const& m)

			: value{col_type(m[0], 0, 0), col_type(m[1], 0, 0), col_type(0, 0, 1, 0), col_type(0, 0, 0, 1)}
#line 233 "C:\\Projects\\glm\\glm\\detail\\type_mat4x4.inl"
	{





#line 240 "C:\\Projects\\glm\\glm\\detail\\type_mat4x4.inl"
	}

	template<typename T>
	 inline constexpr mat<4, 4, T>::mat(mat<3, 4, T> const& m)

			: value{col_type(m[0]), col_type(m[1]), col_type(m[2]), col_type(0, 0, 0, 1)}
#line 247 "C:\\Projects\\glm\\glm\\detail\\type_mat4x4.inl"
	{





#line 254 "C:\\Projects\\glm\\glm\\detail\\type_mat4x4.inl"
	}

	template<typename T>
	 inline constexpr mat<4, 4, T>::mat(mat<4, 3, T> const& m)

			: value{col_type(m[0], 0), col_type(m[1], 0), col_type(m[2], 0), col_type(m[3], 1)}
#line 261 "C:\\Projects\\glm\\glm\\detail\\type_mat4x4.inl"
	{





#line 268 "C:\\Projects\\glm\\glm\\detail\\type_mat4x4.inl"
	}

	

	template<typename T>
	 inline typename mat<4, 4, T>::col_type & mat<4, 4, T>::operator[](typename mat<4, 4, T>::length_type i)
	{
		(void)( (!!(i < this->length())) || (_wassert(L"i < this->length()", L"C:\\Projects\\glm\\glm\\detail\\type_mat4x4.inl", (unsigned)(275)), 0) );
		return this->value[i];
	}

	template<typename T>
	 inline constexpr typename mat<4, 4, T>::col_type const& mat<4, 4, T>::operator[](typename mat<4, 4, T>::length_type i) const
	{
		(void)( (!!(i < this->length())) || (_wassert(L"i < this->length()", L"C:\\Projects\\glm\\glm\\detail\\type_mat4x4.inl", (unsigned)(282)), 0) );
		return this->value[i];
	}

	

	template<typename T>
	template<typename U>
	 inline mat<4, 4, T>& mat<4, 4, T>::operator=(mat<4, 4, U> const& m)
	{
		
		
		this->value[0] = m[0];
		this->value[1] = m[1];
		this->value[2] = m[2];
		this->value[3] = m[3];
		return *this;
	}

	template<typename T>
	template<typename U>
	 inline mat<4, 4, T>& mat<4, 4, T>::operator+=(U s)
	{
		this->value[0] += s;
		this->value[1] += s;
		this->value[2] += s;
		this->value[3] += s;
		return *this;
	}

	template<typename T>
	template<typename U>
	 inline mat<4, 4, T>& mat<4, 4, T>::operator+=(mat<4, 4, U> const& m)
	{
		this->value[0] += m[0];
		this->value[1] += m[1];
		this->value[2] += m[2];
		this->value[3] += m[3];
		return *this;
	}

	template<typename T>
	template<typename U>
	 inline mat<4, 4, T> & mat<4, 4, T>::operator-=(U s)
	{
		this->value[0] -= s;
		this->value[1] -= s;
		this->value[2] -= s;
		this->value[3] -= s;
		return *this;
	}

	template<typename T>
	template<typename U>
	 inline mat<4, 4, T> & mat<4, 4, T>::operator-=(mat<4, 4, U> const& m)
	{
		this->value[0] -= m[0];
		this->value[1] -= m[1];
		this->value[2] -= m[2];
		this->value[3] -= m[3];
		return *this;
	}

	template<typename T>
	template<typename U>
	 inline mat<4, 4, T> & mat<4, 4, T>::operator*=(U s)
	{
		this->value[0] *= s;
		this->value[1] *= s;
		this->value[2] *= s;
		this->value[3] *= s;
		return *this;
	}

	template<typename T>
	template<typename U>
	 inline mat<4, 4, T> & mat<4, 4, T>::operator*=(mat<4, 4, U> const& m)
	{
		return (*this = *this * m);
	}

	template<typename T>
	template<typename U>
	 inline mat<4, 4, T> & mat<4, 4, T>::operator/=(U s)
	{
		this->value[0] /= s;
		this->value[1] /= s;
		this->value[2] /= s;
		this->value[3] /= s;
		return *this;
	}

	template<typename T>
	template<typename U>
	 inline mat<4, 4, T> & mat<4, 4, T>::operator/=(mat<4, 4, U> const& m)
	{
		return *this *= inverse(m);
	}

	

	template<typename T>
	 inline mat<4, 4, T> operator+(mat<4, 4, T> const& m)
	{
		return m;
	}

	template<typename T>
	 inline mat<4, 4, T> operator-(mat<4, 4, T> const& m)
	{
		return mat<4, 4, T>(
			-m[0],
			-m[1],
			-m[2],
			-m[3]);
	}

	

	template<typename T>
	 inline mat<4, 4, T> operator+(mat<4, 4, T> const& m, T const& s)
	{
		return mat<4, 4, T>(
			m[0] + s,
			m[1] + s,
			m[2] + s,
			m[3] + s);
	}

	template<typename T>
	 inline mat<4, 4, T> operator+(T const& s, mat<4, 4, T> const& m)
	{
		return mat<4, 4, T>(
			m[0] + s,
			m[1] + s,
			m[2] + s,
			m[3] + s);
	}

	template<typename T>
	 inline mat<4, 4, T> operator+(mat<4, 4, T> const& m1, mat<4, 4, T> const& m2)
	{
		return mat<4, 4, T>(
			m1[0] + m2[0],
			m1[1] + m2[1],
			m1[2] + m2[2],
			m1[3] + m2[3]);
	}

	template<typename T>
	 inline mat<4, 4, T> operator-(mat<4, 4, T> const& m, T const& s)
	{
		return mat<4, 4, T>(
			m[0] - s,
			m[1] - s,
			m[2] - s,
			m[3] - s);
	}

	template<typename T>
	 inline mat<4, 4, T> operator-(T const& s, mat<4, 4, T> const& m)
	{
		return mat<4, 4, T>(
			s - m[0],
			s - m[1],
			s - m[2],
			s - m[3]);
	}

	template<typename T>
	 inline mat<4, 4, T> operator-(mat<4, 4, T> const& m1, mat<4, 4, T> const& m2)
	{
		return mat<4, 4, T>(
			m1[0] - m2[0],
			m1[1] - m2[1],
			m1[2] - m2[2],
			m1[3] - m2[3]);
	}

	template<typename T>
	 inline mat<4, 4, T> operator*(mat<4, 4, T> const& m, T const  & s)
	{
		return mat<4, 4, T>(
			m[0] * s,
			m[1] * s,
			m[2] * s,
			m[3] * s);
	}

	template<typename T>
	 inline mat<4, 4, T> operator*(T const& s, mat<4, 4, T> const& m)
	{
		return mat<4, 4, T>(
			m[0] * s,
			m[1] * s,
			m[2] * s,
			m[3] * s);
	}

	template<typename T>
	 inline typename mat<4, 4, T>::col_type operator*
	(
		mat<4, 4, T> const& m,
		typename mat<4, 4, T>::row_type const& v
	)
	{



















		typename mat<4, 4, T>::col_type const Mov0(v[0]);
		typename mat<4, 4, T>::col_type const Mov1(v[1]);
		typename mat<4, 4, T>::col_type const Mul0 = m[0] * Mov0;
		typename mat<4, 4, T>::col_type const Mul1 = m[1] * Mov1;
		typename mat<4, 4, T>::col_type const Add0 = Mul0 + Mul1;
		typename mat<4, 4, T>::col_type const Mov2(v[2]);
		typename mat<4, 4, T>::col_type const Mov3(v[3]);
		typename mat<4, 4, T>::col_type const Mul2 = m[2] * Mov2;
		typename mat<4, 4, T>::col_type const Mul3 = m[3] * Mov3;
		typename mat<4, 4, T>::col_type const Add1 = Mul2 + Mul3;
		typename mat<4, 4, T>::col_type const Add2 = Add0 + Add1;
		return Add2;








	}

	template<typename T>
	 inline typename mat<4, 4, T>::row_type operator*
	(
		typename mat<4, 4, T>::col_type const& v,
		mat<4, 4, T> const& m
	)
	{
		return typename mat<4, 4, T>::row_type(
			m[0][0] * v[0] + m[0][1] * v[1] + m[0][2] * v[2] + m[0][3] * v[3],
			m[1][0] * v[0] + m[1][1] * v[1] + m[1][2] * v[2] + m[1][3] * v[3],
			m[2][0] * v[0] + m[2][1] * v[1] + m[2][2] * v[2] + m[2][3] * v[3],
			m[3][0] * v[0] + m[3][1] * v[1] + m[3][2] * v[2] + m[3][3] * v[3]);
	}

	template<typename T>
	 inline mat<2, 4, T> operator*(mat<4, 4, T> const& m1, mat<2, 4, T> const& m2)
	{
		return mat<2, 4, T>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2] + m1[3][0] * m2[0][3],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2] + m1[3][1] * m2[0][3],
			m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2] + m1[3][2] * m2[0][3],
			m1[0][3] * m2[0][0] + m1[1][3] * m2[0][1] + m1[2][3] * m2[0][2] + m1[3][3] * m2[0][3],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2] + m1[3][0] * m2[1][3],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2] + m1[3][1] * m2[1][3],
			m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2] + m1[3][2] * m2[1][3],
			m1[0][3] * m2[1][0] + m1[1][3] * m2[1][1] + m1[2][3] * m2[1][2] + m1[3][3] * m2[1][3]);
	}

	template<typename T>
	 inline mat<3, 4, T> operator*(mat<4, 4, T> const& m1, mat<3, 4, T> const& m2)
	{
		return mat<3, 4, T>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2] + m1[3][0] * m2[0][3],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2] + m1[3][1] * m2[0][3],
			m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2] + m1[3][2] * m2[0][3],
			m1[0][3] * m2[0][0] + m1[1][3] * m2[0][1] + m1[2][3] * m2[0][2] + m1[3][3] * m2[0][3],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2] + m1[3][0] * m2[1][3],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2] + m1[3][1] * m2[1][3],
			m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2] + m1[3][2] * m2[1][3],
			m1[0][3] * m2[1][0] + m1[1][3] * m2[1][1] + m1[2][3] * m2[1][2] + m1[3][3] * m2[1][3],
			m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2] + m1[3][0] * m2[2][3],
			m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2] + m1[3][1] * m2[2][3],
			m1[0][2] * m2[2][0] + m1[1][2] * m2[2][1] + m1[2][2] * m2[2][2] + m1[3][2] * m2[2][3],
			m1[0][3] * m2[2][0] + m1[1][3] * m2[2][1] + m1[2][3] * m2[2][2] + m1[3][3] * m2[2][3]);
	}

	template<typename T>
	 inline mat<4, 4, T> operator*(mat<4, 4, T> const& m1, mat<4, 4, T> const& m2)
	{
		typename mat<4, 4, T>::col_type const SrcA0 = m1[0];
		typename mat<4, 4, T>::col_type const SrcA1 = m1[1];
		typename mat<4, 4, T>::col_type const SrcA2 = m1[2];
		typename mat<4, 4, T>::col_type const SrcA3 = m1[3];

		typename mat<4, 4, T>::col_type const SrcB0 = m2[0];
		typename mat<4, 4, T>::col_type const SrcB1 = m2[1];
		typename mat<4, 4, T>::col_type const SrcB2 = m2[2];
		typename mat<4, 4, T>::col_type const SrcB3 = m2[3];

		mat<4, 4, T> Result;
		Result[0] = SrcA0 * SrcB0[0] + SrcA1 * SrcB0[1] + SrcA2 * SrcB0[2] + SrcA3 * SrcB0[3];
		Result[1] = SrcA0 * SrcB1[0] + SrcA1 * SrcB1[1] + SrcA2 * SrcB1[2] + SrcA3 * SrcB1[3];
		Result[2] = SrcA0 * SrcB2[0] + SrcA1 * SrcB2[1] + SrcA2 * SrcB2[2] + SrcA3 * SrcB2[3];
		Result[3] = SrcA0 * SrcB3[0] + SrcA1 * SrcB3[1] + SrcA2 * SrcB3[2] + SrcA3 * SrcB3[3];
		return Result;
	}

	template<typename T>
	 inline mat<4, 4, T> operator/(mat<4, 4, T> const& m, T const& s)
	{
		return mat<4, 4, T>(
			m[0] / s,
			m[1] / s,
			m[2] / s,
			m[3] / s);
	}

	template<typename T>
	 inline mat<4, 4, T> operator/(T const& s,	mat<4, 4, T> const& m)
	{
		return mat<4, 4, T>(
			s / m[0],
			s / m[1],
			s / m[2],
			s / m[3]);
	}

	template<typename T>
	 inline typename mat<4, 4, T>::col_type operator/(mat<4, 4, T> const& m, typename mat<4, 4, T>::row_type const& v)
	{
		return inverse(m) * v;
	}

	template<typename T>
	 inline typename mat<4, 4, T>::row_type operator/(typename mat<4, 4, T>::col_type const& v, mat<4, 4, T> const& m)
	{
		return v * inverse(m);
	}

	template<typename T>
	 inline mat<4, 4, T> operator/(mat<4, 4, T> const& m1, mat<4, 4, T> const& m2)
	{
		mat<4, 4, T> m1_copy(m1);
		return m1_copy /= m2;
	}

	

	template<typename T>
	 inline bool operator==(mat<4, 4, T> const& m1, mat<4, 4, T> const& m2)
	{
		return (m1[0] == m2[0]) && (m1[1] == m2[1]) && (m1[2] == m2[2]) && (m1[3] == m2[3]);
	}

	template<typename T>
	 inline bool operator!=(mat<4, 4, T> const& m1, mat<4, 4, T> const& m2)
	{
		return (m1[0] != m2[0]) || (m1[1] != m2[1]) || (m1[2] != m2[2]) || (m1[3] != m2[3]);
	}
}



#line 653 "C:\\Projects\\glm\\glm\\detail\\type_mat4x4.inl"
#line 178 "C:\\Projects\\glm\\glm\\ext\\../detail/type_mat4x4.hpp"
#line 179 "C:\\Projects\\glm\\glm\\ext\\../detail/type_mat4x4.hpp"
#line 6 "C:\\Projects\\glm\\glm\\./ext/matrix_double4x4.hpp"

namespace glm
{
	
	

	
	
	
	typedef mat<4, 4, double>		dmat4x4;

	
	
	
	typedef mat<4, 4, double>		dmat4;

	
}
#line 6 "C:\\Projects\\glm\\glm\\mat4x4.hpp"
#line 1 "C:\\Projects\\glm\\glm\\./ext/matrix_float4x4.hpp"



#pragma once


namespace glm
{
	
	

	
	
	
	typedef mat<4, 4, float>			mat4x4;

	
	
	
	typedef mat<4, 4, float>			mat4;

	
}
#line 7 "C:\\Projects\\glm\\glm\\mat4x4.hpp"
#line 29 "C:\\Projects\\glm\\glm\\detail\\../matrix.hpp"

namespace glm {
namespace detail
{
	template<length_t C, length_t R, typename T>
	struct outerProduct_trait{};

	template<typename T>
	struct outerProduct_trait<2, 2, T>
	{
		typedef mat<2, 2, T> type;
	};

	template<typename T>
	struct outerProduct_trait<2, 3, T>
	{
		typedef mat<3, 2, T> type;
	};

	template<typename T>
	struct outerProduct_trait<2, 4, T>
	{
		typedef mat<4, 2, T> type;
	};

	template<typename T>
	struct outerProduct_trait<3, 2, T>
	{
		typedef mat<2, 3, T> type;
	};

	template<typename T>
	struct outerProduct_trait<3, 3, T>
	{
		typedef mat<3, 3, T> type;
	};

	template<typename T>
	struct outerProduct_trait<3, 4, T>
	{
		typedef mat<4, 3, T> type;
	};

	template<typename T>
	struct outerProduct_trait<4, 2, T>
	{
		typedef mat<2, 4, T> type;
	};

	template<typename T>
	struct outerProduct_trait<4, 3, T>
	{
		typedef mat<3, 4, T> type;
	};

	template<typename T>
	struct outerProduct_trait<4, 4, T>
	{
		typedef mat<4, 4, T> type;
	};
}

	 
	 

	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	template<length_t C, length_t R, typename T>
	 mat<C, R, T> matrixCompMult(mat<C, R, T> const& x, mat<C, R, T> const& y);

	
	
	
	
	
	
	
	
	
	
	
	template<length_t C, length_t R, typename T>
	 typename detail::outerProduct_trait<C, R, T>::type outerProduct(vec<C, T> const& c, vec<R, T> const& r);

	
	
	
	
	
	
	
	
	
	template<length_t C, length_t R, typename T>
	 typename mat<C, R, T>::transpose_type transpose(mat<C, R, T> const& x);

	
	
	
	
	
	
	
	
	
	template<length_t C, length_t R, typename T>
	 T determinant(mat<C, R, T> const& m);

	
	
	
	
	
	
	
	
	
	template<length_t C, length_t R, typename T>
	 mat<C, R, T> inverse(mat<C, R, T> const& m);

	
}

#line 1 "C:\\Projects\\glm\\glm\\detail/func_matrix.inl"
#line 1 "C:\\Projects\\glm\\glm\\detail\\../geometric.hpp"












#pragma once



namespace glm
{
	
	

	
	
	
	
	
	
	
	template<length_t L, typename T>
	 T length(vec<L, T> const& x);

	
	
	
	
	
	
	
	template<length_t L, typename T>
	 T distance(vec<L, T> const& p0, vec<L, T> const& p1);

	
	
	
	
	
	
	
	template<length_t L, typename T>
	 T dot(vec<L, T> const& x, vec<L, T> const& y);

	
	
	
	
	
	
	template<typename T>
	 vec<3, T> cross(vec<3, T> const& x, vec<3, T> const& y);

	
	
	
	
	
	
	
	
	template<length_t L, typename T>
	 vec<L, T> normalize(vec<L, T> const& x);

	
	
	
	
	
	
	
	template<length_t L, typename T>
	 vec<L, T> faceforward(
		vec<L, T> const& N,
		vec<L, T> const& I,
		vec<L, T> const& Nref);

	
	
	
	
	
	
	
	
	template<length_t L, typename T>
	 vec<L, T> reflect(
		vec<L, T> const& I,
		vec<L, T> const& N);

	
	
	
	
	
	
	
	
	
	template<length_t L, typename T>
	 vec<L, T> refract(
		vec<L, T> const& I,
		vec<L, T> const& N,
		T eta);

	
}
#line 2 "C:\\Projects\\glm\\glm\\detail/func_matrix.inl"


namespace glm{
namespace detail
{
	template<length_t C, length_t R, typename T, bool Aligned>
	struct compute_matrixCompMult
	{
		 inline static mat<C, R, T> call(mat<C, R, T> const& x, mat<C, R, T> const& y)
		{
			mat<C, R, T> Result;
			for(length_t i = 0; i < Result.length(); ++i)
				Result[i] = x[i] * y[i];
			return Result;
		}
	};

	template<length_t C, length_t R, typename T, bool Aligned>
	struct compute_transpose{};

	template<typename T, bool Aligned>
	struct compute_transpose<2, 2, T, Aligned>
	{
		 inline static mat<2, 2, T> call(mat<2, 2, T> const& m)
		{
			mat<2, 2, T> Result;
			Result[0][0] = m[0][0];
			Result[0][1] = m[1][0];
			Result[1][0] = m[0][1];
			Result[1][1] = m[1][1];
			return Result;
		}
	};

	template<typename T, bool Aligned>
	struct compute_transpose<2, 3, T, Aligned>
	{
		 inline static mat<3, 2, T> call(mat<2, 3, T> const& m)
		{
			mat<3,2, T> Result;
			Result[0][0] = m[0][0];
			Result[0][1] = m[1][0];
			Result[1][0] = m[0][1];
			Result[1][1] = m[1][1];
			Result[2][0] = m[0][2];
			Result[2][1] = m[1][2];
			return Result;
		}
	};

	template<typename T, bool Aligned>
	struct compute_transpose<2, 4, T, Aligned>
	{
		 inline static mat<4, 2, T> call(mat<2, 4, T> const& m)
		{
			mat<4, 2, T> Result;
			Result[0][0] = m[0][0];
			Result[0][1] = m[1][0];
			Result[1][0] = m[0][1];
			Result[1][1] = m[1][1];
			Result[2][0] = m[0][2];
			Result[2][1] = m[1][2];
			Result[3][0] = m[0][3];
			Result[3][1] = m[1][3];
			return Result;
		}
	};

	template<typename T, bool Aligned>
	struct compute_transpose<3, 2, T, Aligned>
	{
		 inline static mat<2, 3, T> call(mat<3, 2, T> const& m)
		{
			mat<2, 3, T> Result;
			Result[0][0] = m[0][0];
			Result[0][1] = m[1][0];
			Result[0][2] = m[2][0];
			Result[1][0] = m[0][1];
			Result[1][1] = m[1][1];
			Result[1][2] = m[2][1];
			return Result;
		}
	};

	template<typename T, bool Aligned>
	struct compute_transpose<3, 3, T, Aligned>
	{
		 inline static mat<3, 3, T> call(mat<3, 3, T> const& m)
		{
			mat<3, 3, T> Result;
			Result[0][0] = m[0][0];
			Result[0][1] = m[1][0];
			Result[0][2] = m[2][0];

			Result[1][0] = m[0][1];
			Result[1][1] = m[1][1];
			Result[1][2] = m[2][1];

			Result[2][0] = m[0][2];
			Result[2][1] = m[1][2];
			Result[2][2] = m[2][2];
			return Result;
		}
	};

	template<typename T, bool Aligned>
	struct compute_transpose<3, 4, T, Aligned>
	{
		 inline static mat<4, 3, T> call(mat<3, 4, T> const& m)
		{
			mat<4, 3, T> Result;
			Result[0][0] = m[0][0];
			Result[0][1] = m[1][0];
			Result[0][2] = m[2][0];
			Result[1][0] = m[0][1];
			Result[1][1] = m[1][1];
			Result[1][2] = m[2][1];
			Result[2][0] = m[0][2];
			Result[2][1] = m[1][2];
			Result[2][2] = m[2][2];
			Result[3][0] = m[0][3];
			Result[3][1] = m[1][3];
			Result[3][2] = m[2][3];
			return Result;
		}
	};

	template<typename T, bool Aligned>
	struct compute_transpose<4, 2, T, Aligned>
	{
		 inline static mat<2, 4, T> call(mat<4, 2, T> const& m)
		{
			mat<2, 4, T> Result;
			Result[0][0] = m[0][0];
			Result[0][1] = m[1][0];
			Result[0][2] = m[2][0];
			Result[0][3] = m[3][0];
			Result[1][0] = m[0][1];
			Result[1][1] = m[1][1];
			Result[1][2] = m[2][1];
			Result[1][3] = m[3][1];
			return Result;
		}
	};

	template<typename T, bool Aligned>
	struct compute_transpose<4, 3, T, Aligned>
	{
		 inline static mat<3, 4, T> call(mat<4, 3, T> const& m)
		{
			mat<3, 4, T> Result;
			Result[0][0] = m[0][0];
			Result[0][1] = m[1][0];
			Result[0][2] = m[2][0];
			Result[0][3] = m[3][0];
			Result[1][0] = m[0][1];
			Result[1][1] = m[1][1];
			Result[1][2] = m[2][1];
			Result[1][3] = m[3][1];
			Result[2][0] = m[0][2];
			Result[2][1] = m[1][2];
			Result[2][2] = m[2][2];
			Result[2][3] = m[3][2];
			return Result;
		}
	};

	template<typename T, bool Aligned>
	struct compute_transpose<4, 4, T, Aligned>
	{
		 inline static mat<4, 4, T> call(mat<4, 4, T> const& m)
		{
			mat<4, 4, T> Result;
			Result[0][0] = m[0][0];
			Result[0][1] = m[1][0];
			Result[0][2] = m[2][0];
			Result[0][3] = m[3][0];

			Result[1][0] = m[0][1];
			Result[1][1] = m[1][1];
			Result[1][2] = m[2][1];
			Result[1][3] = m[3][1];

			Result[2][0] = m[0][2];
			Result[2][1] = m[1][2];
			Result[2][2] = m[2][2];
			Result[2][3] = m[3][2];

			Result[3][0] = m[0][3];
			Result[3][1] = m[1][3];
			Result[3][2] = m[2][3];
			Result[3][3] = m[3][3];
			return Result;
		}
	};

	template<length_t C, length_t R, typename T, bool Aligned>
	struct compute_determinant{};

	template<typename T, bool Aligned>
	struct compute_determinant<2, 2, T, Aligned>
	{
		 inline static T call(mat<2, 2, T> const& m)
		{
			return m[0][0] * m[1][1] - m[1][0] * m[0][1];
		}
	};

	template<typename T, bool Aligned>
	struct compute_determinant<3, 3, T, Aligned>
	{
		 inline static T call(mat<3, 3, T> const& m)
		{
			return
				+ m[0][0] * (m[1][1] * m[2][2] - m[2][1] * m[1][2])
				- m[1][0] * (m[0][1] * m[2][2] - m[2][1] * m[0][2])
				+ m[2][0] * (m[0][1] * m[1][2] - m[1][1] * m[0][2]);
		}
	};

	template<typename T, bool Aligned>
	struct compute_determinant<4, 4, T, Aligned>
	{
		 inline static T call(mat<4, 4, T> const& m)
		{
			T SubFactor00 = m[2][2] * m[3][3] - m[3][2] * m[2][3];
			T SubFactor01 = m[2][1] * m[3][3] - m[3][1] * m[2][3];
			T SubFactor02 = m[2][1] * m[3][2] - m[3][1] * m[2][2];
			T SubFactor03 = m[2][0] * m[3][3] - m[3][0] * m[2][3];
			T SubFactor04 = m[2][0] * m[3][2] - m[3][0] * m[2][2];
			T SubFactor05 = m[2][0] * m[3][1] - m[3][0] * m[2][1];

			vec<4, T> DetCof(
				+ (m[1][1] * SubFactor00 - m[1][2] * SubFactor01 + m[1][3] * SubFactor02),
				- (m[1][0] * SubFactor00 - m[1][2] * SubFactor03 + m[1][3] * SubFactor04),
				+ (m[1][0] * SubFactor01 - m[1][1] * SubFactor03 + m[1][3] * SubFactor05),
				- (m[1][0] * SubFactor02 - m[1][1] * SubFactor04 + m[1][2] * SubFactor05));

			return
				m[0][0] * DetCof[0] + m[0][1] * DetCof[1] +
				m[0][2] * DetCof[2] + m[0][3] * DetCof[3];
		}
	};

	template<length_t C, length_t R, typename T, bool Aligned>
	struct compute_inverse{};

	template<typename T, bool Aligned>
	struct compute_inverse<2, 2, T, Aligned>
	{
		 inline static mat<2, 2, T> call(mat<2, 2, T> const& m)
		{
			T OneOverDeterminant = static_cast<T>(1) / (
				+ m[0][0] * m[1][1]
				- m[1][0] * m[0][1]);

			mat<2, 2, T> Inverse(
				+ m[1][1] * OneOverDeterminant,
				- m[0][1] * OneOverDeterminant,
				- m[1][0] * OneOverDeterminant,
				+ m[0][0] * OneOverDeterminant);

			return Inverse;
		}
	};

	template<typename T, bool Aligned>
	struct compute_inverse<3, 3, T, Aligned>
	{
		 inline static mat<3, 3, T> call(mat<3, 3, T> const& m)
		{
			T OneOverDeterminant = static_cast<T>(1) / (
				+ m[0][0] * (m[1][1] * m[2][2] - m[2][1] * m[1][2])
				- m[1][0] * (m[0][1] * m[2][2] - m[2][1] * m[0][2])
				+ m[2][0] * (m[0][1] * m[1][2] - m[1][1] * m[0][2]));

			mat<3, 3, T> Inverse;
			Inverse[0][0] = + (m[1][1] * m[2][2] - m[2][1] * m[1][2]) * OneOverDeterminant;
			Inverse[1][0] = - (m[1][0] * m[2][2] - m[2][0] * m[1][2]) * OneOverDeterminant;
			Inverse[2][0] = + (m[1][0] * m[2][1] - m[2][0] * m[1][1]) * OneOverDeterminant;
			Inverse[0][1] = - (m[0][1] * m[2][2] - m[2][1] * m[0][2]) * OneOverDeterminant;
			Inverse[1][1] = + (m[0][0] * m[2][2] - m[2][0] * m[0][2]) * OneOverDeterminant;
			Inverse[2][1] = - (m[0][0] * m[2][1] - m[2][0] * m[0][1]) * OneOverDeterminant;
			Inverse[0][2] = + (m[0][1] * m[1][2] - m[1][1] * m[0][2]) * OneOverDeterminant;
			Inverse[1][2] = - (m[0][0] * m[1][2] - m[1][0] * m[0][2]) * OneOverDeterminant;
			Inverse[2][2] = + (m[0][0] * m[1][1] - m[1][0] * m[0][1]) * OneOverDeterminant;

			return Inverse;
		}
	};

	template<typename T, bool Aligned>
	struct compute_inverse<4, 4, T, Aligned>
	{
		 inline static mat<4, 4, T> call(mat<4, 4, T> const& m)
		{
			T Coef00 = m[2][2] * m[3][3] - m[3][2] * m[2][3];
			T Coef02 = m[1][2] * m[3][3] - m[3][2] * m[1][3];
			T Coef03 = m[1][2] * m[2][3] - m[2][2] * m[1][3];

			T Coef04 = m[2][1] * m[3][3] - m[3][1] * m[2][3];
			T Coef06 = m[1][1] * m[3][3] - m[3][1] * m[1][3];
			T Coef07 = m[1][1] * m[2][3] - m[2][1] * m[1][3];

			T Coef08 = m[2][1] * m[3][2] - m[3][1] * m[2][2];
			T Coef10 = m[1][1] * m[3][2] - m[3][1] * m[1][2];
			T Coef11 = m[1][1] * m[2][2] - m[2][1] * m[1][2];

			T Coef12 = m[2][0] * m[3][3] - m[3][0] * m[2][3];
			T Coef14 = m[1][0] * m[3][3] - m[3][0] * m[1][3];
			T Coef15 = m[1][0] * m[2][3] - m[2][0] * m[1][3];

			T Coef16 = m[2][0] * m[3][2] - m[3][0] * m[2][2];
			T Coef18 = m[1][0] * m[3][2] - m[3][0] * m[1][2];
			T Coef19 = m[1][0] * m[2][2] - m[2][0] * m[1][2];

			T Coef20 = m[2][0] * m[3][1] - m[3][0] * m[2][1];
			T Coef22 = m[1][0] * m[3][1] - m[3][0] * m[1][1];
			T Coef23 = m[1][0] * m[2][1] - m[2][0] * m[1][1];

			vec<4, T> Fac0(Coef00, Coef00, Coef02, Coef03);
			vec<4, T> Fac1(Coef04, Coef04, Coef06, Coef07);
			vec<4, T> Fac2(Coef08, Coef08, Coef10, Coef11);
			vec<4, T> Fac3(Coef12, Coef12, Coef14, Coef15);
			vec<4, T> Fac4(Coef16, Coef16, Coef18, Coef19);
			vec<4, T> Fac5(Coef20, Coef20, Coef22, Coef23);

			vec<4, T> Vec0(m[1][0], m[0][0], m[0][0], m[0][0]);
			vec<4, T> Vec1(m[1][1], m[0][1], m[0][1], m[0][1]);
			vec<4, T> Vec2(m[1][2], m[0][2], m[0][2], m[0][2]);
			vec<4, T> Vec3(m[1][3], m[0][3], m[0][3], m[0][3]);

			vec<4, T> Inv0(Vec1 * Fac0 - Vec2 * Fac1 + Vec3 * Fac2);
			vec<4, T> Inv1(Vec0 * Fac0 - Vec2 * Fac3 + Vec3 * Fac4);
			vec<4, T> Inv2(Vec0 * Fac1 - Vec1 * Fac3 + Vec3 * Fac5);
			vec<4, T> Inv3(Vec0 * Fac2 - Vec1 * Fac4 + Vec2 * Fac5);

			vec<4, T> SignA(+1, -1, +1, -1);
			vec<4, T> SignB(-1, +1, -1, +1);
			mat<4, 4, T> Inverse(Inv0 * SignA, Inv1 * SignB, Inv2 * SignA, Inv3 * SignB);

			vec<4, T> Row0(Inverse[0][0], Inverse[1][0], Inverse[2][0], Inverse[3][0]);

			vec<4, T> Dot0(m[0] * Row0);
			T Dot1 = (Dot0.x + Dot0.y) + (Dot0.z + Dot0.w);

			T OneOverDeterminant = static_cast<T>(1) / Dot1;

			return Inverse * OneOverDeterminant;
		}
	};
}

	template<length_t C, length_t R, typename T>
	 inline mat<C, R, T> matrixCompMult(mat<C, R, T> const& x, mat<C, R, T> const& y)
	{
		static_assert(std::numeric_limits<T>::is_iec559 || 0, "'matrixCompMult' only accept floating-point inputs");
		return detail::compute_matrixCompMult<C, R, T, false>::call(x, y);
	}

	template<length_t DA, length_t DB, typename T>
	 inline typename detail::outerProduct_trait<DA, DB, T>::type outerProduct(vec<DA, T> const& c, vec<DB, T> const& r)
	{
		static_assert(std::numeric_limits<T>::is_iec559 || 0, "'outerProduct' only accept floating-point inputs");

		typename detail::outerProduct_trait<DA, DB, T>::type m;
		for(length_t i = 0; i < m.length(); ++i)
			m[i] = c * r[i];
		return m;
	}

	template<length_t C, length_t R, typename T>
	 inline typename mat<C, R, T>::transpose_type transpose(mat<C, R, T> const& m)
	{
		static_assert(std::numeric_limits<T>::is_iec559 || 0, "'transpose' only accept floating-point inputs");
		return detail::compute_transpose<C, R, T, false>::call(m);
	}

	template<length_t C, length_t R, typename T>
	 inline T determinant(mat<C, R, T> const& m)
	{
		static_assert(std::numeric_limits<T>::is_iec559 || 0, "'determinant' only accept floating-point inputs");
		return detail::compute_determinant<C, R, T, false>::call(m);
	}

	template<length_t C, length_t R, typename T>
	 inline mat<C, R, T> inverse(mat<C, R, T> const& m)
	{
		static_assert(std::numeric_limits<T>::is_iec559 || 0, "'inverse' only accept floating-point inputs");
		return detail::compute_inverse<C, R, T, false>::call(m);
	}
}



#line 398 "C:\\Projects\\glm\\glm\\detail/func_matrix.inl"

#line 161 "C:\\Projects\\glm\\glm\\detail\\../matrix.hpp"
#line 2 "C:\\Projects\\glm\\glm\\detail\\type_mat3x3.inl"

namespace glm
{
	














#line 21 "C:\\Projects\\glm\\glm\\detail\\type_mat3x3.inl"

	template<typename T>
	 inline constexpr mat<3, 3, T>::mat(mat<3, 3, T> const& m)

			: value{col_type(m[0]), col_type(m[1]), col_type(m[2])}
#line 27 "C:\\Projects\\glm\\glm\\detail\\type_mat3x3.inl"
	{




#line 33 "C:\\Projects\\glm\\glm\\detail\\type_mat3x3.inl"
	}

	template<typename T>
	 inline constexpr mat<3, 3, T>::mat(T s)

			: value{col_type(s, 0, 0), col_type(0, s, 0), col_type(0, 0, s)}
#line 40 "C:\\Projects\\glm\\glm\\detail\\type_mat3x3.inl"
	{




#line 46 "C:\\Projects\\glm\\glm\\detail\\type_mat3x3.inl"
	}

	template<typename T>
	 inline constexpr mat<3, 3, T>::mat
	(
		T x0, T y0, T z0,
		T x1, T y1, T z1,
		T x2, T y2, T z2
	)

			: value{col_type(x0, y0, z0), col_type(x1, y1, z1), col_type(x2, y2, z2)}
#line 58 "C:\\Projects\\glm\\glm\\detail\\type_mat3x3.inl"
	{




#line 64 "C:\\Projects\\glm\\glm\\detail\\type_mat3x3.inl"
	}

	template<typename T>
	 inline constexpr mat<3, 3, T>::mat(col_type const& v0, col_type const& v1, col_type const& v2)

			: value{col_type(v0), col_type(v1), col_type(v2)}
#line 71 "C:\\Projects\\glm\\glm\\detail\\type_mat3x3.inl"
	{




#line 77 "C:\\Projects\\glm\\glm\\detail\\type_mat3x3.inl"
	}

	

	template<typename T>
	template<
		typename X1, typename Y1, typename Z1,
		typename X2, typename Y2, typename Z2,
		typename X3, typename Y3, typename Z3>
	 inline constexpr mat<3, 3, T>::mat
	(
		X1 x1, Y1 y1, Z1 z1,
		X2 x2, Y2 y2, Z2 z2,
		X3 x3, Y3 y3, Z3 z3
	)

			: value{col_type(x1, y1, z1), col_type(x2, y2, z2), col_type(x3, y3, z3)}
#line 95 "C:\\Projects\\glm\\glm\\detail\\type_mat3x3.inl"
	{




#line 101 "C:\\Projects\\glm\\glm\\detail\\type_mat3x3.inl"
	}

	template<typename T>
	template<typename V1, typename V2, typename V3>
	 inline constexpr mat<3, 3, T>::mat(vec<3, V1> const& v1, vec<3, V2> const& v2, vec<3, V3> const& v3)

			: value{col_type(v1), col_type(v2), col_type(v3)}
#line 109 "C:\\Projects\\glm\\glm\\detail\\type_mat3x3.inl"
	{




#line 115 "C:\\Projects\\glm\\glm\\detail\\type_mat3x3.inl"
	}

	

	template<typename T>
	 inline constexpr mat<3, 3, T>::mat(mat<2, 2, T> const& m)

			: value{col_type(m[0], 0), col_type(m[1], 0), col_type(0, 0, 1)}
#line 124 "C:\\Projects\\glm\\glm\\detail\\type_mat3x3.inl"
	{




#line 130 "C:\\Projects\\glm\\glm\\detail\\type_mat3x3.inl"
	}

	template<typename T>
	 inline constexpr mat<3, 3, T>::mat(mat<4, 4, T> const& m)

			: value{col_type(m[0]), col_type(m[1]), col_type(m[2])}
#line 137 "C:\\Projects\\glm\\glm\\detail\\type_mat3x3.inl"
	{




#line 143 "C:\\Projects\\glm\\glm\\detail\\type_mat3x3.inl"
	}

	template<typename T>
	 inline constexpr mat<3, 3, T>::mat(mat<2, 3, T> const& m)

			: value{col_type(m[0]), col_type(m[1]), col_type(0, 0, 1)}
#line 150 "C:\\Projects\\glm\\glm\\detail\\type_mat3x3.inl"
	{




#line 156 "C:\\Projects\\glm\\glm\\detail\\type_mat3x3.inl"
	}

	template<typename T>
	 inline constexpr mat<3, 3, T>::mat(mat<3, 2, T> const& m)

			: value{col_type(m[0], 0), col_type(m[1], 0), col_type(m[2], 1)}
#line 163 "C:\\Projects\\glm\\glm\\detail\\type_mat3x3.inl"
	{




#line 169 "C:\\Projects\\glm\\glm\\detail\\type_mat3x3.inl"
	}

	template<typename T>
	 inline constexpr mat<3, 3, T>::mat(mat<2, 4, T> const& m)

			: value{col_type(m[0]), col_type(m[1]), col_type(0, 0, 1)}
#line 176 "C:\\Projects\\glm\\glm\\detail\\type_mat3x3.inl"
	{




#line 182 "C:\\Projects\\glm\\glm\\detail\\type_mat3x3.inl"
	}

	template<typename T>
	 inline constexpr mat<3, 3, T>::mat(mat<4, 2, T> const& m)

			: value{col_type(m[0], 0), col_type(m[1], 0), col_type(m[2], 1)}
#line 189 "C:\\Projects\\glm\\glm\\detail\\type_mat3x3.inl"
	{




#line 195 "C:\\Projects\\glm\\glm\\detail\\type_mat3x3.inl"
	}

	template<typename T>
	 inline constexpr mat<3, 3, T>::mat(mat<3, 4, T> const& m)

			: value{col_type(m[0]), col_type(m[1]), col_type(m[2])}
#line 202 "C:\\Projects\\glm\\glm\\detail\\type_mat3x3.inl"
	{




#line 208 "C:\\Projects\\glm\\glm\\detail\\type_mat3x3.inl"
	}

	template<typename T>
	 inline constexpr mat<3, 3, T>::mat(mat<4, 3, T> const& m)

			: value{col_type(m[0]), col_type(m[1]), col_type(m[2])}
#line 215 "C:\\Projects\\glm\\glm\\detail\\type_mat3x3.inl"
	{




#line 221 "C:\\Projects\\glm\\glm\\detail\\type_mat3x3.inl"
	}

	

	template<typename T>
	 inline typename mat<3, 3, T>::col_type & mat<3, 3, T>::operator[](typename mat<3, 3, T>::length_type i)
	{
		(void)( (!!(i < this->length())) || (_wassert(L"i < this->length()", L"C:\\Projects\\glm\\glm\\detail\\type_mat3x3.inl", (unsigned)(228)), 0) );
		return this->value[i];
	}

	template<typename T>
	 inline constexpr typename mat<3, 3, T>::col_type const& mat<3, 3, T>::operator[](typename mat<3, 3, T>::length_type i) const
	{
		(void)( (!!(i < this->length())) || (_wassert(L"i < this->length()", L"C:\\Projects\\glm\\glm\\detail\\type_mat3x3.inl", (unsigned)(235)), 0) );
		return this->value[i];
	}

	

	template<typename T>
	template<typename U>
	 inline mat<3, 3, T> & mat<3, 3, T>::operator=(mat<3, 3, U> const& m)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
		this->value[2] = m[2];
		return *this;
	}

	template<typename T>
	template<typename U>
	 inline mat<3, 3, T> & mat<3, 3, T>::operator+=(U s)
	{
		this->value[0] += s;
		this->value[1] += s;
		this->value[2] += s;
		return *this;
	}

	template<typename T>
	template<typename U>
	 inline mat<3, 3, T> & mat<3, 3, T>::operator+=(mat<3, 3, U> const& m)
	{
		this->value[0] += m[0];
		this->value[1] += m[1];
		this->value[2] += m[2];
		return *this;
	}

	template<typename T>
	template<typename U>
	 inline mat<3, 3, T> & mat<3, 3, T>::operator-=(U s)
	{
		this->value[0] -= s;
		this->value[1] -= s;
		this->value[2] -= s;
		return *this;
	}

	template<typename T>
	template<typename U>
	 inline mat<3, 3, T> & mat<3, 3, T>::operator-=(mat<3, 3, U> const& m)
	{
		this->value[0] -= m[0];
		this->value[1] -= m[1];
		this->value[2] -= m[2];
		return *this;
	}

	template<typename T>
	template<typename U>
	 inline mat<3, 3, T> & mat<3, 3, T>::operator*=(U s)
	{
		this->value[0] *= s;
		this->value[1] *= s;
		this->value[2] *= s;
		return *this;
	}

	template<typename T>
	template<typename U>
	 inline mat<3, 3, T> & mat<3, 3, T>::operator*=(mat<3, 3, U> const& m)
	{
		return (*this = *this * m);
	}

	template<typename T>
	template<typename U>
	 inline mat<3, 3, T> & mat<3, 3, T>::operator/=(U s)
	{
		this->value[0] /= s;
		this->value[1] /= s;
		this->value[2] /= s;
		return *this;
	}

	template<typename T>
	template<typename U>
	 inline mat<3, 3, T> & mat<3, 3, T>::operator/=(mat<3, 3, U> const& m)
	{
		return *this *= inverse(m);
	}

	

	template<typename T>
	 inline mat<3, 3, T> operator+(mat<3, 3, T> const& m)
	{
		return m;
	}

	template<typename T>
	 inline mat<3, 3, T> operator-(mat<3, 3, T> const& m)
	{
		return mat<3, 3, T>(
			-m[0],
			-m[1],
			-m[2]);
	}

	

	template<typename T>
	 inline mat<3, 3, T> operator+(mat<3, 3, T> const& m, T scalar)
	{
		return mat<3, 3, T>(
			m[0] + scalar,
			m[1] + scalar,
			m[2] + scalar);
	}

	template<typename T>
	 inline mat<3, 3, T> operator+(T scalar, mat<3, 3, T> const& m)
	{
		return mat<3, 3, T>(
			m[0] + scalar,
			m[1] + scalar,
			m[2] + scalar);
	}

	template<typename T>
	 inline mat<3, 3, T> operator+(mat<3, 3, T> const& m1, mat<3, 3, T> const& m2)
	{
		return mat<3, 3, T>(
			m1[0] + m2[0],
			m1[1] + m2[1],
			m1[2] + m2[2]);
	}

	template<typename T>
	 inline mat<3, 3, T> operator-(mat<3, 3, T> const& m, T scalar)
	{
		return mat<3, 3, T>(
			m[0] - scalar,
			m[1] - scalar,
			m[2] - scalar);
	}

	template<typename T>
	 inline mat<3, 3, T> operator-(T scalar, mat<3, 3, T> const& m)
	{
		return mat<3, 3, T>(
			scalar - m[0],
			scalar - m[1],
			scalar - m[2]);
	}

	template<typename T>
	 inline mat<3, 3, T> operator-(mat<3, 3, T> const& m1, mat<3, 3, T> const& m2)
	{
		return mat<3, 3, T>(
			m1[0] - m2[0],
			m1[1] - m2[1],
			m1[2] - m2[2]);
	}

	template<typename T>
	 inline mat<3, 3, T> operator*(mat<3, 3, T> const& m, T scalar)
	{
		return mat<3, 3, T>(
			m[0] * scalar,
			m[1] * scalar,
			m[2] * scalar);
	}

	template<typename T>
	 inline mat<3, 3, T> operator*(T scalar, mat<3, 3, T> const& m)
	{
		return mat<3, 3, T>(
			m[0] * scalar,
			m[1] * scalar,
			m[2] * scalar);
	}

	template<typename T>
	 inline typename mat<3, 3, T>::col_type operator*(mat<3, 3, T> const& m, typename mat<3, 3, T>::row_type const& v)
	{
		return typename mat<3, 3, T>::col_type(
			m[0][0] * v.x + m[1][0] * v.y + m[2][0] * v.z,
			m[0][1] * v.x + m[1][1] * v.y + m[2][1] * v.z,
			m[0][2] * v.x + m[1][2] * v.y + m[2][2] * v.z);
	}

	template<typename T>
	 inline typename mat<3, 3, T>::row_type operator*(typename mat<3, 3, T>::col_type const& v, mat<3, 3, T> const& m)
	{
		return typename mat<3, 3, T>::row_type(
			m[0][0] * v.x + m[0][1] * v.y + m[0][2] * v.z,
			m[1][0] * v.x + m[1][1] * v.y + m[1][2] * v.z,
			m[2][0] * v.x + m[2][1] * v.y + m[2][2] * v.z);
	}

	template<typename T>
	 inline mat<3, 3, T> operator*(mat<3, 3, T> const& m1, mat<3, 3, T> const& m2)
	{
		T const SrcA00 = m1[0][0];
		T const SrcA01 = m1[0][1];
		T const SrcA02 = m1[0][2];
		T const SrcA10 = m1[1][0];
		T const SrcA11 = m1[1][1];
		T const SrcA12 = m1[1][2];
		T const SrcA20 = m1[2][0];
		T const SrcA21 = m1[2][1];
		T const SrcA22 = m1[2][2];

		T const SrcB00 = m2[0][0];
		T const SrcB01 = m2[0][1];
		T const SrcB02 = m2[0][2];
		T const SrcB10 = m2[1][0];
		T const SrcB11 = m2[1][1];
		T const SrcB12 = m2[1][2];
		T const SrcB20 = m2[2][0];
		T const SrcB21 = m2[2][1];
		T const SrcB22 = m2[2][2];

		mat<3, 3, T> Result;
		Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01 + SrcA20 * SrcB02;
		Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01 + SrcA21 * SrcB02;
		Result[0][2] = SrcA02 * SrcB00 + SrcA12 * SrcB01 + SrcA22 * SrcB02;
		Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11 + SrcA20 * SrcB12;
		Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11 + SrcA21 * SrcB12;
		Result[1][2] = SrcA02 * SrcB10 + SrcA12 * SrcB11 + SrcA22 * SrcB12;
		Result[2][0] = SrcA00 * SrcB20 + SrcA10 * SrcB21 + SrcA20 * SrcB22;
		Result[2][1] = SrcA01 * SrcB20 + SrcA11 * SrcB21 + SrcA21 * SrcB22;
		Result[2][2] = SrcA02 * SrcB20 + SrcA12 * SrcB21 + SrcA22 * SrcB22;
		return Result;
	}

	template<typename T>
	 inline mat<2, 3, T> operator*(mat<3, 3, T> const& m1, mat<2, 3, T> const& m2)
	{
		return mat<2, 3, T>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2],
			m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2],
			m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2]);
	}

	template<typename T>
	 inline mat<4, 3, T> operator*(mat<3, 3, T> const& m1, mat<4, 3, T> const& m2)
	{
		return mat<4, 3, T>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2],
			m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2],
			m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2],
			m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2],
			m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2],
			m1[0][2] * m2[2][0] + m1[1][2] * m2[2][1] + m1[2][2] * m2[2][2],
			m1[0][0] * m2[3][0] + m1[1][0] * m2[3][1] + m1[2][0] * m2[3][2],
			m1[0][1] * m2[3][0] + m1[1][1] * m2[3][1] + m1[2][1] * m2[3][2],
			m1[0][2] * m2[3][0] + m1[1][2] * m2[3][1] + m1[2][2] * m2[3][2]);
	}

	template<typename T>
	 inline mat<3, 3, T> operator/(mat<3, 3, T> const& m,	T scalar)
	{
		return mat<3, 3, T>(
			m[0] / scalar,
			m[1] / scalar,
			m[2] / scalar);
	}

	template<typename T>
	 inline mat<3, 3, T> operator/(T scalar, mat<3, 3, T> const& m)
	{
		return mat<3, 3, T>(
			scalar / m[0],
			scalar / m[1],
			scalar / m[2]);
	}

	template<typename T>
	 inline typename mat<3, 3, T>::col_type operator/(mat<3, 3, T> const& m, typename mat<3, 3, T>::row_type const& v)
	{
		return  inverse(m) * v;
	}

	template<typename T>
	 inline typename mat<3, 3, T>::row_type operator/(typename mat<3, 3, T>::col_type const& v, mat<3, 3, T> const& m)
	{
		return v * inverse(m);
	}

	template<typename T>
	 inline mat<3, 3, T> operator/(mat<3, 3, T> const& m1, mat<3, 3, T> const& m2)
	{
		mat<3, 3, T> m1_copy(m1);
		return m1_copy /= m2;
	}

	

	template<typename T>
	 inline constexpr bool operator==(mat<3, 3, T> const& m1, mat<3, 3, T> const& m2)
	{
		return (m1[0] == m2[0]) && (m1[1] == m2[1]) && (m1[2] == m2[2]);
	}

	template<typename T>
	 inline bool operator!=(mat<3, 3, T> const& m1, mat<3, 3, T> const& m2)
	{
		return (m1[0] != m2[0]) || (m1[1] != m2[1]) || (m1[2] != m2[2]);
	}
} 
#line 173 "C:\\Projects\\glm\\glm\\ext\\../detail/type_mat3x3.hpp"
#line 174 "C:\\Projects\\glm\\glm\\ext\\../detail/type_mat3x3.hpp"
#line 6 "C:\\Projects\\glm\\glm\\./ext/matrix_double3x3.hpp"

namespace glm
{
	
	

	
	
	
	typedef mat<3, 3, double>		dmat3x3;

	
	
	
	typedef mat<3, 3, double>		dmat3;

	
}
#line 6 "C:\\Projects\\glm\\glm\\mat3x3.hpp"
#line 1 "C:\\Projects\\glm\\glm\\./ext/matrix_float3x3.hpp"



#pragma once


namespace glm
{
	
	

	
	
	
	typedef mat<3, 3, float>			mat3x3;

	
	
	
	typedef mat<3, 3, float>			mat3;

	
}
#line 7 "C:\\Projects\\glm\\glm\\mat3x3.hpp"
#line 8 ".\\glm_impl.cpp"






































#line 1 "C:\\Projects\\glm\\glm\\detail/func_vector_relational.inl"
namespace glm
{
	template<length_t L, typename T>
	 inline constexpr vec<L, bool> lessThan(vec<L, T> const& x, vec<L, T> const& y)
	{
		vec<L, bool> Result(true);
		for(length_t i = 0; i < L; ++i)
			Result[i] = x[i] < y[i];
		return Result;
	}

	template<length_t L, typename T>
	 inline constexpr vec<L, bool> lessThanEqual(vec<L, T> const& x, vec<L, T> const& y)
	{
		vec<L, bool> Result(true);
		for(length_t i = 0; i < L; ++i)
			Result[i] = x[i] <= y[i];
		return Result;
	}

	template<length_t L, typename T>
	 inline constexpr vec<L, bool> greaterThan(vec<L, T> const& x, vec<L, T> const& y)
	{
		vec<L, bool> Result(true);
		for(length_t i = 0; i < L; ++i)
			Result[i] = x[i] > y[i];
		return Result;
	}

	template<length_t L, typename T>
	 inline constexpr vec<L, bool> greaterThanEqual(vec<L, T> const& x, vec<L, T> const& y)
	{
		vec<L, bool> Result(true);
		for(length_t i = 0; i < L; ++i)
			Result[i] = x[i] >= y[i];
		return Result;
	}

	template<length_t L, typename T>
	 inline constexpr vec<L, bool> equal(vec<L, T> const& x, vec<L, T> const& y)
	{
		vec<L, bool> Result(true);
		for(length_t i = 0; i < L; ++i)
			Result[i] = x[i] == y[i];
		return Result;
	}

	template<length_t L, typename T>
	 inline constexpr vec<L, bool> notEqual(vec<L, T> const& x, vec<L, T> const& y)
	{
		vec<L, bool> Result(true);
		for(length_t i = 0; i < L; ++i)
			Result[i] = x[i] != y[i];
		return Result;
	}

	template<length_t L>
	 inline constexpr bool any(vec<L, bool> const& v)
	{
		bool Result = false;
		for(length_t i = 0; i < L; ++i)
			Result = Result || v[i];
		return Result;
	}

	template<length_t L>
	 inline constexpr bool all(vec<L, bool> const& v)
	{
		bool Result = true;
		for(length_t i = 0; i < L; ++i)
			Result = Result && v[i];
		return Result;
	}

	template<length_t L>
	 inline constexpr vec<L, bool> not_(vec<L, bool> const& v)
	{
		vec<L, bool> Result(true);
		for(length_t i = 0; i < L; ++i)
			Result[i] = !v[i];
		return Result;
	}
}



#line 88 "C:\\Projects\\glm\\glm\\detail/func_vector_relational.inl"
#line 47 ".\\glm_impl.cpp"
namespace glm {










	template vec<2, bool> lessThan(vec<2, double>const &, vec<2, double>const &); template vec<2, bool> lessThanEqual(vec<2, double>const &, vec<2, double>const &); template vec<2, bool> greaterThan(vec<2, double>const &, vec<2, double>const &); template vec<2, bool> greaterThanEqual(vec<2, double>const &, vec<2, double>const &); template vec<2, bool> equal(vec<2, double>const &, vec<2, double>const &); template vec<2, bool> notEqual(vec<2, double>const &, vec<2, double>const &); template bool any(vec<2, bool>const &); template bool all(vec<2, bool>const &); template vec<2, bool> not_(vec<2, bool>const &); template vec<2, bool> lessThan(vec<2, float>const &, vec<2, float>const &); template vec<2, bool> lessThanEqual(vec<2, float>const &, vec<2, float>const &); template vec<2, bool> greaterThan(vec<2, float>const &, vec<2, float>const &); template vec<2, bool> greaterThanEqual(vec<2, float>const &, vec<2, float>const &); template vec<2, bool> equal(vec<2, float>const &, vec<2, float>const &); template vec<2, bool> notEqual(vec<2, float>const &, vec<2, float>const &); template bool any(vec<2, bool>const &); template bool all(vec<2, bool>const &); template vec<2, bool> not_(vec<2, bool>const &); template vec<2, bool> lessThan(vec<2, int>const &, vec<2, int>const &); template vec<2, bool> lessThanEqual(vec<2, int>const &, vec<2, int>const &); template vec<2, bool> greaterThan(vec<2, int>const &, vec<2, int>const &); template vec<2, bool> greaterThanEqual(vec<2, int>const &, vec<2, int>const &); template vec<2, bool> equal(vec<2, int>const &, vec<2, int>const &); template vec<2, bool> notEqual(vec<2, int>const &, vec<2, int>const &); template bool any(vec<2, bool>const &); template bool all(vec<2, bool>const &); template vec<2, bool> not_(vec<2, bool>const &); template vec<2, bool> lessThan(vec<2, unsigned>const &, vec<2, unsigned>const &); template vec<2, bool> lessThanEqual(vec<2, unsigned>const &, vec<2, unsigned>const &); template vec<2, bool> greaterThan(vec<2, unsigned>const &, vec<2, unsigned>const &); template vec<2, bool> greaterThanEqual(vec<2, unsigned>const &, vec<2, unsigned>const &); template vec<2, bool> equal(vec<2, unsigned>const &, vec<2, unsigned>const &); template vec<2, bool> notEqual(vec<2, unsigned>const &, vec<2, unsigned>const &); template bool any(vec<2, bool>const &); template bool all(vec<2, bool>const &); template vec<2, bool> not_(vec<2, bool>const &); template vec<3, bool> lessThan(vec<3, double>const &, vec<3, double>const &); template vec<3, bool> lessThanEqual(vec<3, double>const &, vec<3, double>const &); template vec<3, bool> greaterThan(vec<3, double>const &, vec<3, double>const &); template vec<3, bool> greaterThanEqual(vec<3, double>const &, vec<3, double>const &); template vec<3, bool> equal(vec<3, double>const &, vec<3, double>const &); template vec<3, bool> notEqual(vec<3, double>const &, vec<3, double>const &); template bool any(vec<3, bool>const &); template bool all(vec<3, bool>const &); template vec<3, bool> not_(vec<3, bool>const &); template vec<3, bool> lessThan(vec<3, float>const &, vec<3, float>const &); template vec<3, bool> lessThanEqual(vec<3, float>const &, vec<3, float>const &); template vec<3, bool> greaterThan(vec<3, float>const &, vec<3, float>const &); template vec<3, bool> greaterThanEqual(vec<3, float>const &, vec<3, float>const &); template vec<3, bool> equal(vec<3, float>const &, vec<3, float>const &); template vec<3, bool> notEqual(vec<3, float>const &, vec<3, float>const &); template bool any(vec<3, bool>const &); template bool all(vec<3, bool>const &); template vec<3, bool> not_(vec<3, bool>const &); template vec<3, bool> lessThan(vec<3, int>const &, vec<3, int>const &); template vec<3, bool> lessThanEqual(vec<3, int>const &, vec<3, int>const &); template vec<3, bool> greaterThan(vec<3, int>const &, vec<3, int>const &); template vec<3, bool> greaterThanEqual(vec<3, int>const &, vec<3, int>const &); template vec<3, bool> equal(vec<3, int>const &, vec<3, int>const &); template vec<3, bool> notEqual(vec<3, int>const &, vec<3, int>const &); template bool any(vec<3, bool>const &); template bool all(vec<3, bool>const &); template vec<3, bool> not_(vec<3, bool>const &); template vec<3, bool> lessThan(vec<3, unsigned>const &, vec<3, unsigned>const &); template vec<3, bool> lessThanEqual(vec<3, unsigned>const &, vec<3, unsigned>const &); template vec<3, bool> greaterThan(vec<3, unsigned>const &, vec<3, unsigned>const &); template vec<3, bool> greaterThanEqual(vec<3, unsigned>const &, vec<3, unsigned>const &); template vec<3, bool> equal(vec<3, unsigned>const &, vec<3, unsigned>const &); template vec<3, bool> notEqual(vec<3, unsigned>const &, vec<3, unsigned>const &); template bool any(vec<3, bool>const &); template bool all(vec<3, bool>const &); template vec<3, bool> not_(vec<3, bool>const &); template vec<4, bool> lessThan(vec<4, double>const &, vec<4, double>const &); template vec<4, bool> lessThanEqual(vec<4, double>const &, vec<4, double>const &); template vec<4, bool> greaterThan(vec<4, double>const &, vec<4, double>const &); template vec<4, bool> greaterThanEqual(vec<4, double>const &, vec<4, double>const &); template vec<4, bool> equal(vec<4, double>const &, vec<4, double>const &); template vec<4, bool> notEqual(vec<4, double>const &, vec<4, double>const &); template bool any(vec<4, bool>const &); template bool all(vec<4, bool>const &); template vec<4, bool> not_(vec<4, bool>const &); template vec<4, bool> lessThan(vec<4, float>const &, vec<4, float>const &); template vec<4, bool> lessThanEqual(vec<4, float>const &, vec<4, float>const &); template vec<4, bool> greaterThan(vec<4, float>const &, vec<4, float>const &); template vec<4, bool> greaterThanEqual(vec<4, float>const &, vec<4, float>const &); template vec<4, bool> equal(vec<4, float>const &, vec<4, float>const &); template vec<4, bool> notEqual(vec<4, float>const &, vec<4, float>const &); template bool any(vec<4, bool>const &); template bool all(vec<4, bool>const &); template vec<4, bool> not_(vec<4, bool>const &); template vec<4, bool> lessThan(vec<4, int>const &, vec<4, int>const &); template vec<4, bool> lessThanEqual(vec<4, int>const &, vec<4, int>const &); template vec<4, bool> greaterThan(vec<4, int>const &, vec<4, int>const &); template vec<4, bool> greaterThanEqual(vec<4, int>const &, vec<4, int>const &); template vec<4, bool> equal(vec<4, int>const &, vec<4, int>const &); template vec<4, bool> notEqual(vec<4, int>const &, vec<4, int>const &); template bool any(vec<4, bool>const &); template bool all(vec<4, bool>const &); template vec<4, bool> not_(vec<4, bool>const &); template vec<4, bool> lessThan(vec<4, unsigned>const &, vec<4, unsigned>const &); template vec<4, bool> lessThanEqual(vec<4, unsigned>const &, vec<4, unsigned>const &); template vec<4, bool> greaterThan(vec<4, unsigned>const &, vec<4, unsigned>const &); template vec<4, bool> greaterThanEqual(vec<4, unsigned>const &, vec<4, unsigned>const &); template vec<4, bool> equal(vec<4, unsigned>const &, vec<4, unsigned>const &); template vec<4, bool> notEqual(vec<4, unsigned>const &, vec<4, unsigned>const &); template bool any(vec<4, bool>const &); template bool all(vec<4, bool>const &); template vec<4, bool> not_(vec<4, bool>const &);

}
#line 1 "C:\\Projects\\glm\\glm\\detail/func_geometric.inl"
#line 1 "C:\\Projects\\glm\\glm\\detail\\../exponential.hpp"














#pragma once





namespace glm
{
	
	

	
	
	
	
	
	
	
	template<typename genType>
	 genType pow(genType base, genType exponent);
	template<length_t L, typename T>
	 vec<L, T> pow(vec<L, T> const& base, vec<L, T> const& exponent);

	
	
	
	
	
	
	
	
	template<typename genType>
	 genType exp(genType v);
	template<length_t L, typename T>
	 vec<L, T> exp(vec<L, T> const& v);

	
	
	
	
	
	
	
	
	
	
	template<typename genType>
	 genType log(genType v);
	template<length_t L, typename T>
	 vec<L, T> log(vec<L, T> const& v);

	
	
	
	
	
	
	
	
	template<typename genType>
	 genType exp2(genType v);
	template<length_t L, typename T>
	 vec<L, T> exp2(vec<L, T> const& v);

	
	
	
	
	
	
	
	
	
	template<typename genType>
	 genType log2(genType v);
	template<length_t L, typename T>
	 vec<L, T> log2(vec<L, T> const& v);

	
	
	
	
	
	
	
	
	template<typename genType>
	 genType sqrt(genType v);
	template<length_t L, typename T>
	 vec<L, T> sqrt(vec<L, T> const& v);

	
	
	
	
	
	
	
	
	template<typename genType>
	 genType inversesqrt(genType v);
	template<length_t L, typename T>
	 vec<L, T> inversesqrt(vec<L, T> const& v);

	
}
#line 2 "C:\\Projects\\glm\\glm\\detail/func_geometric.inl"
#line 1 "C:\\Projects\\glm\\glm\\detail\\../common.hpp"














#pragma once

#line 1 "C:\\Projects\\glm\\glm\\detail/_fixes.hpp"
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\cmath"





#pragma once







#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4472 4494 4514 4571 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4702 4793 4820 4988 5026 5027 5045  4984 5053 )




[[nodiscard]]   inline double pow(  double _Xx,   int _Yx) noexcept  {
    if (_Yx == 2) {
        return _Xx * _Xx;
    }

    return :: pow(_Xx, static_cast<double>(_Yx));
}

[[nodiscard]]   inline float acos(  float _Xx) noexcept  {
    return :: acosf(_Xx);
}

[[nodiscard]]   inline float acosh(  float _Xx) noexcept  {
    return :: acoshf(_Xx);
}

[[nodiscard]]   inline float asin(  float _Xx) noexcept  {
    return :: asinf(_Xx);
}

[[nodiscard]]   inline float asinh(  float _Xx) noexcept  {
    return :: asinhf(_Xx);
}

[[nodiscard]]   inline float atan(  float _Xx) noexcept  {
    return :: atanf(_Xx);
}

[[nodiscard]]   inline float atanh(  float _Xx) noexcept  {
    return :: atanhf(_Xx);
}

[[nodiscard]]   inline float atan2(  float _Yx,   float _Xx) noexcept  {
    return :: atan2f(_Yx, _Xx);
}

[[nodiscard]]   inline float cbrt(  float _Xx) noexcept  {
    return :: cbrtf(_Xx);
}

[[nodiscard]]   inline float ceil(  float _Xx) noexcept  {
    return :: ceilf(_Xx);
}

[[nodiscard]]   inline float copysign(  float _Number,   float _Sign) noexcept  {
    return :: copysignf(_Number, _Sign);
}

[[nodiscard]]   inline float cos(  float _Xx) noexcept  {
    return :: cosf(_Xx);
}

[[nodiscard]]   inline float cosh(  float _Xx) noexcept  {
    return :: coshf(_Xx);
}

[[nodiscard]]   inline float erf(  float _Xx) noexcept  {
    return :: erff(_Xx);
}

[[nodiscard]]   inline float erfc(  float _Xx) noexcept  {
    return :: erfcf(_Xx);
}

[[nodiscard]]   inline float exp(  float _Xx) noexcept  {
    return :: expf(_Xx);
}

[[nodiscard]]   inline float exp2(  float _Xx) noexcept  {
    return :: exp2f(_Xx);
}

[[nodiscard]]   inline float expm1(  float _Xx) noexcept  {
    return :: expm1f(_Xx);
}

[[nodiscard]]   inline float fabs(  float _Xx) noexcept  {
    return :: fabsf(_Xx);
}

[[nodiscard]]   inline float fdim(  float _Xx,   float _Yx) noexcept  {
    return :: fdimf(_Xx, _Yx);
}

[[nodiscard]]   inline float floor(  float _Xx) noexcept  {
    return :: floorf(_Xx);
}

[[nodiscard]]   inline float fma(  float _Xx,   float _Yx,   float _Zx) noexcept  {
    return :: fmaf(_Xx, _Yx, _Zx);
}

[[nodiscard]]   inline float fmax(  float _Xx,   float _Yx) noexcept  {
    return :: fmaxf(_Xx, _Yx);
}

[[nodiscard]]   inline float fmin(  float _Xx,   float _Yx) noexcept  {
    return :: fminf(_Xx, _Yx);
}

[[nodiscard]]   inline float fmod(  float _Xx,   float _Yx) noexcept  {
    return :: fmodf(_Xx, _Yx);
}

inline float frexp(  float _Xx,   int* _Yx) noexcept  {
    return :: frexpf(_Xx, _Yx);
}

[[nodiscard]]   inline float hypot(  float _Xx,   float _Yx) noexcept  {
    return :: hypotf(_Xx, _Yx);
}

[[nodiscard]]   inline int ilogb(  float _Xx) noexcept  {
    return :: ilogbf(_Xx);
}

[[nodiscard]]   inline float ldexp(  float _Xx,   int _Yx) noexcept  {
    return :: ldexpf(_Xx, _Yx);
}

[[nodiscard]]   inline float lgamma(  float _Xx) noexcept  {
    return :: lgammaf(_Xx);
}

[[nodiscard]]   inline long long llrint(  float _Xx) noexcept  {
    return :: llrintf(_Xx);
}

[[nodiscard]]   inline long long llround(  float _Xx) noexcept  {
    return :: llroundf(_Xx);
}

[[nodiscard]]   inline float log(  float _Xx) noexcept  {
    return :: logf(_Xx);
}

[[nodiscard]]   inline float log10(  float _Xx) noexcept  {
    return :: log10f(_Xx);
}

[[nodiscard]]   inline float log1p(  float _Xx) noexcept  {
    return :: log1pf(_Xx);
}

[[nodiscard]]   inline float log2(  float _Xx) noexcept  {
    return :: log2f(_Xx);
}

[[nodiscard]]   inline float logb(  float _Xx) noexcept  {
    return :: logbf(_Xx);
}

[[nodiscard]]   inline long lrint(  float _Xx) noexcept  {
    return :: lrintf(_Xx);
}

[[nodiscard]]   inline long lround(  float _Xx) noexcept  {
    return :: lroundf(_Xx);
}

inline float modf(  float _Xx,   float* _Yx) noexcept  {
    return :: modff(_Xx, _Yx);
}

[[nodiscard]]   inline float nearbyint(  float _Xx) noexcept  {
    return :: nearbyintf(_Xx);
}

[[nodiscard]]   inline float nextafter(  float _Xx,   float _Yx) noexcept  {
    return :: nextafterf(_Xx, _Yx);
}

[[nodiscard]]   inline float nexttoward(  float _Xx,   long double _Yx) noexcept  {
    return :: nexttowardf(_Xx, _Yx);
}

[[nodiscard]]   inline float pow(  float _Xx,   float _Yx) noexcept  {
    return :: powf(_Xx, _Yx);
}

[[nodiscard]]   inline float pow(  float _Xx,   int _Yx) noexcept  {
    if (_Yx == 2) {
        return _Xx * _Xx;
    }

    return :: powf(_Xx, static_cast<float>(_Yx));
}

[[nodiscard]]   inline float remainder(  float _Xx,   float _Yx) noexcept  {
    return :: remainderf(_Xx, _Yx);
}

inline float remquo(  float _Xx,   float _Yx,   int* _Zx) noexcept  {
    return :: remquof(_Xx, _Yx, _Zx);
}

[[nodiscard]]   inline float rint(  float _Xx) noexcept  {
    return :: rintf(_Xx);
}

[[nodiscard]]   inline float round(  float _Xx) noexcept  {
    return :: roundf(_Xx);
}

[[nodiscard]]   inline float scalbln(  float _Xx,   long _Yx) noexcept  {
    return :: scalblnf(_Xx, _Yx);
}

[[nodiscard]]   inline float scalbn(  float _Xx,   int _Yx) noexcept  {
    return :: scalbnf(_Xx, _Yx);
}

[[nodiscard]]   inline float sin(  float _Xx) noexcept  {
    return :: sinf(_Xx);
}

[[nodiscard]]   inline float sinh(  float _Xx) noexcept  {
    return :: sinhf(_Xx);
}

[[nodiscard]]   inline float sqrt(  float _Xx) noexcept  {
    return :: sqrtf(_Xx);
}

[[nodiscard]]   inline float tan(  float _Xx) noexcept  {
    return :: tanf(_Xx);
}

[[nodiscard]]   inline float tanh(  float _Xx) noexcept  {
    return :: tanhf(_Xx);
}

[[nodiscard]]   inline float tgamma(  float _Xx) noexcept  {
    return :: tgammaf(_Xx);
}

[[nodiscard]]   inline float trunc(  float _Xx) noexcept  {
    return :: truncf(_Xx);
}

[[nodiscard]]   inline long double acos(  long double _Xx) noexcept  {
    return :: acosl(_Xx);
}

[[nodiscard]]   inline long double acosh(  long double _Xx) noexcept  {
    return :: acoshl(_Xx);
}

[[nodiscard]]   inline long double asin(  long double _Xx) noexcept  {
    return :: asinl(_Xx);
}

[[nodiscard]]   inline long double asinh(  long double _Xx) noexcept  {
    return :: asinhl(_Xx);
}

[[nodiscard]]   inline long double atan(  long double _Xx) noexcept  {
    return :: atanl(_Xx);
}

[[nodiscard]]   inline long double atanh(  long double _Xx) noexcept  {
    return :: atanhl(_Xx);
}

[[nodiscard]]   inline long double atan2(
      long double _Yx,   long double _Xx) noexcept  {
    return :: atan2l(_Yx, _Xx);
}

[[nodiscard]]   inline long double cbrt(  long double _Xx) noexcept  {
    return :: cbrtl(_Xx);
}

[[nodiscard]]   inline long double ceil(  long double _Xx) noexcept  {
    return :: ceill(_Xx);
}

[[nodiscard]]   inline long double copysign(
      long double _Number,   long double _Sign) noexcept  {
    return :: copysignl(_Number, _Sign);
}

[[nodiscard]]   inline long double cos(  long double _Xx) noexcept  {
    return :: cosl(_Xx);
}

[[nodiscard]]   inline long double cosh(  long double _Xx) noexcept  {
    return :: coshl(_Xx);
}

[[nodiscard]]   inline long double erf(  long double _Xx) noexcept  {
    return :: erfl(_Xx);
}

[[nodiscard]]   inline long double erfc(  long double _Xx) noexcept  {
    return :: erfcl(_Xx);
}

[[nodiscard]]   inline long double exp(  long double _Xx) noexcept  {
    return :: expl(_Xx);
}

[[nodiscard]]   inline long double exp2(  long double _Xx) noexcept  {
    return :: exp2l(_Xx);
}

[[nodiscard]]   inline long double expm1(  long double _Xx) noexcept  {
    return :: expm1l(_Xx);
}

[[nodiscard]]   inline long double fabs(  long double _Xx) noexcept  {
    return :: fabsl(_Xx);
}

[[nodiscard]]   inline long double fdim(
      long double _Xx,   long double _Yx) noexcept  {
    return :: fdiml(_Xx, _Yx);
}

[[nodiscard]]   inline long double floor(  long double _Xx) noexcept  {
    return :: floorl(_Xx);
}

[[nodiscard]]   inline long double fma(
      long double _Xx,   long double _Yx,   long double _Zx) noexcept  {
    return :: fmal(_Xx, _Yx, _Zx);
}

[[nodiscard]]   inline long double fmax(
      long double _Xx,   long double _Yx) noexcept  {
    return :: fmaxl(_Xx, _Yx);
}

[[nodiscard]]   inline long double fmin(
      long double _Xx,   long double _Yx) noexcept  {
    return :: fminl(_Xx, _Yx);
}

[[nodiscard]]   inline long double fmod(
      long double _Xx,   long double _Yx) noexcept  {
    return :: fmodl(_Xx, _Yx);
}

inline long double frexp(  long double _Xx,   int* _Yx) noexcept  {
    return :: frexpl(_Xx, _Yx);
}

[[nodiscard]]   inline long double hypot(
      long double _Xx,   long double _Yx) noexcept  {
    return :: hypotl(_Xx, _Yx);
}

[[nodiscard]]   inline int ilogb(  long double _Xx) noexcept  {
    return :: ilogbl(_Xx);
}

[[nodiscard]]   inline long double ldexp(  long double _Xx,   int _Yx) noexcept  {
    return :: ldexpl(_Xx, _Yx);
}

[[nodiscard]]   inline long double lgamma(  long double _Xx) noexcept  {
    return :: lgammal(_Xx);
}

[[nodiscard]]   inline long long llrint(  long double _Xx) noexcept  {
    return :: llrintl(_Xx);
}

[[nodiscard]]   inline long long llround(  long double _Xx) noexcept  {
    return :: llroundl(_Xx);
}

[[nodiscard]]   inline long double log(  long double _Xx) noexcept  {
    return :: logl(_Xx);
}

[[nodiscard]]   inline long double log10(  long double _Xx) noexcept  {
    return :: log10l(_Xx);
}

[[nodiscard]]   inline long double log1p(  long double _Xx) noexcept  {
    return :: log1pl(_Xx);
}

[[nodiscard]]   inline long double log2(  long double _Xx) noexcept  {
    return :: log2l(_Xx);
}

[[nodiscard]]   inline long double logb(  long double _Xx) noexcept  {
    return :: logbl(_Xx);
}

[[nodiscard]]   inline long lrint(  long double _Xx) noexcept  {
    return :: lrintl(_Xx);
}

[[nodiscard]]   inline long lround(  long double _Xx) noexcept  {
    return :: lroundl(_Xx);
}

inline long double modf(  long double _Xx,   long double* _Yx) noexcept  {
    return :: modfl(_Xx, _Yx);
}

[[nodiscard]]   inline long double nearbyint(  long double _Xx) noexcept  {
    return :: nearbyintl(_Xx);
}

[[nodiscard]]   inline long double nextafter(
      long double _Xx,   long double _Yx) noexcept  {
    return :: nextafterl(_Xx, _Yx);
}

[[nodiscard]]   inline long double nexttoward(
      long double _Xx,   long double _Yx) noexcept  {
    return :: nexttowardl(_Xx, _Yx);
}

[[nodiscard]]   inline long double pow(
      long double _Xx,   long double _Yx) noexcept  {
    return :: powl(_Xx, _Yx);
}

[[nodiscard]]   inline long double pow(  long double _Xx,   int _Yx) noexcept  {
    if (_Yx == 2) {
        return _Xx * _Xx;
    }

    return :: powl(_Xx, static_cast<long double>(_Yx));
}

[[nodiscard]]   inline long double remainder(
      long double _Xx,   long double _Yx) noexcept  {
    return :: remainderl(_Xx, _Yx);
}

inline long double remquo(  long double _Xx,   long double _Yx,   int* _Zx) noexcept  {
    return :: remquol(_Xx, _Yx, _Zx);
}

[[nodiscard]]   inline long double rint(  long double _Xx) noexcept  {
    return :: rintl(_Xx);
}

[[nodiscard]]   inline long double round(  long double _Xx) noexcept  {
    return :: roundl(_Xx);
}

[[nodiscard]]   inline long double scalbln(  long double _Xx,   long _Yx) noexcept  {
    return :: scalblnl(_Xx, _Yx);
}

[[nodiscard]]   inline long double scalbn(  long double _Xx,   int _Yx) noexcept  {
    return :: scalbnl(_Xx, _Yx);
}

[[nodiscard]]   inline long double sin(  long double _Xx) noexcept  {
    return :: sinl(_Xx);
}

[[nodiscard]]   inline long double sinh(  long double _Xx) noexcept  {
    return :: sinhl(_Xx);
}

[[nodiscard]]   inline long double sqrt(  long double _Xx) noexcept  {
    return :: sqrtl(_Xx);
}

[[nodiscard]]   inline long double tan(  long double _Xx) noexcept  {
    return :: tanl(_Xx);
}

[[nodiscard]]   inline long double tanh(  long double _Xx) noexcept  {
    return :: tanhl(_Xx);
}

[[nodiscard]]   inline long double tgamma(  long double _Xx) noexcept  {
    return :: tgammal(_Xx);
}

[[nodiscard]]   inline long double trunc(  long double _Xx) noexcept  {
    return :: truncl(_Xx);
}

#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\xtgmath.h"





#pragma once








#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4472 4494 4514 4571 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4702 4793 4820 4988 5026 5027 5045  4984 5053 )




namespace std {
template <class _Ty1, class _Ty2>
using _Common_float_type_t = conditional_t<is_same_v<_Ty1, long double> || is_same_v<_Ty2, long double>, long double,
    conditional_t<is_same_v<_Ty1, float> && is_same_v<_Ty2, float>, float,
        double>>; 
}


template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>>
double frexp(_Ty _Value,   int* const _Exp) noexcept  {
    return :: frexp(static_cast<double>(_Value), _Exp);
}


template <class _Ty1, class _Ty2, class = ::std:: enable_if_t<::std:: is_arithmetic_v<_Ty1> && ::std:: is_arithmetic_v<_Ty2>>>
[[nodiscard]] ::std:: _Common_float_type_t<_Ty1, _Ty2> pow(const _Ty1 _Left, const _Ty2 _Right) noexcept  {
    using _Common = ::std:: _Common_float_type_t<_Ty1, _Ty2>;
    return :: pow(static_cast<_Common>(_Left), static_cast<_Common>(_Right));
}














#line 56 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\xtgmath.h"

template <class _Ty1, class _Ty2, class _Ty3,
    class = ::std:: enable_if_t<::std:: is_arithmetic_v<_Ty1> && ::std:: is_arithmetic_v<_Ty2> && ::std:: is_arithmetic_v<_Ty3>>>
[[nodiscard]] ::std:: _Common_float_type_t<_Ty1, ::std:: _Common_float_type_t<_Ty2, _Ty3>> fma(
    _Ty1 _Left, _Ty2 _Middle, _Ty3 _Right) noexcept  {
    using _Common = ::std:: _Common_float_type_t<_Ty1, ::std:: _Common_float_type_t<_Ty2, _Ty3>>;

    if constexpr (::std:: is_same_v<_Common, float>) {
        return :: fmaf(static_cast<_Common>(_Left), static_cast<_Common>(_Middle), static_cast<_Common>(_Right));
    } else if constexpr (::std:: is_same_v<_Common, double>) {
        return :: fma(static_cast<_Common>(_Left), static_cast<_Common>(_Middle), static_cast<_Common>(_Right));
    } else {
        return :: fmal(static_cast<_Common>(_Left), static_cast<_Common>(_Middle), static_cast<_Common>(_Right));
    }


#line 73 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\xtgmath.h"
}














#line 89 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\xtgmath.h"

template <class _Ty1, class _Ty2, class = ::std:: enable_if_t<::std:: is_arithmetic_v<_Ty1> && ::std:: is_arithmetic_v<_Ty2>>>
::std:: _Common_float_type_t<_Ty1, _Ty2> remquo(_Ty1 _Left, _Ty2 _Right, int* _Pquo) noexcept  {
    using _Common = ::std:: _Common_float_type_t<_Ty1, _Ty2>;

    if constexpr (::std:: is_same_v<_Common, float>) {
        return :: remquof(static_cast<_Common>(_Left), static_cast<_Common>(_Right), _Pquo);
    } else if constexpr (::std:: is_same_v<_Common, double>) {
        return :: remquo(static_cast<_Common>(_Left), static_cast<_Common>(_Right), _Pquo);
    } else {
        return :: remquol(static_cast<_Common>(_Left), static_cast<_Common>(_Right), _Pquo);
    }


#line 104 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\xtgmath.h"
}
























template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>> [[nodiscard]] double acos(_Ty _Left) noexcept { return :: acos(static_cast<double>(_Left)); }
template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>> [[nodiscard]] double asin(_Ty _Left) noexcept { return :: asin(static_cast<double>(_Left)); }
template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>> [[nodiscard]] double atan(_Ty _Left) noexcept { return :: atan(static_cast<double>(_Left)); }
template <class _Ty1, class _Ty2, class = ::std:: enable_if_t<::std:: is_arithmetic_v<_Ty1> && ::std:: is_arithmetic_v<_Ty2>>> [[nodiscard]] ::std:: _Common_float_type_t<_Ty1, _Ty2> atan2(_Ty1 _Left, _Ty2 _Right) noexcept { using _Common = ::std:: _Common_float_type_t<_Ty1, _Ty2>; return :: atan2(static_cast<_Common>(_Left), static_cast<_Common>(_Right)); }
template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>> [[nodiscard]] double cos(_Ty _Left) noexcept { return :: cos(static_cast<double>(_Left)); }
template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>> [[nodiscard]] double sin(_Ty _Left) noexcept { return :: sin(static_cast<double>(_Left)); }
template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>> [[nodiscard]] double tan(_Ty _Left) noexcept { return :: tan(static_cast<double>(_Left)); }
template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>> [[nodiscard]] double acosh(_Ty _Left) noexcept { return :: acosh(static_cast<double>(_Left)); }
template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>> [[nodiscard]] double asinh(_Ty _Left) noexcept { return :: asinh(static_cast<double>(_Left)); }
template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>> [[nodiscard]] double atanh(_Ty _Left) noexcept { return :: atanh(static_cast<double>(_Left)); }
template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>> [[nodiscard]] double cosh(_Ty _Left) noexcept { return :: cosh(static_cast<double>(_Left)); }
template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>> [[nodiscard]] double sinh(_Ty _Left) noexcept { return :: sinh(static_cast<double>(_Left)); }
template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>> [[nodiscard]] double tanh(_Ty _Left) noexcept { return :: tanh(static_cast<double>(_Left)); }
template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>> [[nodiscard]] double exp(_Ty _Left) noexcept { return :: exp(static_cast<double>(_Left)); }
template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>> [[nodiscard]] double exp2(_Ty _Left) noexcept { return :: exp2(static_cast<double>(_Left)); }
template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>> [[nodiscard]] double expm1(_Ty _Left) noexcept { return :: expm1(static_cast<double>(_Left)); }

template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>> [[nodiscard]] int ilogb(_Ty _Left) noexcept { return :: ilogb(static_cast<double>(_Left)); }
template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>> [[nodiscard]] double ldexp(_Ty _Left, int _Arg2) noexcept { return :: ldexp(static_cast<double>(_Left), _Arg2); }
template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>> [[nodiscard]] double log(_Ty _Left) noexcept { return :: log(static_cast<double>(_Left)); }
template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>> [[nodiscard]] double log10(_Ty _Left) noexcept { return :: log10(static_cast<double>(_Left)); }
template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>> [[nodiscard]] double log1p(_Ty _Left) noexcept { return :: log1p(static_cast<double>(_Left)); }
template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>> [[nodiscard]] double log2(_Ty _Left) noexcept { return :: log2(static_cast<double>(_Left)); }
template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>> [[nodiscard]] double logb(_Ty _Left) noexcept { return :: logb(static_cast<double>(_Left)); }

template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>> [[nodiscard]] double scalbn(_Ty _Left, int _Arg2) noexcept { return :: scalbn(static_cast<double>(_Left), _Arg2); }
template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>> [[nodiscard]] double scalbln(_Ty _Left, long _Arg2) noexcept { return :: scalbln(static_cast<double>(_Left), _Arg2); }
template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>> [[nodiscard]] double cbrt(_Ty _Left) noexcept { return :: cbrt(static_cast<double>(_Left)); }

template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>> [[nodiscard]] double fabs(_Ty _Left) noexcept { return :: fabs(static_cast<double>(_Left)); }
template <class _Ty1, class _Ty2, class = ::std:: enable_if_t<::std:: is_arithmetic_v<_Ty1> && ::std:: is_arithmetic_v<_Ty2>>> [[nodiscard]] ::std:: _Common_float_type_t<_Ty1, _Ty2> hypot(_Ty1 _Left, _Ty2 _Right) noexcept { using _Common = ::std:: _Common_float_type_t<_Ty1, _Ty2>; return :: hypot(static_cast<_Common>(_Left), static_cast<_Common>(_Right)); }


template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>> [[nodiscard]] double sqrt(_Ty _Left) noexcept { return :: sqrt(static_cast<double>(_Left)); }
template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>> [[nodiscard]] double erf(_Ty _Left) noexcept { return :: erf(static_cast<double>(_Left)); }
template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>> [[nodiscard]] double erfc(_Ty _Left) noexcept { return :: erfc(static_cast<double>(_Left)); }
template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>> [[nodiscard]] double lgamma(_Ty _Left) noexcept { return :: lgamma(static_cast<double>(_Left)); }
template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>> [[nodiscard]] double tgamma(_Ty _Left) noexcept { return :: tgamma(static_cast<double>(_Left)); }
template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>> [[nodiscard]] double ceil(_Ty _Left) noexcept { return :: ceil(static_cast<double>(_Left)); }
template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>> [[nodiscard]] double floor(_Ty _Left) noexcept { return :: floor(static_cast<double>(_Left)); }
template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>> [[nodiscard]] double nearbyint(_Ty _Left) noexcept { return :: nearbyint(static_cast<double>(_Left)); }
template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>> [[nodiscard]] double rint(_Ty _Left) noexcept { return :: rint(static_cast<double>(_Left)); }
template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>> [[nodiscard]] long lrint(_Ty _Left) noexcept { return :: lrint(static_cast<double>(_Left)); }
template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>> [[nodiscard]] long long llrint(_Ty _Left) noexcept { return :: llrint(static_cast<double>(_Left)); }
template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>> [[nodiscard]] double round(_Ty _Left) noexcept { return :: round(static_cast<double>(_Left)); }
template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>> [[nodiscard]] long lround(_Ty _Left) noexcept { return :: lround(static_cast<double>(_Left)); }
template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>> [[nodiscard]] long long llround(_Ty _Left) noexcept { return :: llround(static_cast<double>(_Left)); }
template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>> [[nodiscard]] double trunc(_Ty _Left) noexcept { return :: trunc(static_cast<double>(_Left)); }
template <class _Ty1, class _Ty2, class = ::std:: enable_if_t<::std:: is_arithmetic_v<_Ty1> && ::std:: is_arithmetic_v<_Ty2>>> [[nodiscard]] ::std:: _Common_float_type_t<_Ty1, _Ty2> fmod(_Ty1 _Left, _Ty2 _Right) noexcept { using _Common = ::std:: _Common_float_type_t<_Ty1, _Ty2>; return :: fmod(static_cast<_Common>(_Left), static_cast<_Common>(_Right)); }
template <class _Ty1, class _Ty2, class = ::std:: enable_if_t<::std:: is_arithmetic_v<_Ty1> && ::std:: is_arithmetic_v<_Ty2>>> [[nodiscard]] ::std:: _Common_float_type_t<_Ty1, _Ty2> remainder(_Ty1 _Left, _Ty2 _Right) noexcept { using _Common = ::std:: _Common_float_type_t<_Ty1, _Ty2>; return :: remainder(static_cast<_Common>(_Left), static_cast<_Common>(_Right)); }

template <class _Ty1, class _Ty2, class = ::std:: enable_if_t<::std:: is_arithmetic_v<_Ty1> && ::std:: is_arithmetic_v<_Ty2>>> [[nodiscard]] ::std:: _Common_float_type_t<_Ty1, _Ty2> copysign(_Ty1 _Left, _Ty2 _Right) noexcept { using _Common = ::std:: _Common_float_type_t<_Ty1, _Ty2>; return :: copysign(static_cast<_Common>(_Left), static_cast<_Common>(_Right)); }

template <class _Ty1, class _Ty2, class = ::std:: enable_if_t<::std:: is_arithmetic_v<_Ty1> && ::std:: is_arithmetic_v<_Ty2>>> [[nodiscard]] ::std:: _Common_float_type_t<_Ty1, _Ty2> nextafter(_Ty1 _Left, _Ty2 _Right) noexcept { using _Common = ::std:: _Common_float_type_t<_Ty1, _Ty2>; return :: nextafter(static_cast<_Common>(_Left), static_cast<_Common>(_Right)); }
template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>> [[nodiscard]] double nexttoward(_Ty _Left, long double _Arg2) noexcept { return :: nexttoward(static_cast<double>(_Left), _Arg2); }
template <class _Ty1, class _Ty2, class = ::std:: enable_if_t<::std:: is_arithmetic_v<_Ty1> && ::std:: is_arithmetic_v<_Ty2>>> [[nodiscard]] ::std:: _Common_float_type_t<_Ty1, _Ty2> fdim(_Ty1 _Left, _Ty2 _Right) noexcept { using _Common = ::std:: _Common_float_type_t<_Ty1, _Ty2>; return :: fdim(static_cast<_Common>(_Left), static_cast<_Common>(_Right)); }
template <class _Ty1, class _Ty2, class = ::std:: enable_if_t<::std:: is_arithmetic_v<_Ty1> && ::std:: is_arithmetic_v<_Ty2>>> [[nodiscard]] ::std:: _Common_float_type_t<_Ty1, _Ty2> fmax(_Ty1 _Left, _Ty2 _Right) noexcept { using _Common = ::std:: _Common_float_type_t<_Ty1, _Ty2>; return :: fmax(static_cast<_Common>(_Left), static_cast<_Common>(_Right)); }
template <class _Ty1, class _Ty2, class = ::std:: enable_if_t<::std:: is_arithmetic_v<_Ty1> && ::std:: is_arithmetic_v<_Ty2>>> [[nodiscard]] ::std:: _Common_float_type_t<_Ty1, _Ty2> fmin(_Ty1 _Left, _Ty2 _Right) noexcept { using _Common = ::std:: _Common_float_type_t<_Ty1, _Ty2>; return :: fmin(static_cast<_Common>(_Left), static_cast<_Common>(_Right)); }












#pragma warning(pop)
#pragma pack(pop)
#line 202 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\xtgmath.h"
#line 203 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\xtgmath.h"
#line 506 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\cmath"

namespace std {
using :: abs;
using :: acos;
using :: asin;
using :: atan;
using :: atan2;
using :: ceil;
using :: cos;
using :: cosh;
using :: exp;
using :: fabs;
using :: floor;
using :: fmod;
using :: frexp;
using :: ldexp;
using :: log;
using :: log10;
using :: modf;
using :: pow;
using :: sin;
using :: sinh;
using :: sqrt;
using :: tan;
using :: tanh;

using :: acosf;
using :: asinf;
using :: atanf;
using :: atan2f;
using :: ceilf;
using :: cosf;
using :: coshf;
using :: expf;
using :: fabsf;
using :: floorf;
using :: fmodf;
using :: frexpf;
using :: ldexpf;
using :: logf;
using :: log10f;
using :: modff;
using :: powf;
using :: sinf;
using :: sinhf;
using :: sqrtf;
using :: tanf;
using :: tanhf;

using :: acosl;
using :: asinl;
using :: atanl;
using :: atan2l;
using :: ceill;
using :: cosl;
using :: coshl;
using :: expl;
using :: fabsl;
using :: floorl;
using :: fmodl;
using :: frexpl;
using :: ldexpl;
using :: logl;
using :: log10l;
using :: modfl;
using :: powl;
using :: sinl;
using :: sinhl;
using :: sqrtl;
using :: tanl;
using :: tanhl;

using :: float_t;
using :: double_t;

using :: acosh;
using :: asinh;
using :: atanh;
using :: cbrt;
using :: erf;
using :: erfc;
using :: expm1;
using :: exp2;
using :: hypot;
using :: ilogb;
using :: lgamma;
using :: log1p;
using :: log2;
using :: logb;
using :: llrint;
using :: lrint;
using :: nearbyint;
using :: rint;
using :: llround;
using :: lround;
using :: fdim;
using :: fma;
using :: fmax;
using :: fmin;
using :: round;
using :: trunc;
using :: remainder;
using :: remquo;
using :: copysign;
using :: nan;
using :: nextafter;
using :: scalbn;
using :: scalbln;
using :: nexttoward;
using :: tgamma;

using :: acoshf;
using :: asinhf;
using :: atanhf;
using :: cbrtf;
using :: erff;
using :: erfcf;
using :: expm1f;
using :: exp2f;
using :: hypotf;
using :: ilogbf;
using :: lgammaf;
using :: log1pf;
using :: log2f;
using :: logbf;
using :: llrintf;
using :: lrintf;
using :: nearbyintf;
using :: rintf;
using :: llroundf;
using :: lroundf;
using :: fdimf;
using :: fmaf;
using :: fmaxf;
using :: fminf;
using :: roundf;
using :: truncf;
using :: remainderf;
using :: remquof;
using :: copysignf;
using :: nanf;
using :: nextafterf;
using :: scalbnf;
using :: scalblnf;
using :: nexttowardf;
using :: tgammaf;

using :: acoshl;
using :: asinhl;
using :: atanhl;
using :: cbrtl;
using :: erfl;
using :: erfcl;
using :: expm1l;
using :: exp2l;
using :: hypotl;
using :: ilogbl;
using :: lgammal;
using :: log1pl;
using :: log2l;
using :: logbl;
using :: llrintl;
using :: lrintl;
using :: nearbyintl;
using :: rintl;
using :: llroundl;
using :: lroundl;
using :: fdiml;
using :: fmal;
using :: fmaxl;
using :: fminl;
using :: roundl;
using :: truncl;
using :: remainderl;
using :: remquol;
using :: copysignl;
using :: nanl;
using :: nextafterl;
using :: scalbnl;
using :: scalblnl;
using :: nexttowardl;
using :: tgammal;

using :: fpclassify;
using :: signbit;
using :: isfinite;
using :: isinf;
using :: isnan;
using :: isnormal;
using :: isgreater;
using :: isgreaterequal;
using :: isless;
using :: islessequal;
using :: islessgreater;
using :: isunordered;
}













































































































































































































































































































































































































































































































































#line 1228 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\cmath"



#pragma warning(pop)
#pragma pack(pop)

#line 1235 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\cmath"
#line 1236 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.24.28314\\include\\cmath"
#line 2 "C:\\Projects\\glm\\glm\\detail/_fixes.hpp"


























#line 18 "C:\\Projects\\glm\\glm\\detail\\../common.hpp"


namespace glm
{
	
	

	
	
	
	
	
	
	template<typename genType>
	 constexpr genType abs(genType x);

	
	
	
	
	
	
	
	
	template<length_t L, typename T>
	 constexpr vec<L, T> abs(vec<L, T> const& x);

	
	
	
	
	
	
	
	
	template<typename genType>
	 genType sign(genType x);
	template<length_t L, typename T>
	 vec<L, T> sign(vec<L, T> const& x);

	
	
	
	
	
	
	
	
	template<typename genType>
	 genType floor(genType x);
	template<length_t L, typename T>
	 vec<L, T> floor(vec<L, T> const& x);

	
	
	
	
	
	
	
	
	
	template<length_t L, typename T>
	 vec<L, T> trunc(vec<L, T> const& x);

	
	
	
	
	
	
	
	
	
	
	
	
	template<typename genType>
	 genType round(genType x);
	template<length_t L, typename T>
	 vec<L, T> round(vec<L, T> const& x);

	
	
	
	
	
	
	
	
	
	
	
	template<typename genType>
	 genType roundEven(genType x);
	template<length_t L, typename T>
	 vec<L, T> roundEven(vec<L, T> const& x);

	
	
	
	
	
	
	
	
	

	template<length_t L, typename T>
	 vec<L, T> ceil(vec<L, T> const& x);

	
	
	
	
	
	
	template<typename genType>
	 genType fract(genType x);

	
	
	
	
	
	
	
	
	template<length_t L, typename T>
	 vec<L, T> fract(vec<L, T> const& x);

	template<typename genType>
	 genType mod(genType x, genType y);

	template<length_t L, typename T>
	 vec<L, T> mod(vec<L, T> const& x, T y);

	
	
	
	
	
	
	
	
	
	template<length_t L, typename T>
	 vec<L, T> mod(vec<L, T> const& x, vec<L, T> const& y);

	
	
	
	
	
	
	
	
	
	template<typename genType>
	 genType modf(genType x, genType& i);
	template<typename T>
	 vec<2, T> modf(vec<2, T> const& x, vec<2, T>& i);
	template<typename T>
	 vec<3, T> modf(vec<3, T> const& x, vec<3, T>& i);
	template<typename T>
	 vec<4, T> modf(vec<4, T> const& x, vec<4, T>& i);

	
	
	
	
	
	
	template<typename genType>
	 constexpr genType min(genType x, genType y);

	
	
	
	
	
	
	
	
	template<length_t L, typename T>
	 constexpr vec<L, T> min(vec<L, T> const& x, T y);

	
	
	
	
	
	
	
	
	template<length_t L, typename T>
	 constexpr vec<L, T> min(vec<L, T> const& x, vec<L, T> const& y);

	
	
	
	
	
	
	template<typename genType>
	 constexpr genType max(genType x, genType y);

	
	
	
	
	
	
	
	
	template<length_t L, typename T>
	 constexpr vec<L, T> max(vec<L, T> const& x, T y);

	
	
	
	
	
	
	
	
	template<length_t L, typename T>
	 constexpr vec<L, T> max(vec<L, T> const& x, vec<L, T> const& y);

	
	
	
	
	
	
	
	template<typename genType>
	 constexpr genType clamp(genType x, genType minVal, genType maxVal);

	
	
	
	
	
	
	
	
	
	template<length_t L, typename T>
	 constexpr vec<L, T> clamp(vec<L, T> const& x, T minVal, T maxVal);

	
	
	
	
	
	
	
	
	
	template<length_t L, typename T>
	 constexpr vec<L, T> clamp(vec<L, T> const& x, vec<L, T> const& minVal, vec<L, T> const& maxVal);

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	template<typename genTypeT, typename genTypeU>
	 genTypeT mix(genTypeT x, genTypeT y, genTypeU a);

	template<length_t L, typename T, typename U>
	 vec<L, T> mix(vec<L, T> const& x, vec<L, T> const& y, vec<L, U> const& a);

	template<length_t L, typename T, typename U>
	 vec<L, T> mix(vec<L, T> const& x, vec<L, T> const& y, U a);

	
	
	
	
	template<typename genType>
	 genType step(genType edge, genType x);

	
	
	
	
	
	
	
	
	template<length_t L, typename T>
	 vec<L, T> step(T edge, vec<L, T> const& x);

	
	
	
	
	
	
	
	
	template<length_t L, typename T>
	 vec<L, T> step(vec<L, T> const& edge, vec<L, T> const& x);

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	template<typename genType>
	 genType smoothstep(genType edge0, genType edge1, genType x);

	template<length_t L, typename T>
	 vec<L, T> smoothstep(T edge0, T edge1, vec<L, T> const& x);

	template<length_t L, typename T>
	 vec<L, T> smoothstep(vec<L, T> const& edge0, vec<L, T> const& edge1, vec<L, T> const& x);

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	template<typename genType>
	 bool isnan(genType x);
	template<length_t L, typename T>
	 vec<L, bool> isnan(vec<L, T> const& x);

	
	
	
	
	
	
	
	
	
	
	
	
	template<typename genType>
	 bool isinf(genType x);
	template<length_t L, typename T>
	 vec<L, bool> isinf(vec<L, T> const& x);

	
	
	
	
	
	
	 int floatBitsToInt(float const& v);

	
	
	
	
	
	
	
	
	
	template<length_t L>
	 vec<L, int> floatBitsToInt(vec<L, float> const& v);

	
	
	
	
	
	
	 uint floatBitsToUint(float const& v);

	
	
	
	
	
	
	
	
	
	template<length_t L>
	 vec<L, uint> floatBitsToUint(vec<L, float> const& v);

	
	
	
	
	
	
	
	
	 float intBitsToFloat(int const& v);

	
	
	
	
	
	
	
	
	
	
	
	template<length_t L>
	 vec<L, float> intBitsToFloat(vec<L, int> const& v);

	
	
	
	
	
	
	
	
	 float uintBitsToFloat(uint const& v);

	
	
	
	
	
	
	
	
	
	
	
	template<length_t L>
	 vec<L, float> uintBitsToFloat(vec<L, uint> const& v);

	
	
	
	
	
	
	template<typename genType>
	 genType fma(genType const& a, genType const& b, genType const& c);

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	template<typename genType>
	 genType frexp(genType x, int& exp);
	
	template<length_t L, typename T>
	 vec<L, T> frexp(vec<L, T> const& v, vec<L, int>& exp);

	
	
	
	
	
	
	
	
	
	
	
	template<typename genType>
	 genType ldexp(genType const& x, int const& exp);
	
	template<length_t L, typename T>
	 vec<L, T> ldexp(vec<L, T> const& v, vec<L, int> const& exp);

	
}


#line 3 "C:\\Projects\\glm\\glm\\detail/func_geometric.inl"








#line 12 "C:\\Projects\\glm\\glm\\detail/func_geometric.inl"

namespace glm{
namespace detail
{
	template<length_t L, typename T, bool Aligned>
	struct compute_length
	{
		 static T call(vec<L, T> const& v)
		{
			return sqrt(dot(v, v));
		}
	};

	template<length_t L, typename T, bool Aligned>
	struct compute_distance
	{
		 static T call(vec<L, T> const& p0, vec<L, T> const& p1)
		{
			return length(p1 - p0);
		}
	};

	template<typename V, typename T, bool Aligned>
	struct compute_dot{};

	template<typename T, bool Aligned>
	struct compute_dot<vec<1, T>, T, Aligned>
	{
		 static T call(vec<1, T> const& a, vec<1, T> const& b)
		{
			return a.x * b.x;
		}
	};

	template<typename T, bool Aligned>
	struct compute_dot<vec<2, T>, T, Aligned>
	{
		 static T call(vec<2, T> const& a, vec<2, T> const& b)
		{
			vec<2, T> tmp(a * b);
			return tmp.x + tmp.y;
		}
	};

	template<typename T, bool Aligned>
	struct compute_dot<vec<3, T>, T, Aligned>
	{
		 static T call(vec<3, T> const& a, vec<3, T> const& b)
		{
			vec<3, T> tmp(a * b);
			return tmp.x + tmp.y + tmp.z;
		}
	};

	template<typename T, bool Aligned>
	struct compute_dot<vec<4, T>, T, Aligned>
	{
		 static T call(vec<4, T> const& a, vec<4, T> const& b)
		{
			vec<4, T> tmp(a * b);
			return (tmp.x + tmp.y) + (tmp.z + tmp.w);
		}
	};

	template<typename T, bool Aligned>
	struct compute_cross
	{
		 static vec<3, T> call(vec<3, T> const& x, vec<3, T> const& y)
		{
			static_assert(std::numeric_limits<T>::is_iec559, "'cross' accepts only floating-point inputs");

			return vec<3, T>(
				x.y * y.z - y.y * x.z,
				x.z * y.x - y.z * x.x,
				x.x * y.y - y.x * x.y);
		}
	};

	template<length_t L, typename T, bool Aligned>
	struct compute_normalize
	{
		 static vec<L, T> call(vec<L, T> const& v)
		{
			static_assert(std::numeric_limits<T>::is_iec559, "'normalize' accepts only floating-point inputs");

			return v * inversesqrt(dot(v, v));
		}
	};

	template<length_t L, typename T, bool Aligned>
	struct compute_faceforward
	{
		 static vec<L, T> call(vec<L, T> const& N, vec<L, T> const& I, vec<L, T> const& Nref)
		{
			static_assert(std::numeric_limits<T>::is_iec559, "'normalize' accepts only floating-point inputs");

			return dot(Nref, I) < static_cast<T>(0) ? N : -N;
		}
	};

	template<length_t L, typename T, bool Aligned>
	struct compute_reflect
	{
		 static vec<L, T> call(vec<L, T> const& I, vec<L, T> const& N)
		{
			return I - N * dot(N, I) * static_cast<T>(2);
		}
	};

	template<length_t L, typename T, bool Aligned>
	struct compute_refract
	{
		 static vec<L, T> call(vec<L, T> const& I, vec<L, T> const& N, T eta)
		{
			T const dotValue(dot(N, I));
			T const k(static_cast<T>(1) - eta * eta * (static_cast<T>(1) - dotValue * dotValue));
			vec<L, T> const Result =
                (k >= static_cast<T>(0)) ? (eta * I - (eta * dotValue + std::sqrt(k)) * N) : vec<L, T>(0);
			return Result;
		}
	};
}

	
	template<typename genType>
	 genType length(genType x)
	{
		static_assert(std::numeric_limits<genType>::is_iec559, "'length' accepts only floating-point inputs");

		return abs(x);
	}

	template<length_t L, typename T>
	 T length(vec<L, T> const& v)
	{
		static_assert(std::numeric_limits<T>::is_iec559, "'length' accepts only floating-point inputs");

		return detail::compute_length<L, T, false>::call(v);
	}

	
	template<typename genType>
	 genType distance(genType const& p0, genType const& p1)
	{
		static_assert(std::numeric_limits<genType>::is_iec559, "'distance' accepts only floating-point inputs");

		return length(p1 - p0);
	}

	template<length_t L, typename T>
	 T distance(vec<L, T> const& p0, vec<L, T> const& p1)
	{
		return detail::compute_distance<L, T, false>::call(p0, p1);
	}

	
	template<typename T>
	 T dot(T x, T y)
	{
		static_assert(std::numeric_limits<T>::is_iec559, "'dot' accepts only floating-point inputs");
		return x * y;
	}

	template<length_t L, typename T>
	 T dot(vec<L, T> const& x, vec<L, T> const& y)
	{
		static_assert(std::numeric_limits<T>::is_iec559, "'dot' accepts only floating-point inputs");
		return detail::compute_dot<vec<L, T>, T, false>::call(x, y);
	}

	
	template<typename T>
	 vec<3, T> cross(vec<3, T> const& x, vec<3, T> const& y)
	{
		return detail::compute_cross<T, false>::call(x, y);
	}










	template<length_t L, typename T>
	 vec<L, T> normalize(vec<L, T> const& x)
	{
		static_assert(std::numeric_limits<T>::is_iec559, "'normalize' accepts only floating-point inputs");

		return detail::compute_normalize<L, T, false>::call(x);
	}

	
	template<typename genType>
	 genType faceforward(genType const& N, genType const& I, genType const& Nref)
	{
		return dot(Nref, I) < static_cast<genType>(0) ? N : -N;
	}

	template<length_t L, typename T>
	 vec<L, T> faceforward(vec<L, T> const& N, vec<L, T> const& I, vec<L, T> const& Nref)
	{
		return detail::compute_faceforward<L, T, false>::call(N, I, Nref);
	}

	
	template<typename genType>
	 genType reflect(genType const& I, genType const& N)
	{
		return I - N * dot(N, I) * genType(2);
	}

	template<length_t L, typename T>
	 vec<L, T> reflect(vec<L, T> const& I, vec<L, T> const& N)
	{
		return detail::compute_reflect<L, T, false>::call(I, N);
	}

	
	template<typename genType>
	 genType refract(genType const& I, genType const& N, genType eta)
	{
		static_assert(std::numeric_limits<genType>::is_iec559, "'refract' accepts only floating-point inputs");
		genType const dotValue(dot(N, I));
		genType const k(static_cast<genType>(1) - eta * eta * (static_cast<genType>(1) - dotValue * dotValue));
		return (eta * I - (eta * dotValue + sqrt(k)) * N) * static_cast<genType>(k >= static_cast<genType>(0));
	}

	template<length_t L, typename T>
	 vec<L, T> refract(vec<L, T> const& I, vec<L, T> const& N, T eta)
	{
		static_assert(std::numeric_limits<T>::is_iec559, "'refract' accepts only floating-point inputs");
		return detail::compute_refract<L, T, false>::call(I, N, eta);
	}
}



#line 253 "C:\\Projects\\glm\\glm\\detail/func_geometric.inl"
#line 62 ".\\glm_impl.cpp"
namespace glm {








	template double length(vec<2, double>const&); template double distance(vec<2, double>const&, vec<2, double>const&); template vec<3, double> cross(vec<3, double>const&, vec<3, double>const&); template vec<2, double> normalize(vec<2, double>const&); template vec<2, double> faceforward(vec<2, double>const&, vec<2, double>const&, vec<2, double>const&); template vec<2, double> reflect(vec<2, double>const&, vec<2, double>const&); template vec<2, double> refract(vec<2, double>const&, vec<2, double>const&, double); template float length(vec<2, float>const&); template float distance(vec<2, float>const&, vec<2, float>const&); template vec<3, float> cross(vec<3, float>const&, vec<3, float>const&); template vec<2, float> normalize(vec<2, float>const&); template vec<2, float> faceforward(vec<2, float>const&, vec<2, float>const&, vec<2, float>const&); template vec<2, float> reflect(vec<2, float>const&, vec<2, float>const&); template vec<2, float> refract(vec<2, float>const&, vec<2, float>const&, float); template double length(vec<3, double>const&); template double distance(vec<3, double>const&, vec<3, double>const&); template vec<3, double> cross(vec<3, double>const&, vec<3, double>const&); template vec<3, double> normalize(vec<3, double>const&); template vec<3, double> faceforward(vec<3, double>const&, vec<3, double>const&, vec<3, double>const&); template vec<3, double> reflect(vec<3, double>const&, vec<3, double>const&); template vec<3, double> refract(vec<3, double>const&, vec<3, double>const&, double); template float length(vec<3, float>const&); template float distance(vec<3, float>const&, vec<3, float>const&); template vec<3, float> cross(vec<3, float>const&, vec<3, float>const&); template vec<3, float> normalize(vec<3, float>const&); template vec<3, float> faceforward(vec<3, float>const&, vec<3, float>const&, vec<3, float>const&); template vec<3, float> reflect(vec<3, float>const&, vec<3, float>const&); template vec<3, float> refract(vec<3, float>const&, vec<3, float>const&, float); template double length(vec<4, double>const&); template double distance(vec<4, double>const&, vec<4, double>const&); template vec<3, double> cross(vec<3, double>const&, vec<3, double>const&); template vec<4, double> normalize(vec<4, double>const&); template vec<4, double> faceforward(vec<4, double>const&, vec<4, double>const&, vec<4, double>const&); template vec<4, double> reflect(vec<4, double>const&, vec<4, double>const&); template vec<4, double> refract(vec<4, double>const&, vec<4, double>const&, double); template float length(vec<4, float>const&); template float distance(vec<4, float>const&, vec<4, float>const&); template vec<3, float> cross(vec<3, float>const&, vec<3, float>const&); template vec<4, float> normalize(vec<4, float>const&); template vec<4, float> faceforward(vec<4, float>const&, vec<4, float>const&, vec<4, float>const&); template vec<4, float> reflect(vec<4, float>const&, vec<4, float>const&); template vec<4, float> refract(vec<4, float>const&, vec<4, float>const&, float);

}

#line 1 "C:\\Projects\\glm\\glm\\detail/func_common.inl"



#line 1 "C:\\Projects\\glm\\glm\\detail\\../vector_relational.hpp"



















#pragma once



namespace glm
{
	
	

	
	
	
	
	
	
	
	template<length_t L, typename T>
	 constexpr vec<L, bool> lessThan(vec<L, T> const& x, vec<L, T> const& y);

	
	
	
	
	
	
	
	template<length_t L, typename T>
	 constexpr vec<L, bool> lessThanEqual(vec<L, T> const& x, vec<L, T> const& y);

	
	
	
	
	
	
	
	template<length_t L, typename T>
	 constexpr vec<L, bool> greaterThan(vec<L, T> const& x, vec<L, T> const& y);

	
	
	
	
	
	
	
	template<length_t L, typename T>
	 constexpr vec<L, bool> greaterThanEqual(vec<L, T> const& x, vec<L, T> const& y);

	
	
	
	
	
	
	
	template<length_t L, typename T>
	 constexpr vec<L, bool> equal(vec<L, T> const& x, vec<L, T> const& y);

	
	
	
	
	
	
	
	template<length_t L, typename T>
	 constexpr vec<L, bool> notEqual(vec<L, T> const& x, vec<L, T> const& y);

	
	
	
	
	
	
	template<length_t L>
	 constexpr bool any(vec<L, bool> const& v);

	
	
	
	
	
	
	template<length_t L>
	 constexpr bool all(vec<L, bool> const& v);

	
	
	
	
	
	
	
	template<length_t L>
	 constexpr vec<L, bool> not_(vec<L, bool> const& v);

	
}
#line 5 "C:\\Projects\\glm\\glm\\detail/func_common.inl"
#line 1 "C:\\Projects\\glm\\glm\\detail\\compute_common.hpp"
#pragma once




namespace glm{
namespace detail
{
	template<typename genFIType, bool >
	struct compute_abs
	{};

	template<typename genFIType>
	struct compute_abs<genFIType, true>
	{
		 constexpr static genFIType call(genFIType x)
		{
			static_assert(std::numeric_limits<genFIType>::is_iec559 || std::numeric_limits<genFIType>::is_signed, "'abs' only accept floating-point and integer scalar or vector inputs");
#line 22 "C:\\Projects\\glm\\glm\\detail\\compute_common.hpp"

			return x >= genFIType(0) ? x : -x;
			
		}
	};










#line 37 "C:\\Projects\\glm\\glm\\detail\\compute_common.hpp"

	template<typename genFIType>
	struct compute_abs<genFIType, false>
	{
		 constexpr static genFIType call(genFIType x)
		{
			static_assert((!std::numeric_limits<genFIType>::is_signed && std::numeric_limits<genFIType>::is_integer), "'abs' only accept floating-point and integer scalar or vector inputs");
#line 47 "C:\\Projects\\glm\\glm\\detail\\compute_common.hpp"
			return x;
		}
	};
}
}
#line 6 "C:\\Projects\\glm\\glm\\detail/func_common.inl"



#line 1 "C:\\Projects\\glm\\glm\\detail\\_vectorize.hpp"
#pragma once





namespace glm{
namespace detail
{
	template<template<length_t L, typename T> class vec, length_t L, typename R, typename T>
	struct functor1{};

	template<template<length_t L, typename T> class vec, typename R, typename T>
	struct functor1<vec, 2, R, T>
	{
		 constexpr static vec<2, R> call(R (*Func) (T x), vec<2, T> const& v)
		{
			return vec<2, R>(Func(v.x), Func(v.y));
		}
	};

	template<template<length_t L, typename T> class vec, typename R, typename T>
	struct functor1<vec, 3, R, T>
	{
		 constexpr static vec<3, R> call(R (*Func) (T x), vec<3, T> const& v)
		{
			return vec<3, R>(Func(v.x), Func(v.y), Func(v.z));
		}
	};

	template<template<length_t L, typename T> class vec, typename R, typename T>
	struct functor1<vec, 4, R, T>
	{
		 constexpr static vec<4, R> call(R (*Func) (T x), vec<4, T> const& v)
		{
			return vec<4, R>(Func(v.x), Func(v.y), Func(v.z), Func(v.w));
		}
	};

	template<template<length_t L, typename T> class vec, length_t L, typename T>
	struct functor2{};


	template<template<length_t L, typename T> class vec, typename T>
	struct functor2<vec, 2, T>
	{
		 static vec<2, T> call(T (*Func) (T x, T y), vec<2, T> const& a, vec<2, T> const& b)
		{
			return vec<2, T>(Func(a.x, b.x), Func(a.y, b.y));
		}
	};

	template<template<length_t L, typename T> class vec, typename T>
	struct functor2<vec, 3, T>
	{
		 static vec<3, T> call(T (*Func) (T x, T y), vec<3, T> const& a, vec<3, T> const& b)
		{
			return vec<3, T>(Func(a.x, b.x), Func(a.y, b.y), Func(a.z, b.z));
		}
	};

	template<template<length_t L, typename T> class vec, typename T>
	struct functor2<vec, 4, T>
	{
		 static vec<4, T> call(T (*Func) (T x, T y), vec<4, T> const& a, vec<4, T> const& b)
		{
			return vec<4, T>(Func(a.x, b.x), Func(a.y, b.y), Func(a.z, b.z), Func(a.w, b.w));
		}
	};

	template<template<length_t L, typename T> class vec, length_t L, typename T>
	struct functor2_vec_sca{};

	template<template<length_t L, typename T> class vec, typename T>
	struct functor2_vec_sca<vec, 1, T>
	{
		 static vec<1, T> call(T (*Func) (T x, T y), vec<1, T> const& a, T b)
		{
			return vec<1, T>(Func(a.x, b));
		}
	};

	template<template<length_t L, typename T> class vec, typename T>
	struct functor2_vec_sca<vec, 2, T>
	{
		 static vec<2, T> call(T (*Func) (T x, T y), vec<2, T> const& a, T b)
		{
			return vec<2, T>(Func(a.x, b), Func(a.y, b));
		}
	};

	template<template<length_t L, typename T> class vec, typename T>
	struct functor2_vec_sca<vec, 3, T>
	{
		 static vec<3, T> call(T (*Func) (T x, T y), vec<3, T> const& a, T b)
		{
			return vec<3, T>(Func(a.x, b), Func(a.y, b), Func(a.z, b));
		}
	};

	template<template<length_t L, typename T> class vec, typename T>
	struct functor2_vec_sca<vec, 4, T>
	{
		 static vec<4, T> call(T (*Func) (T x, T y), vec<4, T> const& a, T b)
		{
			return vec<4, T>(Func(a.x, b), Func(a.y, b), Func(a.z, b), Func(a.w, b));
		}
	};

	template<length_t L, typename T>
	struct functor2_vec_int {};

	template<typename T>
	struct functor2_vec_int<2, T>
	{
		 static vec<2, int> call(int (*Func) (T x, int y), vec<2, T> const& a, vec<2, int> const& b)
		{
			return vec<2, int>(Func(a.x, b.x), Func(a.y, b.y));
		}
	};

	template<typename T>
	struct functor2_vec_int<3, T>
	{
		 static vec<3, int> call(int (*Func) (T x, int y), vec<3, T> const& a, vec<3, int> const& b)
		{
			return vec<3, int>(Func(a.x, b.x), Func(a.y, b.y), Func(a.z, b.z));
		}
	};

	template<typename T>
	struct functor2_vec_int<4, T>
	{
		 static vec<4, int> call(int (*Func) (T x, int y), vec<4, T> const& a, vec<4, int> const& b)
		{
			return vec<4, int>(Func(a.x, b.x), Func(a.y, b.y), Func(a.z, b.z), Func(a.w, b.w));
		}
	};
}
}
#line 10 "C:\\Projects\\glm\\glm\\detail/func_common.inl"








#line 19 "C:\\Projects\\glm\\glm\\detail/func_common.inl"

namespace glm
{
	
	template<typename genType>
	 constexpr genType min(genType x, genType y)
	{
		static_assert(std::numeric_limits<genType>::is_iec559 || std::numeric_limits<genType>::is_integer, "'min' only accept floating-point or integer inputs");
		return (y < x) ? y : x;
	}

	
	template<typename genType>
	 constexpr genType max(genType x, genType y)
	{
		static_assert(std::numeric_limits<genType>::is_iec559 || std::numeric_limits<genType>::is_integer, "'max' only accept floating-point or integer inputs");

		return (x < y) ? y : x;
	}

	
	template<>
	 constexpr int abs(int x)
	{
		int const y = x >> (sizeof(int) * 8 - 1);
		return (x ^ y) - y;
	}

	

		using ::std::round;








#line 59 "C:\\Projects\\glm\\glm\\detail/func_common.inl"

	

		using ::std::trunc;








#line 72 "C:\\Projects\\glm\\glm\\detail/func_common.inl"

}

namespace glm{
namespace detail
{
	template<length_t L, typename T, bool Aligned>
	struct compute_abs_vector
	{
		 constexpr static vec<L, T> call(vec<L, T> const& x)
		{
			return detail::functor1<vec, L, T, T>::call(abs, x);
		}
	};

	template<length_t L, typename T, typename U, bool Aligned>
	struct compute_mix_vector
	{
		 static vec<L, T> call(vec<L, T> const& x, vec<L, T> const& y, vec<L, U> const& a)
		{
			static_assert(std::numeric_limits<U>::is_iec559 || 0, "'mix' only accept floating-point inputs for the interpolator a");

			return vec<L, T>(vec<L, U>(x) * (static_cast<U>(1) - a) + vec<L, U>(y) * a);
		}
	};

	template<length_t L, typename T, bool Aligned>
	struct compute_mix_vector<L, T, bool, Aligned>
	{
		 static vec<L, T> call(vec<L, T> const& x, vec<L, T> const& y, vec<L, bool> const& a)
		{
			vec<L, T> Result;
			for(length_t i = 0; i < x.length(); ++i)
				Result[i] = a[i] ? y[i] : x[i];
			return Result;
		}
	};

	template<length_t L, typename T, typename U, bool Aligned>
	struct compute_mix_scalar
	{
		 static vec<L, T> call(vec<L, T> const& x, vec<L, T> const& y, U const& a)
		{
			static_assert(std::numeric_limits<U>::is_iec559 || 0, "'mix' only accept floating-point inputs for the interpolator a");

			return vec<L, T>(vec<L, U>(x) * (static_cast<U>(1) - a) + vec<L, U>(y) * a);
		}
	};

	template<length_t L, typename T, bool Aligned>
	struct compute_mix_scalar<L, T, bool, Aligned>
	{
		 static vec<L, T> call(vec<L, T> const& x, vec<L, T> const& y, bool const& a)
		{
			return a ? y : x;
		}
	};

	template<typename T, typename U>
	struct compute_mix
	{
		 static T call(T const& x, T const& y, U const& a)
		{
			static_assert(std::numeric_limits<U>::is_iec559 || 0, "'mix' only accept floating-point inputs for the interpolator a");

			return static_cast<T>(static_cast<U>(x) * (static_cast<U>(1) - a) + static_cast<U>(y) * a);
		}
	};

	template<typename T>
	struct compute_mix<T, bool>
	{
		 static T call(T const& x, T const& y, bool const& a)
		{
			return a ? y : x;
		}
	};

	template<length_t L, typename T, bool isFloat, bool Aligned>
	struct compute_sign
	{
		 static vec<L, T> call(vec<L, T> const& x)
		{
			return vec<L, T>(glm::lessThan(vec<L, T>(0), x)) - vec<L, T>(glm::lessThan(x, vec<L, T>(0)));
		}
	};

	template<length_t L, typename T, bool Aligned>
	struct compute_floor
	{
		 static vec<L, T> call(vec<L, T> const& x)
		{
			return detail::functor1<vec, L, T, T>::call(std::floor, x);
		}
	};

	template<length_t L, typename T, bool Aligned>
	struct compute_ceil
	{
		 static vec<L, T> call(vec<L, T> const& x)
		{
			return detail::functor1<vec, L, T, T>::call(std::ceil, x);
		}
	};

	template<length_t L, typename T, bool Aligned>
	struct compute_fract
	{
		 static vec<L, T> call(vec<L, T> const& x)
		{
			return x - floor(x);
		}
	};

	template<length_t L, typename T, bool Aligned>
	struct compute_trunc
	{
		 static vec<L, T> call(vec<L, T> const& x)
		{
			return detail::functor1<vec, L, T, T>::call(trunc, x);
		}
	};

	template<length_t L, typename T, bool Aligned>
	struct compute_round
	{
		 static vec<L, T> call(vec<L, T> const& x)
		{
			return detail::functor1<vec, L, T, T>::call(round, x);
		}
	};

	template<length_t L, typename T, bool Aligned>
	struct compute_mod
	{
		 static vec<L, T> call(vec<L, T> const& a, vec<L, T> const& b)
		{
			static_assert(std::numeric_limits<T>::is_iec559, "'mod' only accept floating-point inputs. Include <glm/gtc/integer.hpp> for integer inputs.");
			return a - b * floor(a / b);
		}
	};

	template<length_t L, typename T, bool Aligned>
	struct compute_min_vector
	{
		 static vec<L, T> call(vec<L, T> const& x, vec<L, T> const& y)
		{
			return detail::functor2<vec, L, T>::call(min, x, y);
		}
	};

	template<length_t L, typename T, bool Aligned>
	struct compute_max_vector
	{
		 static vec<L, T> call(vec<L, T> const& x, vec<L, T> const& y)
		{
			return detail::functor2<vec, L, T>::call(max, x, y);
		}
	};

	template<length_t L, typename T, bool Aligned>
	struct compute_clamp_vector
	{
		 static vec<L, T> call(vec<L, T> const& x, vec<L, T> const& minVal, vec<L, T> const& maxVal)
		{
			return min(max(x, minVal), maxVal);
		}
	};

	template<length_t L, typename T, bool Aligned>
	struct compute_step_vector
	{
		 static vec<L, T> call(vec<L, T> const& edge, vec<L, T> const& x)
		{
			return mix(vec<L, T>(1), vec<L, T>(0), glm::lessThan(x, edge));
		}
	};

	template<length_t L, typename T, bool Aligned>
	struct compute_smoothstep_vector
	{
		 static vec<L, T> call(vec<L, T> const& edge0, vec<L, T> const& edge1, vec<L, T> const& x)
		{
			static_assert(std::numeric_limits<T>::is_iec559 || 0, "'smoothstep' only accept floating-point inputs");
			vec<L, T> const tmp(clamp((x - edge0) / (edge1 - edge0), static_cast<T>(0), static_cast<T>(1)));
			return tmp * tmp * (static_cast<T>(3) - static_cast<T>(2) * tmp);
		}
	};
}

	template<typename genFIType>
	 constexpr genFIType abs(genFIType x)
	{
		return detail::compute_abs<genFIType, std::numeric_limits<genFIType>::is_signed>::call(x);
	}

	template<length_t L, typename T>
	 constexpr vec<L, T> abs(vec<L, T> const& x)
	{
		return detail::compute_abs_vector<L, T, false>::call(x);
	}

	
	
	template<typename genFIType>
	 genFIType sign(genFIType x)
	{
		static_assert(std::numeric_limits<genFIType>::is_iec559 || (std::numeric_limits<genFIType>::is_signed && std::numeric_limits<genFIType>::is_integer), "'sign' only accept signed inputs");
#line 283 "C:\\Projects\\glm\\glm\\detail/func_common.inl"
		return (genFIType(0) < x) - (x < genFIType(0));
	}

	template<length_t L, typename T>
	 vec<L, T> sign(vec<L, T> const& x)
	{
		static_assert(std::numeric_limits<T>::is_iec559 || (std::numeric_limits<T>::is_signed && std::numeric_limits<T>::is_integer), "'sign' only accept signed inputs");
#line 292 "C:\\Projects\\glm\\glm\\detail/func_common.inl"

		return detail::compute_sign<L, T, std::numeric_limits<T>::is_iec559, false>::call(x);
	}

	
	
	template<typename genType>
	 genType floor(genType x) 
	{
		static_assert(std::numeric_limits<genType>::is_iec559, "'floor' only accept floating-point inputs.");
		return ::std::floor(x);
	}

	template<length_t L, typename T>
	 vec<L, T> floor(vec<L, T> const& x)
	{
		static_assert(std::numeric_limits<T>::is_iec559, "'floor' only accept floating-point inputs.");
		return detail::compute_floor<L, T, false>::call(x);
	}

	template<length_t L, typename T>
	 vec<L, T> trunc(vec<L, T> const& x)
	{
		static_assert(std::numeric_limits<T>::is_iec559, "'trunc' only accept floating-point inputs");
		return detail::compute_trunc<L, T, false>::call(x);
	}

	template<typename genType>
	 genType round(genType x)
	{
		static_assert(std::numeric_limits<genType>::is_iec559, "'round' only accept floating-point inputs");
		return ::std::round(x);
	}


	template<length_t L, typename T>
	 vec<L, T> round(vec<L, T> const& x)
	{
		static_assert(std::numeric_limits<T>::is_iec559, "'round' only accept floating-point inputs");
		return detail::compute_round<L, T, false>::call(x);
	}












	
	template<typename genType>
	 genType roundEven(genType x)
	{
		static_assert(std::numeric_limits<genType>::is_iec559, "'roundEven' only accept floating-point inputs");

		int Integer = static_cast<int>(x);
		genType IntegerPart = static_cast<genType>(Integer);
		genType FractionalPart = fract(x);

		if(FractionalPart > static_cast<genType>(0.5) || FractionalPart < static_cast<genType>(0.5))
		{
			return round(x);
		}
		else if((Integer % 2) == 0)
		{
			return IntegerPart;
		}
		else if(x <= static_cast<genType>(0)) 
		{
			return IntegerPart - static_cast<genType>(1);
		}
		else
		{
			return IntegerPart + static_cast<genType>(1);
		}
		
		
		
		
	}

	template<length_t L, typename T>
	 vec<L, T> roundEven(vec<L, T> const& x)
	{
		static_assert(std::numeric_limits<T>::is_iec559, "'roundEven' only accept floating-point inputs");
		return detail::functor1<vec, L, T, T>::call(roundEven, x);
	}

	
	using ::std::ceil;
	template<length_t L, typename T>
	 vec<L, T> ceil(vec<L, T> const& x)
	{
		static_assert(std::numeric_limits<T>::is_iec559, "'ceil' only accept floating-point inputs");
		return detail::compute_ceil<L, T, false>::call(x);
	}

	
	template<typename genType>
	 genType fract(genType x)
	{
		return x - floor(x);
	}

	template<length_t L, typename T>
	 vec<L, T> fract(vec<L, T> const& x)
	{
		static_assert(std::numeric_limits<T>::is_iec559, "'fract' only accept floating-point inputs");
		return detail::compute_fract<L, T, false>::call(x);
	}

	
	template<typename genType>
	 genType mod(genType x, genType y)
	{




#line 415 "C:\\Projects\\glm\\glm\\detail/func_common.inl"
			return x - y * floor(x / y);
#line 417 "C:\\Projects\\glm\\glm\\detail/func_common.inl"
	}

	template<length_t L, typename T>
	 vec<L, T> mod(vec<L, T> const& x, T y)
	{
		return detail::compute_mod<L, T, false>::call(x, vec<L, T>(y));
	}

	template<length_t L, typename T>
	 vec<L, T> mod(vec<L, T> const& x, vec<L, T> const& y)
	{
		return detail::compute_mod<L, T, false>::call(x, y);
	}

	
	template<typename genType>
	 genType modf(genType x, genType & i)
	{
		static_assert(std::numeric_limits<genType>::is_iec559, "'modf' only accept floating-point inputs");
		return std::modf(x, &i);
	}

	template<typename T>
	 vec<2, T> modf(vec<2, T> const& x, vec<2, T> & i)
	{
		return vec<2, T>(
			modf(x.x, i.x),
			modf(x.y, i.y));
	}

	template<typename T>
	 vec<3, T> modf(vec<3, T> const& x, vec<3, T> & i)
	{
		return vec<3, T>(
			modf(x.x, i.x),
			modf(x.y, i.y),
			modf(x.z, i.z));
	}

	template<typename T>
	 vec<4, T> modf(vec<4, T> const& x, vec<4, T> & i)
	{
		return vec<4, T>(
			modf(x.x, i.x),
			modf(x.y, i.y),
			modf(x.z, i.z),
			modf(x.w, i.w));
	}

	
	
	
	
	
	
	

	
	template<length_t L, typename T>
	 constexpr vec<L, T> min(vec<L, T> const& a, T b)
	{
		static_assert(std::numeric_limits<T>::is_iec559 || std::numeric_limits<T>::is_integer, "'min' only accept floating-point or integer inputs");
		return detail::compute_min_vector<L, T, false>::call(a, vec<L, T>(b));
	}

	template<length_t L, typename T>
	 constexpr vec<L, T> min(vec<L, T> const& a, vec<L, T> const& b)
	{
		return detail::compute_min_vector<L, T, false>::call(a, b);
	}

	
	template<length_t L, typename T>
	 constexpr vec<L, T> max(vec<L, T> const& a, T b)
	{
		static_assert(std::numeric_limits<T>::is_iec559 || std::numeric_limits<T>::is_integer, "'max' only accept floating-point or integer inputs");
		return detail::compute_max_vector<L, T, false>::call(a, vec<L, T>(b));
	}

	template<length_t L, typename T>
	 constexpr vec<L, T> max(vec<L, T> const& a, vec<L, T> const& b)
	{
		return detail::compute_max_vector<L, T, false>::call(a, b);
	}

	
	template<typename genType>
	 constexpr genType clamp(genType x, genType minVal, genType maxVal)
	{
		static_assert(std::numeric_limits<genType>::is_iec559 || std::numeric_limits<genType>::is_integer, "'clamp' only accept floating-point or integer inputs");
		return min(max(x, minVal), maxVal);
	}

	template<length_t L, typename T>
	 constexpr vec<L, T> clamp(vec<L, T> const& x, T minVal, T maxVal)
	{
		static_assert(std::numeric_limits<T>::is_iec559 || std::numeric_limits<T>::is_integer, "'clamp' only accept floating-point or integer inputs");
		return detail::compute_clamp_vector<L, T, false>::call(x, vec<L, T>(minVal), vec<L, T>(maxVal));
	}

	template<length_t L, typename T>
	 constexpr vec<L, T> clamp(vec<L, T> const& x, vec<L, T> const& minVal, vec<L, T> const& maxVal)
	{
		static_assert(std::numeric_limits<T>::is_iec559 || std::numeric_limits<T>::is_integer, "'clamp' only accept floating-point or integer inputs");
		return detail::compute_clamp_vector<L, T, false>::call(x, minVal, maxVal);
	}

	template<typename genTypeT, typename genTypeU>
	 genTypeT mix(genTypeT x, genTypeT y, genTypeU a)
	{
		return detail::compute_mix<genTypeT, genTypeU>::call(x, y, a);
	}

	template<length_t L, typename T, typename U>
	 vec<L, T> mix(vec<L, T> const& x, vec<L, T> const& y, U a)
	{
		return detail::compute_mix_scalar<L, T, U, false>::call(x, y, a);
	}

	template<length_t L, typename T, typename U>
	 vec<L, T> mix(vec<L, T> const& x, vec<L, T> const& y, vec<L, U> const& a)
	{
		return detail::compute_mix_vector<L, T, U, false>::call(x, y, a);
	}

	
	template<typename genType>
	 genType step(genType edge, genType x)
	{
		return mix(static_cast<genType>(1), static_cast<genType>(0), x < edge);
	}

	template<length_t L, typename T>
	 vec<L, T> step(T edge, vec<L, T> const& x)
	{
		return detail::compute_step_vector<L, T, false>::call(vec<L, T>(edge), x);
	}

	template<length_t L, typename T>
	 vec<L, T> step(vec<L, T> const& edge, vec<L, T> const& x)
	{
		return detail::compute_step_vector<L, T, false>::call(edge, x);
	}

	
	template<typename genType>
	 genType smoothstep(genType edge0, genType edge1, genType x)
	{
		static_assert(std::numeric_limits<genType>::is_iec559 || 0, "'smoothstep' only accept floating-point inputs");

		genType const tmp(clamp((x - edge0) / (edge1 - edge0), genType(0), genType(1)));
		return tmp * tmp * (genType(3) - genType(2) * tmp);
	}

	template<length_t L, typename T>
	 vec<L, T> smoothstep(T edge0, T edge1, vec<L, T> const& x)
	{
		return detail::compute_smoothstep_vector<L, T, false>::call(vec<L, T>(edge0), vec<L, T>(edge1), x);
	}

	template<length_t L, typename T>
	 vec<L, T> smoothstep(vec<L, T> const& edge0, vec<L, T> const& edge1, vec<L, T> const& x)
	{
		return detail::compute_smoothstep_vector<L, T, false>::call(edge0, edge1, x);
	}


		
























#line 610 "C:\\Projects\\glm\\glm\\detail/func_common.inl"

	template<typename genType>
	 bool isnan(genType x)
	{
		static_assert(std::numeric_limits<genType>::is_iec559, "'isnan' only accept floating-point inputs");
		return std::isnan(x);
	}


	template<length_t L, typename T>
	 vec<L, bool> isnan(vec<L, T> const& v)
	{
		static_assert(std::numeric_limits<T>::is_iec559, "'isnan' only accept floating-point inputs");

		vec<L, bool> Result;
		for (length_t l = 0; l < v.length(); ++l)
			Result[l] = glm::isnan(v[l]);
		return Result;
	}


		



























#line 660 "C:\\Projects\\glm\\glm\\detail/func_common.inl"

	template<typename genType>
	 bool isinf(genType x)
	{
		static_assert(std::numeric_limits<genType>::is_iec559, "'isinf' only accept floating-point inputs");
		return std::isinf(x);
	}

	template<length_t L, typename T>
	 vec<L, bool> isinf(vec<L, T> const& v)
	{
		static_assert(std::numeric_limits<T>::is_iec559, "'isinf' only accept floating-point inputs");

		vec<L, bool> Result;
		for (length_t l = 0; l < v.length(); ++l)
			Result[l] = glm::isinf(v[l]);
		return Result;
	}

	 inline int floatBitsToInt(float const& v)
	{
		union
		{
			float in;
			int out;
		} u;

		u.in = v;

		return u.out;
	}

	template<length_t L>
	 vec<L, int> floatBitsToInt(vec<L, float> const& v)
	{
		return reinterpret_cast<vec<L, int>&>(const_cast<vec<L, float>&>(v));
	}

	 inline uint floatBitsToUint(float const& v)
	{
		union
		{
			float in;
			uint out;
		} u;

		u.in = v;

		return u.out;
	}

	template<length_t L>
	 vec<L, uint> floatBitsToUint(vec<L, float> const& v)
	{
		return reinterpret_cast<vec<L, uint>&>(const_cast<vec<L, float>&>(v));
	}

	 inline float intBitsToFloat(int const& v)
	{
		union
		{
			int in;
			float out;
		} u;

		u.in = v;

		return u.out;
	}

	template<length_t L>
	 vec<L, float> intBitsToFloat(vec<L, int> const& v)
	{
		return reinterpret_cast<vec<L, float>&>(const_cast<vec<L, int>&>(v));
	}

	 inline float uintBitsToFloat(uint const& v)
	{
		union
		{
			uint in;
			float out;
		} u;

		u.in = v;

		return u.out;
	}

	template<length_t L>
	 vec<L, float> uintBitsToFloat(vec<L, uint> const& v)
	{
		return reinterpret_cast<vec<L, float>&>(const_cast<vec<L, uint>&>(v));
	}


		using std::fma;






#line 764 "C:\\Projects\\glm\\glm\\detail/func_common.inl"

	template<typename genType>
	 genType frexp(genType x, int& exp)
	{
		static_assert(std::numeric_limits<genType>::is_iec559, "'frexp' only accept floating-point inputs");

		return std::frexp(x, &exp);
	}

	template<length_t L, typename T>
	 vec<L, T> frexp(vec<L, T> const& v, vec<L, int>& exp)
	{
		static_assert(std::numeric_limits<T>::is_iec559, "'frexp' only accept floating-point inputs");

		vec<L, T> Result;
		for (length_t l = 0; l < v.length(); ++l)
			Result[l] = std::frexp(v[l], &exp[l]);
		return Result;
	}

	template<typename genType>
	 genType ldexp(genType const& x, int const& exp)
	{
		static_assert(std::numeric_limits<genType>::is_iec559, "'ldexp' only accept floating-point inputs");

		return std::ldexp(x, exp);
	}

	template<length_t L, typename T>
	 vec<L, T> ldexp(vec<L, T> const& v, vec<L, int> const& exp)
	{
		static_assert(std::numeric_limits<T>::is_iec559, "'ldexp' only accept floating-point inputs");

		vec<L, T> Result;
		for (length_t l = 0; l < v.length(); ++l)
			Result[l] = std::ldexp(v[l], exp[l]);
		return Result;
	}
}



#line 807 "C:\\Projects\\glm\\glm\\detail/func_common.inl"
#line 76 ".\\glm_impl.cpp"
namespace glm {




















    template double abs(double x); template vec<2, double> abs(vec<2, double> const& x); template double min(double x, double y); template vec<2, double> min(vec<2, double> const& x, double y); template vec<2, double> min(vec<2, double> const& x, vec<2, double> const& y); template double max(double x, double y); template vec<2, double> max(vec<2, double> const& x, double y); template vec<2, double> max(vec<2, double> const& x, vec<2, double> const& y); template double clamp(double x, double minVal, double maxVal); template vec<2, double> clamp(vec<2, double> const& x, double minVal, double maxVal); template vec<2, double> clamp(vec<2, double> const& x, vec<2, double> const& minVal, vec<2, double> const& maxVal); template double step(double edge, double x); template vec<2, double> step(double edge, vec<2, double> const& x); template vec<2, double> step(vec<2, double> const& edge, vec<2, double> const& x); template vec<2, int> floatBitsToInt(vec<2, float> const& v); template vec<2, uint> floatBitsToUint(vec<2, float> const& v); template vec<2, float> intBitsToFloat(vec<2 , int> const& v); template vec<2, float> uintBitsToFloat(vec<2, uint> const& v); template double fma(double const& a, double const& b, double const& c); template float abs(float x); template vec<2, float> abs(vec<2, float> const& x); template float min(float x, float y); template vec<2, float> min(vec<2, float> const& x, float y); template vec<2, float> min(vec<2, float> const& x, vec<2, float> const& y); template float max(float x, float y); template vec<2, float> max(vec<2, float> const& x, float y); template vec<2, float> max(vec<2, float> const& x, vec<2, float> const& y); template float clamp(float x, float minVal, float maxVal); template vec<2, float> clamp(vec<2, float> const& x, float minVal, float maxVal); template vec<2, float> clamp(vec<2, float> const& x, vec<2, float> const& minVal, vec<2, float> const& maxVal); template float step(float edge, float x); template vec<2, float> step(float edge, vec<2, float> const& x); template vec<2, float> step(vec<2, float> const& edge, vec<2, float> const& x); template vec<2, int> floatBitsToInt(vec<2, float> const& v); template vec<2, uint> floatBitsToUint(vec<2, float> const& v); template vec<2, float> intBitsToFloat(vec<2 , int> const& v); template vec<2, float> uintBitsToFloat(vec<2, uint> const& v); template float fma(float const& a, float const& b, float const& c); template int abs(int x); template vec<2, int> abs(vec<2, int> const& x); template int min(int x, int y); template vec<2, int> min(vec<2, int> const& x, int y); template vec<2, int> min(vec<2, int> const& x, vec<2, int> const& y); template int max(int x, int y); template vec<2, int> max(vec<2, int> const& x, int y); template vec<2, int> max(vec<2, int> const& x, vec<2, int> const& y); template int clamp(int x, int minVal, int maxVal); template vec<2, int> clamp(vec<2, int> const& x, int minVal, int maxVal); template vec<2, int> clamp(vec<2, int> const& x, vec<2, int> const& minVal, vec<2, int> const& maxVal); template int step(int edge, int x); template vec<2, int> step(int edge, vec<2, int> const& x); template vec<2, int> step(vec<2, int> const& edge, vec<2, int> const& x); template vec<2, int> floatBitsToInt(vec<2, float> const& v); template vec<2, uint> floatBitsToUint(vec<2, float> const& v); template vec<2, float> intBitsToFloat(vec<2 , int> const& v); template vec<2, float> uintBitsToFloat(vec<2, uint> const& v); template int fma(int const& a, int const& b, int const& c); template unsigned abs(unsigned x); template vec<2, unsigned> abs(vec<2, unsigned> const& x); template unsigned min(unsigned x, unsigned y); template vec<2, unsigned> min(vec<2, unsigned> const& x, unsigned y); template vec<2, unsigned> min(vec<2, unsigned> const& x, vec<2, unsigned> const& y); template unsigned max(unsigned x, unsigned y); template vec<2, unsigned> max(vec<2, unsigned> const& x, unsigned y); template vec<2, unsigned> max(vec<2, unsigned> const& x, vec<2, unsigned> const& y); template unsigned clamp(unsigned x, unsigned minVal, unsigned maxVal); template vec<2, unsigned> clamp(vec<2, unsigned> const& x, unsigned minVal, unsigned maxVal); template vec<2, unsigned> clamp(vec<2, unsigned> const& x, vec<2, unsigned> const& minVal, vec<2, unsigned> const& maxVal); template unsigned step(unsigned edge, unsigned x); template vec<2, unsigned> step(unsigned edge, vec<2, unsigned> const& x); template vec<2, unsigned> step(vec<2, unsigned> const& edge, vec<2, unsigned> const& x); template vec<2, int> floatBitsToInt(vec<2, float> const& v); template vec<2, uint> floatBitsToUint(vec<2, float> const& v); template vec<2, float> intBitsToFloat(vec<2 , int> const& v); template vec<2, float> uintBitsToFloat(vec<2, uint> const& v); template unsigned fma(unsigned const& a, unsigned const& b, unsigned const& c); template double abs(double x); template vec<3, double> abs(vec<3, double> const& x); template double min(double x, double y); template vec<3, double> min(vec<3, double> const& x, double y); template vec<3, double> min(vec<3, double> const& x, vec<3, double> const& y); template double max(double x, double y); template vec<3, double> max(vec<3, double> const& x, double y); template vec<3, double> max(vec<3, double> const& x, vec<3, double> const& y); template double clamp(double x, double minVal, double maxVal); template vec<3, double> clamp(vec<3, double> const& x, double minVal, double maxVal); template vec<3, double> clamp(vec<3, double> const& x, vec<3, double> const& minVal, vec<3, double> const& maxVal); template double step(double edge, double x); template vec<3, double> step(double edge, vec<3, double> const& x); template vec<3, double> step(vec<3, double> const& edge, vec<3, double> const& x); template vec<3, int> floatBitsToInt(vec<3, float> const& v); template vec<3, uint> floatBitsToUint(vec<3, float> const& v); template vec<3, float> intBitsToFloat(vec<3 , int> const& v); template vec<3, float> uintBitsToFloat(vec<3, uint> const& v); template double fma(double const& a, double const& b, double const& c); template float abs(float x); template vec<3, float> abs(vec<3, float> const& x); template float min(float x, float y); template vec<3, float> min(vec<3, float> const& x, float y); template vec<3, float> min(vec<3, float> const& x, vec<3, float> const& y); template float max(float x, float y); template vec<3, float> max(vec<3, float> const& x, float y); template vec<3, float> max(vec<3, float> const& x, vec<3, float> const& y); template float clamp(float x, float minVal, float maxVal); template vec<3, float> clamp(vec<3, float> const& x, float minVal, float maxVal); template vec<3, float> clamp(vec<3, float> const& x, vec<3, float> const& minVal, vec<3, float> const& maxVal); template float step(float edge, float x); template vec<3, float> step(float edge, vec<3, float> const& x); template vec<3, float> step(vec<3, float> const& edge, vec<3, float> const& x); template vec<3, int> floatBitsToInt(vec<3, float> const& v); template vec<3, uint> floatBitsToUint(vec<3, float> const& v); template vec<3, float> intBitsToFloat(vec<3 , int> const& v); template vec<3, float> uintBitsToFloat(vec<3, uint> const& v); template float fma(float const& a, float const& b, float const& c); template int abs(int x); template vec<3, int> abs(vec<3, int> const& x); template int min(int x, int y); template vec<3, int> min(vec<3, int> const& x, int y); template vec<3, int> min(vec<3, int> const& x, vec<3, int> const& y); template int max(int x, int y); template vec<3, int> max(vec<3, int> const& x, int y); template vec<3, int> max(vec<3, int> const& x, vec<3, int> const& y); template int clamp(int x, int minVal, int maxVal); template vec<3, int> clamp(vec<3, int> const& x, int minVal, int maxVal); template vec<3, int> clamp(vec<3, int> const& x, vec<3, int> const& minVal, vec<3, int> const& maxVal); template int step(int edge, int x); template vec<3, int> step(int edge, vec<3, int> const& x); template vec<3, int> step(vec<3, int> const& edge, vec<3, int> const& x); template vec<3, int> floatBitsToInt(vec<3, float> const& v); template vec<3, uint> floatBitsToUint(vec<3, float> const& v); template vec<3, float> intBitsToFloat(vec<3 , int> const& v); template vec<3, float> uintBitsToFloat(vec<3, uint> const& v); template int fma(int const& a, int const& b, int const& c); template unsigned abs(unsigned x); template vec<3, unsigned> abs(vec<3, unsigned> const& x); template unsigned min(unsigned x, unsigned y); template vec<3, unsigned> min(vec<3, unsigned> const& x, unsigned y); template vec<3, unsigned> min(vec<3, unsigned> const& x, vec<3, unsigned> const& y); template unsigned max(unsigned x, unsigned y); template vec<3, unsigned> max(vec<3, unsigned> const& x, unsigned y); template vec<3, unsigned> max(vec<3, unsigned> const& x, vec<3, unsigned> const& y); template unsigned clamp(unsigned x, unsigned minVal, unsigned maxVal); template vec<3, unsigned> clamp(vec<3, unsigned> const& x, unsigned minVal, unsigned maxVal); template vec<3, unsigned> clamp(vec<3, unsigned> const& x, vec<3, unsigned> const& minVal, vec<3, unsigned> const& maxVal); template unsigned step(unsigned edge, unsigned x); template vec<3, unsigned> step(unsigned edge, vec<3, unsigned> const& x); template vec<3, unsigned> step(vec<3, unsigned> const& edge, vec<3, unsigned> const& x); template vec<3, int> floatBitsToInt(vec<3, float> const& v); template vec<3, uint> floatBitsToUint(vec<3, float> const& v); template vec<3, float> intBitsToFloat(vec<3 , int> const& v); template vec<3, float> uintBitsToFloat(vec<3, uint> const& v); template unsigned fma(unsigned const& a, unsigned const& b, unsigned const& c); template double abs(double x); template vec<4, double> abs(vec<4, double> const& x); template double min(double x, double y); template vec<4, double> min(vec<4, double> const& x, double y); template vec<4, double> min(vec<4, double> const& x, vec<4, double> const& y); template double max(double x, double y); template vec<4, double> max(vec<4, double> const& x, double y); template vec<4, double> max(vec<4, double> const& x, vec<4, double> const& y); template double clamp(double x, double minVal, double maxVal); template vec<4, double> clamp(vec<4, double> const& x, double minVal, double maxVal); template vec<4, double> clamp(vec<4, double> const& x, vec<4, double> const& minVal, vec<4, double> const& maxVal); template double step(double edge, double x); template vec<4, double> step(double edge, vec<4, double> const& x); template vec<4, double> step(vec<4, double> const& edge, vec<4, double> const& x); template vec<4, int> floatBitsToInt(vec<4, float> const& v); template vec<4, uint> floatBitsToUint(vec<4, float> const& v); template vec<4, float> intBitsToFloat(vec<4 , int> const& v); template vec<4, float> uintBitsToFloat(vec<4, uint> const& v); template double fma(double const& a, double const& b, double const& c); template float abs(float x); template vec<4, float> abs(vec<4, float> const& x); template float min(float x, float y); template vec<4, float> min(vec<4, float> const& x, float y); template vec<4, float> min(vec<4, float> const& x, vec<4, float> const& y); template float max(float x, float y); template vec<4, float> max(vec<4, float> const& x, float y); template vec<4, float> max(vec<4, float> const& x, vec<4, float> const& y); template float clamp(float x, float minVal, float maxVal); template vec<4, float> clamp(vec<4, float> const& x, float minVal, float maxVal); template vec<4, float> clamp(vec<4, float> const& x, vec<4, float> const& minVal, vec<4, float> const& maxVal); template float step(float edge, float x); template vec<4, float> step(float edge, vec<4, float> const& x); template vec<4, float> step(vec<4, float> const& edge, vec<4, float> const& x); template vec<4, int> floatBitsToInt(vec<4, float> const& v); template vec<4, uint> floatBitsToUint(vec<4, float> const& v); template vec<4, float> intBitsToFloat(vec<4 , int> const& v); template vec<4, float> uintBitsToFloat(vec<4, uint> const& v); template float fma(float const& a, float const& b, float const& c); template int abs(int x); template vec<4, int> abs(vec<4, int> const& x); template int min(int x, int y); template vec<4, int> min(vec<4, int> const& x, int y); template vec<4, int> min(vec<4, int> const& x, vec<4, int> const& y); template int max(int x, int y); template vec<4, int> max(vec<4, int> const& x, int y); template vec<4, int> max(vec<4, int> const& x, vec<4, int> const& y); template int clamp(int x, int minVal, int maxVal); template vec<4, int> clamp(vec<4, int> const& x, int minVal, int maxVal); template vec<4, int> clamp(vec<4, int> const& x, vec<4, int> const& minVal, vec<4, int> const& maxVal); template int step(int edge, int x); template vec<4, int> step(int edge, vec<4, int> const& x); template vec<4, int> step(vec<4, int> const& edge, vec<4, int> const& x); template vec<4, int> floatBitsToInt(vec<4, float> const& v); template vec<4, uint> floatBitsToUint(vec<4, float> const& v); template vec<4, float> intBitsToFloat(vec<4 , int> const& v); template vec<4, float> uintBitsToFloat(vec<4, uint> const& v); template int fma(int const& a, int const& b, int const& c); template unsigned abs(unsigned x); template vec<4, unsigned> abs(vec<4, unsigned> const& x); template unsigned min(unsigned x, unsigned y); template vec<4, unsigned> min(vec<4, unsigned> const& x, unsigned y); template vec<4, unsigned> min(vec<4, unsigned> const& x, vec<4, unsigned> const& y); template unsigned max(unsigned x, unsigned y); template vec<4, unsigned> max(vec<4, unsigned> const& x, unsigned y); template vec<4, unsigned> max(vec<4, unsigned> const& x, vec<4, unsigned> const& y); template unsigned clamp(unsigned x, unsigned minVal, unsigned maxVal); template vec<4, unsigned> clamp(vec<4, unsigned> const& x, unsigned minVal, unsigned maxVal); template vec<4, unsigned> clamp(vec<4, unsigned> const& x, vec<4, unsigned> const& minVal, vec<4, unsigned> const& maxVal); template unsigned step(unsigned edge, unsigned x); template vec<4, unsigned> step(unsigned edge, vec<4, unsigned> const& x); template vec<4, unsigned> step(vec<4, unsigned> const& edge, vec<4, unsigned> const& x); template vec<4, int> floatBitsToInt(vec<4, float> const& v); template vec<4, uint> floatBitsToUint(vec<4, float> const& v); template vec<4, float> intBitsToFloat(vec<4 , int> const& v); template vec<4, float> uintBitsToFloat(vec<4, uint> const& v); template unsigned fma(unsigned const& a, unsigned const& b, unsigned const& c);




























    template vec<2, double> sign(vec<2, double> const& x); template vec<2, double> floor(vec<2, double> const& x); template vec<2, double> trunc(vec<2, double> const& x); template vec<2, double> round(vec<2, double> const& x); template double roundEven(double x); template vec<2, double> roundEven(vec<2, double> const& x); template vec<2, double> ceil(vec<2, double> const& x); template double fract(double x); template vec<2, double> fract(vec<2, double> const& x); template vec<2, double> mod(vec<2, double> const& x, double y); template vec<2, double> mod(vec<2, double> const& x, vec<2, double> const& y); template double modf<double>(double x, double& i); template vec<2, double> modf<2, double>(vec<2, double> const& x, vec<2, double>& i); template vec<2, bool> isnan(vec<2, double> const& x); template vec<2, bool> isinf(vec<2, double> const& x); template double frexp(double x, int& exp); template vec<2, double> frexp(vec<2, double> const& v, vec<2, int>& exp); template double ldexp(double const& x, int const& exp); template vec<2, double> ldexp(vec<2, double> const& v, vec<2, int> const& exp);template double smoothstep(double edge0, double edge1, double x); template vec<2, double> smoothstep(double edge0, double edge1, vec<2, double> const& x); template vec<2, double> smoothstep(vec<2, double> const& edge0, vec<2, double> const& edge1, vec<2, double> const& x); template double mod(double x, double y); template double mix(double x, double y, double a); template vec<2, double> mix(vec<2, double> const& x, vec<2, double> const& y, vec<2, double> const& a); template vec<2, double> mix(vec<2, double> const& x, vec<2, double> const& y, double a); template vec<2, float> sign(vec<2, float> const& x); template vec<2, float> floor(vec<2, float> const& x); template vec<2, float> trunc(vec<2, float> const& x); template vec<2, float> round(vec<2, float> const& x); template float roundEven(float x); template vec<2, float> roundEven(vec<2, float> const& x); template vec<2, float> ceil(vec<2, float> const& x); template float fract(float x); template vec<2, float> fract(vec<2, float> const& x); template vec<2, float> mod(vec<2, float> const& x, float y); template vec<2, float> mod(vec<2, float> const& x, vec<2, float> const& y); template float modf<float>(float x, float& i); template vec<2, float> modf<2, float>(vec<2, float> const& x, vec<2, float>& i); template vec<2, bool> isnan(vec<2, float> const& x); template vec<2, bool> isinf(vec<2, float> const& x); template float frexp(float x, int& exp); template vec<2, float> frexp(vec<2, float> const& v, vec<2, int>& exp); template float ldexp(float const& x, int const& exp); template vec<2, float> ldexp(vec<2, float> const& v, vec<2, int> const& exp);template float smoothstep(float edge0, float edge1, float x); template vec<2, float> smoothstep(float edge0, float edge1, vec<2, float> const& x); template vec<2, float> smoothstep(vec<2, float> const& edge0, vec<2, float> const& edge1, vec<2, float> const& x); template float mod(float x, float y); template float mix(float x, float y, float a); template vec<2, float> mix(vec<2, float> const& x, vec<2, float> const& y, vec<2, float> const& a); template vec<2, float> mix(vec<2, float> const& x, vec<2, float> const& y, float a); template vec<3, double> sign(vec<3, double> const& x); template vec<3, double> floor(vec<3, double> const& x); template vec<3, double> trunc(vec<3, double> const& x); template vec<3, double> round(vec<3, double> const& x); template double roundEven(double x); template vec<3, double> roundEven(vec<3, double> const& x); template vec<3, double> ceil(vec<3, double> const& x); template double fract(double x); template vec<3, double> fract(vec<3, double> const& x); template vec<3, double> mod(vec<3, double> const& x, double y); template vec<3, double> mod(vec<3, double> const& x, vec<3, double> const& y); template double modf<double>(double x, double& i); template vec<3, double> modf<3, double>(vec<3, double> const& x, vec<3, double>& i); template vec<3, bool> isnan(vec<3, double> const& x); template vec<3, bool> isinf(vec<3, double> const& x); template double frexp(double x, int& exp); template vec<3, double> frexp(vec<3, double> const& v, vec<3, int>& exp); template double ldexp(double const& x, int const& exp); template vec<3, double> ldexp(vec<3, double> const& v, vec<3, int> const& exp);template double smoothstep(double edge0, double edge1, double x); template vec<3, double> smoothstep(double edge0, double edge1, vec<3, double> const& x); template vec<3, double> smoothstep(vec<3, double> const& edge0, vec<3, double> const& edge1, vec<3, double> const& x); template double mod(double x, double y); template double mix(double x, double y, double a); template vec<3, double> mix(vec<3, double> const& x, vec<3, double> const& y, vec<3, double> const& a); template vec<3, double> mix(vec<3, double> const& x, vec<3, double> const& y, double a); template vec<3, float> sign(vec<3, float> const& x); template vec<3, float> floor(vec<3, float> const& x); template vec<3, float> trunc(vec<3, float> const& x); template vec<3, float> round(vec<3, float> const& x); template float roundEven(float x); template vec<3, float> roundEven(vec<3, float> const& x); template vec<3, float> ceil(vec<3, float> const& x); template float fract(float x); template vec<3, float> fract(vec<3, float> const& x); template vec<3, float> mod(vec<3, float> const& x, float y); template vec<3, float> mod(vec<3, float> const& x, vec<3, float> const& y); template float modf<float>(float x, float& i); template vec<3, float> modf<3, float>(vec<3, float> const& x, vec<3, float>& i); template vec<3, bool> isnan(vec<3, float> const& x); template vec<3, bool> isinf(vec<3, float> const& x); template float frexp(float x, int& exp); template vec<3, float> frexp(vec<3, float> const& v, vec<3, int>& exp); template float ldexp(float const& x, int const& exp); template vec<3, float> ldexp(vec<3, float> const& v, vec<3, int> const& exp);template float smoothstep(float edge0, float edge1, float x); template vec<3, float> smoothstep(float edge0, float edge1, vec<3, float> const& x); template vec<3, float> smoothstep(vec<3, float> const& edge0, vec<3, float> const& edge1, vec<3, float> const& x); template float mod(float x, float y); template float mix(float x, float y, float a); template vec<3, float> mix(vec<3, float> const& x, vec<3, float> const& y, vec<3, float> const& a); template vec<3, float> mix(vec<3, float> const& x, vec<3, float> const& y, float a); template vec<4, double> sign(vec<4, double> const& x); template vec<4, double> floor(vec<4, double> const& x); template vec<4, double> trunc(vec<4, double> const& x); template vec<4, double> round(vec<4, double> const& x); template double roundEven(double x); template vec<4, double> roundEven(vec<4, double> const& x); template vec<4, double> ceil(vec<4, double> const& x); template double fract(double x); template vec<4, double> fract(vec<4, double> const& x); template vec<4, double> mod(vec<4, double> const& x, double y); template vec<4, double> mod(vec<4, double> const& x, vec<4, double> const& y); template double modf<double>(double x, double& i); template vec<4, double> modf<4, double>(vec<4, double> const& x, vec<4, double>& i); template vec<4, bool> isnan(vec<4, double> const& x); template vec<4, bool> isinf(vec<4, double> const& x); template double frexp(double x, int& exp); template vec<4, double> frexp(vec<4, double> const& v, vec<4, int>& exp); template double ldexp(double const& x, int const& exp); template vec<4, double> ldexp(vec<4, double> const& v, vec<4, int> const& exp);template double smoothstep(double edge0, double edge1, double x); template vec<4, double> smoothstep(double edge0, double edge1, vec<4, double> const& x); template vec<4, double> smoothstep(vec<4, double> const& edge0, vec<4, double> const& edge1, vec<4, double> const& x); template double mod(double x, double y); template double mix(double x, double y, double a); template vec<4, double> mix(vec<4, double> const& x, vec<4, double> const& y, vec<4, double> const& a); template vec<4, double> mix(vec<4, double> const& x, vec<4, double> const& y, double a); template vec<4, float> sign(vec<4, float> const& x); template vec<4, float> floor(vec<4, float> const& x); template vec<4, float> trunc(vec<4, float> const& x); template vec<4, float> round(vec<4, float> const& x); template float roundEven(float x); template vec<4, float> roundEven(vec<4, float> const& x); template vec<4, float> ceil(vec<4, float> const& x); template float fract(float x); template vec<4, float> fract(vec<4, float> const& x); template vec<4, float> mod(vec<4, float> const& x, float y); template vec<4, float> mod(vec<4, float> const& x, vec<4, float> const& y); template float modf<float>(float x, float& i); template vec<4, float> modf<4, float>(vec<4, float> const& x, vec<4, float>& i); template vec<4, bool> isnan(vec<4, float> const& x); template vec<4, bool> isinf(vec<4, float> const& x); template float frexp(float x, int& exp); template vec<4, float> frexp(vec<4, float> const& v, vec<4, int>& exp); template float ldexp(float const& x, int const& exp); template vec<4, float> ldexp(vec<4, float> const& v, vec<4, int> const& exp);template float smoothstep(float edge0, float edge1, float x); template vec<4, float> smoothstep(float edge0, float edge1, vec<4, float> const& x); template vec<4, float> smoothstep(vec<4, float> const& edge0, vec<4, float> const& edge1, vec<4, float> const& x); template float mod(float x, float y); template float mix(float x, float y, float a); template vec<4, float> mix(vec<4, float> const& x, vec<4, float> const& y, vec<4, float> const& a); template vec<4, float> mix(vec<4, float> const& x, vec<4, float> const& y, float a);

}


namespace glm {










    template vec<2, double> pow(vec<2, double> const& base, vec<2, double> const& exponent); template vec<2, double> exp(vec<2, double> const& v); template vec<2, double> log(vec<2, double> const& v); template vec<2, double> exp2(vec<2, double> const& v); template vec<2, double> log2(vec<2, double> const& v); template vec<2, double> sqrt(vec<2, double> const& v); template vec<2, double> inversesqrt(vec<2, double> const& v); template double pow(double base, double exponent); template double exp(double v); template double log(double v); template double exp2(double v); template double log2(double v); template double sqrt<double>(double v); template double inversesqrt(double v); template vec<2, float> pow(vec<2, float> const& base, vec<2, float> const& exponent); template vec<2, float> exp(vec<2, float> const& v); template vec<2, float> log(vec<2, float> const& v); template vec<2, float> exp2(vec<2, float> const& v); template vec<2, float> log2(vec<2, float> const& v); template vec<2, float> sqrt(vec<2, float> const& v); template vec<2, float> inversesqrt(vec<2, float> const& v); template float pow(float base, float exponent); template float exp(float v); template float log(float v); template float exp2(float v); template float log2(float v); template float sqrt<float>(float v); template float inversesqrt(float v); template vec<3, double> pow(vec<3, double> const& base, vec<3, double> const& exponent); template vec<3, double> exp(vec<3, double> const& v); template vec<3, double> log(vec<3, double> const& v); template vec<3, double> exp2(vec<3, double> const& v); template vec<3, double> log2(vec<3, double> const& v); template vec<3, double> sqrt(vec<3, double> const& v); template vec<3, double> inversesqrt(vec<3, double> const& v); template double pow(double base, double exponent); template double exp(double v); template double log(double v); template double exp2(double v); template double log2(double v); template double sqrt<double>(double v); template double inversesqrt(double v); template vec<3, float> pow(vec<3, float> const& base, vec<3, float> const& exponent); template vec<3, float> exp(vec<3, float> const& v); template vec<3, float> log(vec<3, float> const& v); template vec<3, float> exp2(vec<3, float> const& v); template vec<3, float> log2(vec<3, float> const& v); template vec<3, float> sqrt(vec<3, float> const& v); template vec<3, float> inversesqrt(vec<3, float> const& v); template float pow(float base, float exponent); template float exp(float v); template float log(float v); template float exp2(float v); template float log2(float v); template float sqrt<float>(float v); template float inversesqrt(float v); template vec<4, double> pow(vec<4, double> const& base, vec<4, double> const& exponent); template vec<4, double> exp(vec<4, double> const& v); template vec<4, double> log(vec<4, double> const& v); template vec<4, double> exp2(vec<4, double> const& v); template vec<4, double> log2(vec<4, double> const& v); template vec<4, double> sqrt(vec<4, double> const& v); template vec<4, double> inversesqrt(vec<4, double> const& v); template double pow(double base, double exponent); template double exp(double v); template double log(double v); template double exp2(double v); template double log2(double v); template double sqrt<double>(double v); template double inversesqrt(double v); template vec<4, float> pow(vec<4, float> const& base, vec<4, float> const& exponent); template vec<4, float> exp(vec<4, float> const& v); template vec<4, float> log(vec<4, float> const& v); template vec<4, float> exp2(vec<4, float> const& v); template vec<4, float> log2(vec<4, float> const& v); template vec<4, float> sqrt(vec<4, float> const& v); template vec<4, float> inversesqrt(vec<4, float> const& v); template float pow(float base, float exponent); template float exp(float v); template float log(float v); template float exp2(float v); template float log2(float v); template float sqrt<float>(float v); template float inversesqrt(float v);


}
